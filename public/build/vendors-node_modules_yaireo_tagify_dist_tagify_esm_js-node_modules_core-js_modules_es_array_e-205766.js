(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_yaireo_tagify_dist_tagify_esm_js-node_modules_core-js_modules_es_array_e-205766"],{

/***/ "./node_modules/@yaireo/tagify/dist/tagify.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@yaireo/tagify/dist/tagify.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tagify)
/* harmony export */ });
/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/**
 * Tagify (v 4.9.4) - tags input component
 * By Yair Even-Or
 * Don't sell this code. (c)
 * https://github.com/yairEO/tagify
 */

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

// console.json = console.json || function(argument){
//     for(var arg=0; arg < arguments.length; ++arg)
//         console.log(  JSON.stringify(arguments[arg], null, 4)  )
// }
// const isEdge = /Edge/.test(navigator.userAgent)
const sameStr = (s1, s2, caseSensitive, trim) => {
  // cast to String
  s1 = "" + s1;
  s2 = "" + s2;

  if (trim) {
    s1 = s1.trim();
    s2 = s2.trim();
  }

  return caseSensitive ? s1 == s2 : s1.toLowerCase() == s2.toLowerCase();
}; // const getUID = () => (new Date().getTime() + Math.floor((Math.random()*10000)+1)).toString(16)

const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map(v => omit(v, unwantedProps));
function omit(obj, props) {
  var newObj = {},
      p;

  for (p in obj) if (props.indexOf(p) < 0) newObj[p] = obj[p];

  return newObj;
}
function decode(s) {
  var el = document.createElement('div');
  return s.replace(/\&#?[0-9a-z]+;/gi, function (enc) {
    el.innerHTML = enc;
    return el.innerText;
  });
}
/**
 * utility method
 * https://stackoverflow.com/a/35385518/104380
 * @param  {String} s [HTML string]
 * @return {Object}   [DOM node]
 */

function parseHTML(s) {
  var parser = new DOMParser(),
      node = parser.parseFromString(s.trim(), "text/html");
  return node.body.firstElementChild;
}
/**
 * Removed new lines and irrelevant spaces which might affect layout, and are better gone
 * @param {string} s [HTML string]
 */

function minify(s) {
  return s ? s.replace(/\>[\r\n ]+\</g, "><").replace(/(<.*?>)|\s+/g, (m, $1) => $1 ? $1 : ' ') // https://stackoverflow.com/a/44841484/104380
  : "";
}
function removeTextChildNodes(elm) {
  var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false),
      textnode; // print all text nodes

  while (textnode = iter.nextNode()) {
    if (!textnode.textContent.trim()) textnode.parentNode.removeChild(textnode);
  }
}
function getfirstTextNode(elm, action) {
  action = action || 'previous';

  while (elm = elm[action + 'Sibling']) if (elm.nodeType == 3) return elm;
}
/**
 * utility method
 * https://stackoverflow.com/a/6234804/104380
 */

function escapeHTML(s) {
  return typeof s == 'string' ? s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : s;
}
/**
 * Checks if an argument is a javascript Object
 */

function isObject(obj) {
  var type = Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);
  return obj === Object(obj) && type != 'Array' && type != 'Function' && type != 'RegExp' && type != 'HTMLUnknownElement';
}
/**
 * merge objects into a single new one
 * TEST: extend({}, {a:{foo:1}, b:[]}, {a:{bar:2}, b:[1], c:()=>{}})
 */

function extend(o, o1, o2) {
  if (!(o instanceof Object)) o = {};
  copy(o, o1);
  if (o2) copy(o, o2);

  function copy(a, b) {
    // copy o2 to o
    for (var key in b) if (b.hasOwnProperty(key)) {
      if (isObject(b[key])) {
        if (!isObject(a[key])) a[key] = Object.assign({}, b[key]);else copy(a[key], b[key]);
        continue;
      }

      if (Array.isArray(b[key])) {
        a[key] = Object.assign([], b[key]);
        continue;
      }

      a[key] = b[key];
    }
  }

  return o;
}
/**
 * concatenates N arrays without dups.
 * If an array's item is an Object, compare by `value`
 */

function concatWithoutDups() {
  const newArr = [],
        existingObj = {};

  for (let arr of arguments) {
    for (let item of arr) {
      // if current item is an object which has yet to be added to the new array
      if (isObject(item)) {
        if (!existingObj[item.value]) {
          newArr.push(item);
          existingObj[item.value] = 1;
        }
      } // if current item is not an object and is not in the new array
      else if (!newArr.includes(item)) newArr.push(item);
    }
  }

  return newArr;
}
/**
 *  Extracted from: https://stackoverflow.com/a/37511463/104380
 * @param {String} s
 */

function unaccent(s) {
  // if not supported, do not continue.
  // developers should use a polyfill:
  // https://github.com/walling/unorm
  if (!String.prototype.normalize) return s;
  if (typeof s === 'string') return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
/**
 * Meassures an element's height, which might yet have been added DOM
 * https://stackoverflow.com/q/5944038/104380
 * @param {DOM} node
 */

function getNodeHeight(node) {
  var height,
      clone = node.cloneNode(true);
  clone.style.cssText = "position:fixed; top:-9999px; opacity:0";
  document.body.appendChild(clone);
  height = clone.clientHeight;
  clone.parentNode.removeChild(clone);
  return height;
}
var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
function getUID() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}
function isNodeTag(node) {
  return node && node.classList && node.classList.contains(this.settings.classNames.tag);
}

var DEFAULTS = {
  delimiters: ",",
  // [RegEx] split tags by any of these delimiters ("null" to cancel) Example: ",| |."
  pattern: null,
  // RegEx pattern to validate input by. Ex: /[1-9]/
  tagTextProp: 'value',
  // tag data Object property which will be displayed as the tag's text
  maxTags: Infinity,
  // Maximum number of tags
  callbacks: {},
  // Exposed callbacks object to be triggered on certain events
  addTagOnBlur: true,
  // Flag - automatically adds the text which was inputed as a tag when blur event happens
  duplicates: false,
  // Flag - allow tuplicate tags
  whitelist: [],
  // Array of tags to suggest as the user types (can be used along with "enforceWhitelist" setting)
  blacklist: [],
  // A list of non-allowed tags
  enforceWhitelist: false,
  // Flag - Only allow tags from the whitelist
  userInput: true,
  // Flag - disable manually typing/pasting/editing tags (tags may only be added from the whitelist)
  keepInvalidTags: false,
  // Flag - if true, do not remove tags which did not pass validation
  mixTagsAllowedAfter: /,|\.|\:|\s/,
  // RegEx - Define conditions in which mix-tags content allows a tag to be added after
  mixTagsInterpolator: ['[[', ']]'],
  // Interpolation for mix mode. Everything between this will becmoe a tag
  backspace: true,
  // false / true / "edit"
  skipInvalid: false,
  // If `true`, do not add invalid, temporary, tags before automatically removing them
  pasteAsTags: true,
  // automatically converts pasted text into tags. if "false", allows for further text editing
  editTags: {
    clicks: 2,
    // clicks to enter "edit-mode": 1 for single click. any other value is considered as double-click
    keepInvalid: true // keeps invalid edits as-is until `esc` is pressed while in focus

  },
  // 1 or 2 clicks to edit a tag. false/null for not allowing editing
  transformTag: () => {},
  // Takes a tag input string as argument and returns a transformed value
  trim: true,
  // whether or not the value provided should be trimmed, before being added as a tag
  a11y: {
    focusableTags: false
  },
  mixMode: {
    insertAfterTag: '\u00A0' // String/Node to inject after a tag has been added (see #588)

  },
  autoComplete: {
    enabled: true,
    // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text
    rightKey: false // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to "true"

  },
  classNames: {
    namespace: 'tagify',
    mixMode: 'tagify--mix',
    selectMode: 'tagify--select',
    input: 'tagify__input',
    focus: 'tagify--focus',
    tag: 'tagify__tag',
    tagNoAnimation: 'tagify--noAnim',
    tagInvalid: 'tagify--invalid',
    tagNotAllowed: 'tagify--notAllowed',
    inputInvalid: 'tagify__input--invalid',
    tagX: 'tagify__tag__removeBtn',
    tagText: 'tagify__tag-text',
    dropdown: 'tagify__dropdown',
    dropdownWrapper: 'tagify__dropdown__wrapper',
    dropdownItem: 'tagify__dropdown__item',
    dropdownItemActive: 'tagify__dropdown__item--active',
    dropdownInital: 'tagify__dropdown--initial',
    scopeLoading: 'tagify--loading',
    tagLoading: 'tagify__tag--loading',
    tagEditing: 'tagify__tag--editable',
    tagFlash: 'tagify__tag--flash',
    tagHide: 'tagify__tag--hide',
    hasMaxTags: 'tagify--hasMaxTags',
    hasNoTags: 'tagify--noTags',
    empty: 'tagify--empty'
  },
  dropdown: {
    classname: '',
    enabled: 2,
    // minimum input characters to be typed for the suggestions dropdown to show
    maxItems: 10,
    searchKeys: ["value", "searchBy"],
    fuzzySearch: true,
    caseSensitive: false,
    accentedSearch: true,
    highlightFirst: false,
    // highlights first-matched item in the list
    closeOnSelect: true,
    // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)
    clearOnSelect: true,
    // after selecting a suggetion, should the typed text input remain or be cleared
    position: 'all',
    // 'manual' / 'text' / 'all'
    appendTarget: null // defaults to document.body one DOM has been loaded

  },
  hooks: {
    beforeRemoveTag: () => Promise.resolve(),
    beforePaste: () => Promise.resolve(),
    suggestionClick: () => Promise.resolve()
  }
};

function initDropdown() {
  this.dropdown = {};

  for (let p in this._dropdown) this.dropdown[p] = typeof this._dropdown[p] === 'function' ? this._dropdown[p].bind(this) : this._dropdown[p];

  if (this.settings.dropdown.enabled >= 0) this.dropdown.init();
}
var _dropdown = {
  init() {
    this.DOM.dropdown = this.parseTemplate('dropdown', [this.settings]);
    this.DOM.dropdown.content = this.DOM.dropdown.querySelector(this.settings.classNames.dropdownWrapperSelector);
  },

  /**
   * shows the suggestions select box
   * @param {String} value [optional, filter the whitelist by this value]
   */
  show(value) {
    var _s = this.settings,
        firstListItem,
        firstListItemValue,
        allowNewTags = _s.mode == 'mix' && !_s.enforceWhitelist,
        noWhitelist = !_s.whitelist || !_s.whitelist.length,
        noMatchListItem,
        isManual = _s.dropdown.position == 'manual'; // if text still exists in the input, and `show` method has no argument, then the input's text should be used

    value = value === undefined ? this.state.inputText : value; // ⚠️ Do not render suggestions list  if:
    // 1. there's no whitelist (can happen while async loading) AND new tags arn't allowed
    // 2. dropdown is disabled
    // 3. loader is showing (controlled outside of this code)

    if (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch || _s.dropdown.enable === false || this.state.isLoading) return;
    clearTimeout(this.dropdownHide__bindEventsTimeout); // if no value was supplied, show all the "whitelist" items in the dropdown
    // @type [Array] listItems
    // TODO: add a Setting to control items' sort order for "listItems"

    this.suggestedListItems = this.dropdown.filterListItems(value); // trigger at this exact point to let the developer the chance to manually set "this.suggestedListItems"

    if (value && !this.suggestedListItems.length) {
      this.trigger('dropdown:noMatch', value);
      if (_s.templates.dropdownItemNoMatch) noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {
        value
      });
    } // if "dropdownItemNoMatch" was no defined, procceed regular flow.
    //


    if (!noMatchListItem) {
      // in mix-mode, if the value isn't included in the whilelist & "enforceWhitelist" setting is "false",
      // then add a custom suggestion item to the dropdown
      if (this.suggestedListItems.length) {
        if (value && allowNewTags && !this.state.editing.scope && !sameStr(this.suggestedListItems[0].value, value)) this.suggestedListItems.unshift({
          value
        });
      } else {
        if (value && allowNewTags && !this.state.editing.scope) {
          this.suggestedListItems = [{
            value
          }];
        } // hide suggestions list if no suggestion matched
        else {
          this.input.autocomplete.suggest.call(this);
          this.dropdown.hide();
          return;
        }
      }

      firstListItem = this.suggestedListItems[0];
      firstListItemValue = "" + (isObject(firstListItem) ? firstListItem.value : firstListItem);

      if (_s.autoComplete && firstListItemValue) {
        // only fill the sugegstion if the value of the first list item STARTS with the input value (regardless of "fuzzysearch" setting)
        if (firstListItemValue.indexOf(value) == 0) this.input.autocomplete.suggest.call(this, firstListItem);
      }
    }

    this.dropdown.fill(noMatchListItem);
    if (_s.dropdown.highlightFirst) this.dropdown.highlightOption(this.DOM.dropdown.content.children[0]); // bind events, exactly at this stage of the code. "dropdown.show" method is allowed to be
    // called multiple times, regardless if the dropdown is currently visible, but the events-binding
    // should only be called if the dropdown wasn't previously visible.

    if (!this.state.dropdown.visible) // timeout is needed for when pressing arrow down to show the dropdown,
      // so the key event won't get registered in the dropdown events listeners
      setTimeout(this.dropdown.events.binding.bind(this)); // set the dropdown visible state to be the same as the searched value.
    // MUST be set *before* position() is called

    this.state.dropdown.visible = value || true;
    this.state.dropdown.query = value;
    this.setStateSelection(); // try to positioning the dropdown (it might not yet be on the page, doesn't matter, next code handles this)

    if (!isManual) {
      // a slight delay is needed if the dropdown "position" setting is "text", and nothing was typed in the input,
      // so sadly the "getCaretGlobalPosition" method doesn't recognize the caret position without this delay
      setTimeout(() => {
        this.dropdown.position();
        this.dropdown.render();
      });
    } // a delay is needed because of the previous delay reason.
    // this event must be fired after the dropdown was rendered & positioned


    setTimeout(() => {
      this.trigger("dropdown:show", this.DOM.dropdown);
    });
  },

  /**
   * Hides the dropdown (if it's not managed manually by the developer)
   * @param {Boolean} overrideManual
   */
  hide(overrideManual) {
    var _this$DOM = this.DOM,
        scope = _this$DOM.scope,
        dropdown = _this$DOM.dropdown,
        isManual = this.settings.dropdown.position == 'manual' && !overrideManual; // if there's no dropdown, this means the dropdown events aren't binded

    if (!dropdown || !document.body.contains(dropdown) || isManual) return;
    window.removeEventListener('resize', this.dropdown.position);
    this.dropdown.events.binding.call(this, false); // unbind all events
    // if the dropdown is open, and the input (scope) is clicked,
    // the dropdown should be now "close", and the next click (on the scope)
    // should re-open it, and without a timeout, clicking to close will re-open immediately
    //  clearTimeout(this.dropdownHide__bindEventsTimeout)
    //  this.dropdownHide__bindEventsTimeout = setTimeout(this.events.binding.bind(this), 250)  // re-bind main events

    scope.setAttribute("aria-expanded", false);
    dropdown.parentNode.removeChild(dropdown); // scenario: clicking the scope to show the dropdown, clicking again to hide -> calls dropdown.hide() and then re-focuses the input
    // which casues another onFocus event, which checked "this.state.dropdown.visible" and see it as "false" and re-open the dropdown

    setTimeout(() => {
      this.state.dropdown.visible = false;
    }, 100);
    this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null; // if the user closed the dropdown (in mix-mode) while a potential tag was detected, flag the current tag
    // so the dropdown won't be shown on following user input for that "tag"

    if (this.state.tag && this.state.tag.value.length) {
      this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag;
    }

    this.trigger("dropdown:hide", dropdown);
    return this;
  },

  /**
   * Toggles dropdown show/hide
   * @param {Boolean} show forces the dropdown to show
   */
  toggle(show) {
    this.dropdown[this.state.dropdown.visible && !show ? 'hide' : 'show']();
  },

  render() {
    // let the element render in the DOM first, to accurately measure it.
    // this.DOM.dropdown.style.cssText = "left:-9999px; top:-9999px;";
    var ddHeight = getNodeHeight(this.DOM.dropdown),
        _s = this.settings;
    this.DOM.scope.setAttribute("aria-expanded", true); // if the dropdown has yet to be appended to the DOM,
    // append the dropdown to the body element & handle events

    if (!document.body.contains(this.DOM.dropdown)) {
      this.DOM.dropdown.classList.add(_s.classNames.dropdownInital);
      this.dropdown.position(ddHeight);

      _s.dropdown.appendTarget.appendChild(this.DOM.dropdown);

      setTimeout(() => this.DOM.dropdown.classList.remove(_s.classNames.dropdownInital));
    }

    return this;
  },

  /**
   *
   * @param {String/Array} HTMLContent - optional
   */
  fill(HTMLContent) {
    HTMLContent = typeof HTMLContent == 'string' ? HTMLContent : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems);
    this.DOM.dropdown.content.innerHTML = minify(HTMLContent);
  },

  /**
   * fill data into the suggestions list
   * (mainly used to update the list when removing tags, so they will be re-added to the list. not efficient)
   */
  refilter(value) {
    value = value || this.state.dropdown.query || '';
    this.suggestedListItems = this.dropdown.filterListItems(value);
    this.dropdown.fill();
    if (!this.suggestedListItems.length) this.dropdown.hide();
    this.trigger("dropdown:updated", this.DOM.dropdown);
  },

  position(ddHeight) {
    var _sd = this.settings.dropdown;
    if (_sd.position == 'manual') return;
    var rect,
        top,
        bottom,
        left,
        width,
        parentsPositions,
        ddElm = this.DOM.dropdown,
        placeAbove = _sd.placeAbove,
        viewportHeight = document.documentElement.clientHeight,
        viewportWidth = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
        positionTo = viewportWidth > 480 ? _sd.position : 'all',
        ddTarget = this.DOM[positionTo == 'input' ? 'input' : 'scope'];
    ddHeight = ddHeight || ddElm.clientHeight;

    function getParentsPositions(p) {
      var left = 0,
          top = 0;

      while (p) {
        left += p.offsetLeft || 0;
        top += p.offsetTop || 0;
        p = p.parentNode;
      }

      return {
        left,
        top
      };
    }

    if (!this.state.dropdown.visible) return;

    if (positionTo == 'text') {
      rect = this.getCaretGlobalPosition();
      bottom = rect.bottom;
      top = rect.top;
      left = rect.left;
      width = 'auto';
    } else {
      parentsPositions = getParentsPositions(this.settings.dropdown.appendTarget);
      rect = ddTarget.getBoundingClientRect();
      top = rect.top - parentsPositions.top;
      bottom = rect.bottom - 1 - parentsPositions.top;
      left = rect.left - parentsPositions.left;
      width = rect.width + 'px';
    }

    top = Math.floor(top);
    bottom = Math.ceil(bottom);
    placeAbove = placeAbove === undefined ? viewportHeight - rect.bottom < ddHeight : placeAbove; // flip vertically if there is no space for the dropdown below the input

    ddElm.style.cssText = "left:" + (left + window.pageXOffset) + "px; width:" + width + ";" + (placeAbove ? "top: " + (top + window.pageYOffset) + "px" : "top: " + (bottom + window.pageYOffset) + "px");
    ddElm.setAttribute('placement', placeAbove ? "top" : "bottom");
    ddElm.setAttribute('position', positionTo);
  },

  events: {
    /**
     * Events should only be binded when the dropdown is rendered and removed when isn't
     * because there might be multiple Tagify instances on a certain page
     * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]
     */
    binding(bindUnbind = true) {
      // references to the ".bind()" methods must be saved so they could be unbinded later
      var _CB = this.dropdown.events.callbacks,
          // callback-refs
      _CBR = this.listeners.dropdown = this.listeners.dropdown || {
        position: this.dropdown.position.bind(this),
        onKeyDown: _CB.onKeyDown.bind(this),
        onMouseOver: _CB.onMouseOver.bind(this),
        onMouseLeave: _CB.onMouseLeave.bind(this),
        onClick: _CB.onClick.bind(this),
        onScroll: _CB.onScroll.bind(this)
      },
          action = bindUnbind ? 'addEventListener' : 'removeEventListener';

      if (this.settings.dropdown.position != 'manual') {
        window[action]('resize', _CBR.position);
        window[action]('keydown', _CBR.onKeyDown);
      }

      this.DOM.dropdown[action]('mouseover', _CBR.onMouseOver);
      this.DOM.dropdown[action]('mouseleave', _CBR.onMouseLeave);
      this.DOM.dropdown[action]('mousedown', _CBR.onClick);
      this.DOM.dropdown.content[action]('scroll', _CBR.onScroll);
    },

    callbacks: {
      onKeyDown(e) {
        // get the "active" element, and if there was none (yet) active, use first child
        var selectedElm = this.DOM.dropdown.querySelector(this.settings.classNames.dropdownItemActiveSelector),
            selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm);

        switch (e.key) {
          case 'ArrowDown':
          case 'ArrowUp':
          case 'Down': // >IE11

          case 'Up':
            {
              // >IE11
              e.preventDefault();
              var dropdownItems;
              if (selectedElm) selectedElm = selectedElm[(e.key == 'ArrowUp' || e.key == 'Up' ? "previous" : "next") + "ElementSibling"]; // if no element was found, loop

              if (!selectedElm) {
                dropdownItems = this.DOM.dropdown.content.children;
                selectedElm = dropdownItems[e.key == 'ArrowUp' || e.key == 'Up' ? dropdownItems.length - 1 : 0];
              }

              selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm);
              this.dropdown.highlightOption(selectedElm, true);
              break;
            }

          case 'Escape':
          case 'Esc':
            // IE11
            this.dropdown.hide();
            break;

          case 'ArrowRight':
            if (this.state.actions.ArrowLeft) return;

          case 'Tab':
            {
              // in mix-mode, treat arrowRight like Enter key, so a tag will be created
              if (this.settings.mode != 'mix' && selectedElm && !this.settings.autoComplete.rightKey && !this.state.editing) {
                e.preventDefault(); // prevents blur so the autocomplete suggestion will not become a tag

                var value = this.dropdown.getMappedValue(selectedElmData);
                this.input.autocomplete.set.call(this, value);
                return false;
              }

              return true;
            }

          case 'Enter':
            {
              e.preventDefault();
              this.settings.hooks.suggestionClick(e, {
                tagify: this,
                tagData: selectedElmData,
                suggestionElm: selectedElm
              }).then(() => {
                if (selectedElm) return this.dropdown.selectOption(selectedElm);else this.dropdown.hide();
                if (this.settings.mode != 'mix') this.addTags(this.state.inputText.trim(), true);
              }).catch(err => err);
              break;
            }

          case 'Backspace':
            {
              if (this.settings.mode == 'mix' || this.state.editing.scope) return;
              const value = this.input.raw.call(this);

              if (value == "" || value.charCodeAt(0) == 8203) {
                if (this.settings.backspace === true) this.removeTags();else if (this.settings.backspace == 'edit') setTimeout(this.editTag.bind(this), 0);
              }
            }
        }
      },

      onMouseOver(e) {
        var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector); // event delegation check

        ddItem && this.dropdown.highlightOption(ddItem);
      },

      onMouseLeave(e) {
        // de-highlight any previously highlighted option
        this.dropdown.highlightOption();
      },

      onClick(e) {
        if (e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content) return; // allow only mouse left-clicks

        var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector),
            selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm); // temporary set the "actions" state to indicate to the main "blur" event it shouldn't run

        this.state.actions.selectOption = true;
        setTimeout(() => this.state.actions.selectOption = false, 50);
        this.settings.hooks.suggestionClick(e, {
          tagify: this,
          tagData: selectedElmData,
          suggestionElm: selectedElm
        }).then(() => {
          if (selectedElm) this.dropdown.selectOption(selectedElm);else this.dropdown.hide();
        }).catch(err => console.warn(err));
      },

      onScroll(e) {
        var elm = e.target,
            pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;
        this.trigger("dropdown:scroll", {
          percentage: Math.round(pos)
        });
      }

    }
  },

  getSuggestionDataByNode(tagElm) {
    var idx = tagElm ? +tagElm.getAttribute('tagifySuggestionIdx') : -1;
    return this.suggestedListItems[idx] || null;
  },

  /**
   * mark the currently active suggestion option
   * @param {Object}  elm            option DOM node
   * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), aut-scroll to always show the highlighted element
   */
  highlightOption(elm, adjustScroll) {
    var className = this.settings.classNames.dropdownItemActive,
        itemData; // focus casues a bug in Firefox with the placeholder been shown on the input element
    // if( this.settings.dropdown.position != 'manual' )
    //     elm.focus();

    if (this.state.ddItemElm) {
      this.state.ddItemElm.classList.remove(className);
      this.state.ddItemElm.removeAttribute("aria-selected");
    }

    if (!elm) {
      this.state.ddItemData = null;
      this.state.ddItemElm = null;
      this.input.autocomplete.suggest.call(this);
      return;
    }

    itemData = this.suggestedListItems[this.getNodeIndex(elm)];
    this.state.ddItemData = itemData;
    this.state.ddItemElm = elm; // this.DOM.dropdown.querySelectorAll("." + this.settings.classNames.dropdownItemActive).forEach(activeElm => activeElm.classList.remove(className));

    elm.classList.add(className);
    elm.setAttribute("aria-selected", true);
    if (adjustScroll) elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight; // Try to autocomplete the typed value with the currently highlighted dropdown item

    if (this.settings.autoComplete) {
      this.input.autocomplete.suggest.call(this, itemData);
      this.dropdown.position(); // suggestions might alter the height of the tagify wrapper because of unkown suggested term length that could drop to the next line
    }
  },

  /**
   * Create a tag from the currently active suggestion option
   * @param {Object} elm  DOM node to select
   */
  selectOption(elm) {
    var _this$settings$dropdo = this.settings.dropdown,
        clearOnSelect = _this$settings$dropdo.clearOnSelect,
        closeOnSelect = _this$settings$dropdo.closeOnSelect,
        addedTag;

    if (!elm) {
      addedTag = this.addTags(this.state.inputText, true);
      closeOnSelect && this.dropdown.hide();
      return;
    } // if in edit-mode, do not continue but instead replace the tag's text.
    // the scenario is that "addTags" was called from a dropdown suggested option selected while editing


    var tagifySuggestionIdx = elm.getAttribute('tagifySuggestionIdx'),
        tagData = this.suggestedListItems[+tagifySuggestionIdx];
    this.trigger("dropdown:select", {
      data: tagData,
      elm
    }); // The above event must be triggered, regardless of anything else which might go wrong

    if (!tagifySuggestionIdx || !tagData) {
      this.dropdown.hide();
      return;
    }

    if (this.state.editing) // normalizing value, because "tagData" might be a string, and therefore will not be able to extend the object
      this.onEditTagDone(null, extend({
        __isValid: true
      }, this.normalizeTags(tagData)[0])); // Tagify instances should re-focus to the input element once an option was selected, to allow continuous typing
    else {
      addedTag = this[this.settings.mode == 'mix' ? "addMixTags" : "addTags"]([tagData], clearOnSelect);
    } // todo: consider not doing this on mix-mode

    if (!this.DOM.input.parentNode) return;
    setTimeout(() => {
      this.DOM.input.focus();
      this.toggleFocusClass(true);
      this.placeCaretAfterNode(addedTag);
    });

    if (closeOnSelect) {
      setTimeout(this.dropdown.hide.bind(this));
    } else this.dropdown.refilter();
  },

  selectAll() {
    // having suggestedListItems with items messes with "normalizeTags" when wanting
    // to add all tags
    this.suggestedListItems.length = 0;
    this.dropdown.hide(); // some whitelist items might have already been added as tags so when addings all of them,
    // skip adding already-added ones, so best to use "filterListItems" method over "settings.whitelist"

    this.addTags(this.dropdown.filterListItems(''), true);
    return this;
  },

  /**
   * returns an HTML string of the suggestions' list items
   * @param {String} value string to filter the whitelist by
   * @param {Object} options "exact" - for exact complete match
   * @return {Array} list of filtered whitelist items according to the settings provided and current value
   */
  filterListItems(value, options) {
    var _s = this.settings,
        _sd = _s.dropdown,
        options = options || {},
        value = _s.mode == 'select' && this.value.length && this.value[0][_s.tagTextProp] == value ? '' // do not filter if the tag, which is already selecetd in "select" mode, is the same as the typed text
    : value,
        list = [],
        exactMatchesList = [],
        whitelist = _s.whitelist,
        suggestionsCount = _sd.maxItems || Infinity,
        searchKeys = _sd.searchKeys,
        whitelistItem,
        valueIsInWhitelist,
        searchBy,
        isDuplicate,
        niddle,
        i = 0;

    if (!value || !searchKeys.length) {
      return (_s.duplicates ? whitelist : whitelist.filter(item => !this.isTagDuplicate(isObject(item) ? item.value : item)) // don't include tags which have already been added.
      ).slice(0, suggestionsCount); // respect "maxItems" dropdown setting
    }

    niddle = _sd.caseSensitive ? "" + value : ("" + value).toLowerCase(); // checks if ALL of the words in the search query exists in the current whitelist item, regardless of their order

    function stringHasAll(s, query) {
      return query.toLowerCase().split(' ').every(q => s.includes(q.toLowerCase()));
    }

    for (; i < whitelist.length; i++) {
      let startsWithMatch, exactMatch;
      whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : {
        value: whitelist[i]
      }; //normalize value as an Object

      let itemWithoutSearchKeys = !Object.keys(whitelistItem).some(k => searchKeys.includes(k)),
          _searchKeys = itemWithoutSearchKeys ? ["value"] : searchKeys;

      if (_sd.fuzzySearch && !options.exact) {
        searchBy = _searchKeys.reduce((values, k) => values + " " + (whitelistItem[k] || ""), "").toLowerCase().trim();

        if (_sd.accentedSearch) {
          searchBy = unaccent(searchBy);
          niddle = unaccent(niddle);
        }

        startsWithMatch = searchBy.indexOf(niddle) == 0;
        exactMatch = searchBy === niddle;
        valueIsInWhitelist = stringHasAll(searchBy, niddle);
      } else {
        startsWithMatch = true;
        valueIsInWhitelist = _searchKeys.some(k => {
          var v = '' + (whitelistItem[k] || ''); // if key exists, cast to type String

          if (_sd.accentedSearch) {
            v = unaccent(v);
            niddle = unaccent(niddle);
          }

          if (!_sd.caseSensitive) v = v.toLowerCase();
          exactMatch = v === niddle;
          return options.exact ? v === niddle : v.indexOf(niddle) == 0;
        });
      }

      isDuplicate = !_s.duplicates && this.isTagDuplicate(isObject(whitelistItem) ? whitelistItem.value : whitelistItem); // match for the value within each "whitelist" item

      if (valueIsInWhitelist && !isDuplicate) if (exactMatch && startsWithMatch) exactMatchesList.push(whitelistItem);else if (_sd.sortby == 'startsWith' && startsWithMatch) list.unshift(whitelistItem);else list.push(whitelistItem);
    } // custom sorting function


    return typeof _sd.sortby == 'function' ? _sd.sortby(exactMatchesList.concat(list), niddle) : exactMatchesList.concat(list).slice(0, suggestionsCount);
  },

  /**
   * Returns the final value of a tag data (object) with regards to the "mapValueTo" dropdown setting
   * @param {Object} tagData
   * @returns
   */
  getMappedValue(tagData) {
    var mapValueTo = this.settings.dropdown.mapValueTo,
        value = mapValueTo ? typeof mapValueTo == 'function' ? mapValueTo(tagData) : tagData[mapValueTo] || tagData.value : tagData.value;
    return value;
  },

  /**
   * Creates the dropdown items' HTML
   * @param  {Array} list  [Array of Objects]
   * @return {String}
   */
  createListHTML(optionsArr) {
    return extend([], optionsArr).map((suggestion, idx) => {
      if (typeof suggestion == 'string' || typeof suggestion == 'number') suggestion = {
        value: suggestion
      };
      var value = this.dropdown.getMappedValue(suggestion);
      suggestion.value = value && typeof value == 'string' ? escapeHTML(value) : value;
      var tagHTMLString = this.settings.templates.dropdownItem.apply(this, [suggestion, this]); // make sure the sugestion index is present as attribute, to match the data when one is selected

      tagHTMLString = tagHTMLString.replace(/\s*tagifySuggestionIdx=(["'])(.*?)\1/gmi, '') // remove the "tagifySuggestionIdx" attribute if for some reason was there
      .replace('>', ` tagifySuggestionIdx="${idx}">`); // add "tagifySuggestionIdx"

      return tagHTMLString;
    }).join("");
  }

};

const VERSION = 1; // current version of persisted data. if code change breaks persisted data, verison number should be bumped.

const STORE_KEY = '@yaireo/tagify/';
const getPersistedData = id => key => {
  // if "persist" is "false", do not save to localstorage
  let customKey = '/' + key,
      persistedData,
      versionMatch = localStorage.getItem(STORE_KEY + id + '/v', VERSION) == VERSION;

  if (versionMatch) {
    try {
      persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]);
    } catch (err) {}
  }

  return persistedData;
};
const setPersistedData = id => {
  if (!id) return () => {}; // for storage invalidation

  localStorage.setItem(STORE_KEY + id + '/v', VERSION);
  return (data, key) => {
    let customKey = '/' + key,
        persistedData = JSON.stringify(data);

    if (data && key) {
      localStorage.setItem(STORE_KEY + id + customKey, persistedData);
      dispatchEvent(new Event('storage'));
    }
  };
};
const clearPersistedData = id => key => {
  const base = STORE_KEY + '/' + id + '/'; // delete specific key in the storage

  if (key) localStorage.removeItem(base + key); // delete all keys in the storage with a specific tagify id
  else {
    for (let k in localStorage) if (k.includes(base)) localStorage.removeItem(k);
  }
};

var TEXTS = {
  empty: "empty",
  exceed: "number of tags exceeded",
  pattern: "pattern mismatch",
  duplicate: "already exists",
  notAllowed: "not allowed"
};

var templates = {
  /**
   *
   * @param {DOM Object} input     Original input DOm element
   * @param {Object}     settings  Tagify instance settings Object
   */
  wrapper(input, _s) {
    return `<tags class="${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + "Mode"]}` : ""} ${input.className}"
                    ${_s.readonly ? 'readonly' : ''}
                    ${_s.disabled ? 'disabled' : ''}
                    ${_s.required ? 'required' : ''}
                    tabIndex="-1">
            <span ${!_s.readonly && _s.userInput ? 'contenteditable' : ''} tabIndex="0" data-placeholder="${_s.placeholder || '&#8203;'}" aria-placeholder="${_s.placeholder || ''}"
                class="${_s.classNames.input}"
                role="textbox"
                aria-autocomplete="both"
                aria-multiline="${_s.mode == 'mix' ? true : false}"></span>
                &#8203;
        </tags>`;
  },

  tag(tagData, tagify) {
    var _s = this.settings;
    return `<tag title="${tagData.title || tagData.value}"
                    contenteditable='false'
                    spellcheck='false'
                    tabIndex="${_s.a11y.focusableTags ? 0 : -1}"
                    class="${_s.classNames.tag} ${tagData.class || ""}"
                    ${this.getAttributes(tagData)}>
            <x title='' class="${_s.classNames.tagX}" role='button' aria-label='remove tag'></x>
            <div>
                <span class="${_s.classNames.tagText}">${tagData[_s.tagTextProp] || tagData.value}</span>
            </div>
        </tag>`;
  },

  dropdown(settings) {
    var _sd = settings.dropdown,
        isManual = _sd.position == 'manual',
        className = `${settings.classNames.dropdown}`;
    return `<div class="${isManual ? "" : className} ${_sd.classname}" role="listbox" aria-labelledby="dropdown">
                    <div class="${settings.classNames.dropdownWrapper}"></div>
                </div>`;
  },

  dropdownItem(item, tagify) {
    return `<div ${this.getAttributes(item)}
                    class='${this.settings.classNames.dropdownItem} ${item.class ? item.class : ""}'
                    tabindex="0"
                    role="option">${item.value}</div>`;
  },

  dropdownItemNoMatch: null
};

function EventDispatcher(instance) {
  // Create a DOM EventTarget object
  var target = document.createTextNode('');

  function addRemove(op, events, cb) {
    if (cb) events.split(/\s+/g).forEach(name => target[op + 'EventListener'].call(target, name, cb));
  } // Pass EventTarget interface calls to DOM EventTarget object


  return {
    off(events, cb) {
      addRemove('remove', events, cb);
      return this;
    },

    on(events, cb) {
      if (cb && typeof cb == 'function') addRemove('add', events, cb);
      return this;
    },

    trigger(eventName, data, opts) {
      var e;
      opts = opts || {
        cloneData: true
      };
      if (!eventName) return;

      if (instance.settings.isJQueryPlugin) {
        if (eventName == 'remove') eventName = 'removeTag'; // issue #222

        jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data]);
      } else {
        try {
          var eventData = typeof data === 'object' ? data : {
            value: data
          };
          eventData = opts.cloneData ? extend({}, eventData) : eventData;
          eventData.tagify = this; // TODO: move the below to the "extend" function

          if (data instanceof Object) for (var prop in data) if (data[prop] instanceof HTMLElement) eventData[prop] = data[prop];
          e = new CustomEvent(eventName, {
            "detail": eventData
          });
        } catch (err) {
          console.warn(err);
        }

        target.dispatchEvent(e);
      }
    }

  };
}

var deleteBackspaceTimeout;
function triggerChangeEvent() {
  if (this.settings.mixMode.integrated) return;
  var inputElm = this.DOM.originalInput,
      changed = this.state.lastOriginalValueReported !== inputElm.value,
      event = new CustomEvent("change", {
    bubbles: true
  }); // must use "CustomEvent" and not "Event" to support IE

  if (!changed) return; // must apply this BEFORE triggering the simulated event

  this.state.lastOriginalValueReported = inputElm.value; // React hack: https://github.com/facebook/react/issues/11488

  event.simulated = true;
  if (inputElm._valueTracker) inputElm._valueTracker.setValue(Math.random());
  inputElm.dispatchEvent(event); // also trigger a Tagify event

  this.trigger("change", this.state.lastOriginalValueReported); // React, for some reason, clears the input's value after "dispatchEvent" is fired

  inputElm.value = this.state.lastOriginalValueReported;
}
var events = {
  // bind custom events which were passed in the settings
  customBinding() {
    this.customEventsList.forEach(name => {
      this.on(name, this.settings.callbacks[name]);
    });
  },

  binding(bindUnbind = true) {
    var _CB = this.events.callbacks,
        _CBR,
        action = bindUnbind ? 'addEventListener' : 'removeEventListener'; // do not allow the main events to be bound more than once


    if (this.state.mainEvents && bindUnbind) return; // set the binding state of the main events, so they will not be bound more than once

    this.state.mainEvents = bindUnbind; // everything inside gets executed only once-per instance

    if (bindUnbind && !this.listeners.main) {
      this.events.bindGlobal.call(this);
      if (this.settings.isJQueryPlugin) jQuery(this.DOM.originalInput).on('tagify.removeAllTags', this.removeAllTags.bind(this));
    } // setup callback references so events could be removed later


    _CBR = this.listeners.main = this.listeners.main || {
      focus: ['input', _CB.onFocusBlur.bind(this)],
      keydown: ['input', _CB.onKeydown.bind(this)],
      click: ['scope', _CB.onClickScope.bind(this)],
      dblclick: ['scope', _CB.onDoubleClickScope.bind(this)],
      paste: ['input', _CB.onPaste.bind(this)],
      drop: ['input', _CB.onDrop.bind(this)]
    };

    for (var eventName in _CBR) {
      this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);
    } // listen to original input changes (unfortunetly this is the best way...)
    // https://stackoverflow.com/a/1949416/104380


    clearInterval(this.listeners.main.originalInputValueObserverInterval);
    this.listeners.main.originalInputValueObserverInterval = setInterval(_CB.observeOriginalInputValue.bind(this), 500); // observers

    var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this)); // cleaup just-in-case

    if (inputMutationObserver) inputMutationObserver.disconnect(); // observe stuff

    if (this.settings.mode == 'mix') inputMutationObserver.observe(this.DOM.input, {
      childList: true
    });
  },

  bindGlobal(unbind) {
    var _CB = this.events.callbacks,
        action = unbind ? 'removeEventListener' : 'addEventListener',
        e;
    if (!unbind && this.listeners.global) return; // do not re-bind
    // these events are global event should never be unbinded, unless the instance is destroyed:

    this.listeners.global = this.listeners && this.listeners.global || [{
      type: this.isIE ? 'keydown' : 'input',
      // IE cannot register "input" events on contenteditable elements, so the "keydown" should be used instead..
      target: this.DOM.input,
      cb: _CB[this.isIE ? 'onInputIE' : 'onInput'].bind(this)
    }, {
      type: 'keydown',
      target: window,
      cb: _CB.onWindowKeyDown.bind(this)
    }, {
      type: 'blur',
      target: this.DOM.input,
      cb: _CB.onFocusBlur.bind(this)
    }];

    for (e of this.listeners.global) e.target[action](e.type, e.cb);
  },

  unbindGlobal() {
    this.events.bindGlobal.call(this, true);
  },

  /**
   * DOM events callbacks
   */
  callbacks: {
    onFocusBlur(e) {
      var text = e.target ? this.trim(e.target.textContent) : '',
          // a string
      _s = this.settings,
          type = e.type,
          ddEnabled = _s.dropdown.enabled >= 0,
          eventData = {
        relatedTarget: e.relatedTarget
      },
          isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect),
          isTargetAddNewBtn = this.state.actions.addNew && ddEnabled,
          isRelatedTargetX = e.relatedTarget && isNodeTag.call(this, e.relatedTarget) && this.DOM.scope.contains(e.relatedTarget),
          shouldAddTags;

      if (type == 'blur') {
        if (e.relatedTarget === this.DOM.scope) {
          this.dropdown.hide();
          this.DOM.input.focus();
          return;
        }

        this.postUpdate();
        this.triggerChangeEvent();
      }

      if (isTargetSelectOption || isTargetAddNewBtn) return;
      this.state.hasFocus = type == "focus" ? +new Date() : false;
      this.toggleFocusClass(this.state.hasFocus);

      if (_s.mode == 'mix') {
        if (type == "focus") {
          this.trigger("focus", eventData);
        } else if (e.type == "blur") {
          this.trigger("blur", eventData);
          this.loading(false);
          this.dropdown.hide(); // reset state which needs reseting

          this.state.dropdown.visible = undefined;
          this.setStateSelection();
        }

        return;
      }

      if (type == "focus") {
        this.trigger("focus", eventData); //  e.target.classList.remove('placeholder');

        if (_s.dropdown.enabled === 0 || !_s.userInput) {
          // && _s.mode != "select"
          this.dropdown.show(this.value.length ? '' : undefined);
        }

        return;
      } else if (type == "blur") {
        this.trigger("blur", eventData);
        this.loading(false); // when clicking the X button of a selected tag, it is unwanted it will be added back
        // again in a few more lines of code (shouldAddTags && addTags)

        if (this.settings.mode == 'select' && isRelatedTargetX) text = '';
        shouldAddTags = this.settings.mode == 'select' && text ? !this.value.length || this.value[0].value != text : text && !this.state.actions.selectOption && _s.addTagOnBlur; // do not add a tag if "selectOption" action was just fired (this means a tag was just added from the dropdown)

        shouldAddTags && this.addTags(text, true);
        if (this.settings.mode == 'select' && !text) this.removeTags();
      }

      this.DOM.input.removeAttribute('style');
      this.dropdown.hide();
    },

    onWindowKeyDown(e) {
      var focusedElm = document.activeElement,
          isTag = isNodeTag.call(this, focusedElm),
          isBelong = isTag && this.DOM.scope.contains(document.activeElement),
          nextTag;
      if (!isBelong) return;
      nextTag = focusedElm.nextElementSibling;

      switch (e.key) {
        // remove tag if has focus
        case 'Backspace':
          {
            this.removeTags(focusedElm);
            (nextTag ? nextTag : this.DOM.input).focus();
            break;
          }
        // edit tag if has focus

        case 'Enter':
          {
            setTimeout(this.editTag.bind(this), 0, focusedElm);
            break;
          }
      }
    },

    onKeydown(e) {
      var _s = this.settings;

      if (_s.mode == 'select' && _s.enforceWhitelist && this.value.length && e.key != 'Tab') {
        e.preventDefault();
      }

      var s = this.trim(e.target.textContent);
      this.trigger("keydown", {
        originalEvent: this.cloneEvent(e)
      });
      /**
       * ONLY FOR MIX-MODE:
       */

      if (_s.mode == 'mix') {
        switch (e.key) {
          case 'Left':
          case 'ArrowLeft':
            {
              // when left arrow was pressed, set a flag so when the dropdown is shown, right-arrow will be ignored
              // because it seems likely the user wishes to use the arrows to move the caret
              this.state.actions.ArrowLeft = true;
              break;
            }

          case 'Delete':
          case 'Backspace':
            {
              if (this.state.editing) return;
              var sel = document.getSelection(),
                  deleteKeyTagDetected = e.key == 'Delete' && sel.anchorOffset == (sel.anchorNode.length || 0),
                  prevAnchorSibling = sel.anchorNode.previousSibling,
                  isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling,
                  lastInputValue = decode(this.DOM.input.innerHTML),
                  lastTagElems = this.getTagElms(),
                  //  isCaretInsideTag = sel.anchorNode.parentNode('.' + _s.classNames.tag),
              tagBeforeCaret,
                  tagElmToBeDeleted,
                  firstTextNodeBeforeTag;

              if (_s.backspace == 'edit' && isCaretAfterTag) {
                tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;
                setTimeout(this.editTag.bind(this), 0, tagBeforeCaret); // timeout is needed to the last cahacrter in the edited tag won't get deleted

                e.preventDefault(); // needed so the tag elm won't get deleted

                return;
              }

              if (isChromeAndroidBrowser() && isCaretAfterTag) {
                firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag);
                if (!isCaretAfterTag.hasAttribute('readonly')) isCaretAfterTag.remove(); // since this is Chrome, can safetly use this "new" DOM API
                // Android-Chrome wrongly hides the keyboard, and loses focus,
                // so this hack below is needed to regain focus at the correct place:

                this.DOM.input.focus();
                setTimeout(() => {
                  this.placeCaretAfterNode(firstTextNodeBeforeTag);
                  this.DOM.input.click();
                });
                return;
              }

              if (sel.anchorNode.nodeName == 'BR') return;
              if ((deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1) {
                if (sel.anchorOffset == 0) // caret is at the very begining, before a tag
                  tagElmToBeDeleted = deleteKeyTagDetected // delete key pressed
                  ? lastTagElems[0] : null;else tagElmToBeDeleted = lastTagElems[sel.anchorOffset - 1]; // find out if a tag *might* be a candidate for deletion, and if so, which

              } else if (deleteKeyTagDetected) tagElmToBeDeleted = sel.anchorNode.nextElementSibling;else if (isCaretAfterTag) tagElmToBeDeleted = isCaretAfterTag; // tagElm.hasAttribute('readonly')

              if (sel.anchorNode.nodeType == 3 && // node at caret location is a Text node
              !sel.anchorNode.nodeValue && // has some text
              sel.anchorNode.previousElementSibling) // text node has a Tag node before it
                e.preventDefault(); // if backspace not allowed, do nothing
              // TODO: a better way to detect if nodes were deleted is to simply check the "this.value" before & after

              if ((isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace) {
                e.preventDefault();
                return;
              }

              if (sel.type != 'Range' && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != 'Delete') {
                e.preventDefault();
                return;
              }

              if (sel.type != 'Range' && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute('readonly')) {
                // allows the continuation of deletion by placing the caret on the first previous textNode.
                // since a few readonly-tags might be one after the other, iteration is needed:
                this.placeCaretAfterNode(getfirstTextNode(tagElmToBeDeleted));
                return;
              } // update regarding https://github.com/yairEO/tagify/issues/762#issuecomment-786464317:
              // the bug described is more severe than the fix below, therefore I disable the fix until a solution
              // is found which work well for both cases.
              // -------
              // nodeType is "1" only when the caret is at the end after last tag (no text after), or before first first (no text before)

              /*
              if( this.isFirefox && sel.anchorNode.nodeType == 1 && sel.anchorOffset != 0 ){
                  this.removeTags() // removes last tag by default if no parameter supplied
                  // place caret inside last textNode, if exist. it's an annoying bug only in FF,
                  // if the last tag is removed, and there is a textNode before it, the caret is not placed at its end
                  this.placeCaretAfterNode( this.setRangeAtStartEnd() )
              }
              */


              clearTimeout(deleteBackspaceTimeout); // a minimum delay is needed before the node actually gets detached from the document (don't know why),
              // to know exactly which tag was deleted. This is the easiest way of knowing besides using MutationObserver

              deleteBackspaceTimeout = setTimeout(() => {
                var sel = document.getSelection(),
                    currentValue = decode(this.DOM.input.innerHTML),
                    prevElm = !deleteKeyTagDetected && sel.anchorNode.previousSibling; // fixes #384, where the first and only tag will not get removed with backspace

                if (currentValue.length >= lastInputValue.length && prevElm) {
                  if (isNodeTag.call(this, prevElm) && !prevElm.hasAttribute('readonly')) {
                    this.removeTags(prevElm);
                    this.fixFirefoxLastTagNoCaret(); // the above "removeTag" methods removes the tag with a transition. Chrome adds a <br> element for some reason at this stage

                    if (this.DOM.input.children.length == 2 && this.DOM.input.children[1].tagName == "BR") {
                      this.DOM.input.innerHTML = "";
                      this.value.length = 0;
                      return true;
                    }
                  } else prevElm.remove();
                } // find out which tag(s) were deleted and trigger "remove" event
                // iterate over the list of tags still in the document and then filter only those from the "this.value" collection


                this.value = [].map.call(lastTagElems, (node, nodeIdx) => {
                  var tagData = this.tagData(node); // since readonly cannot be removed (it's technically resurrected if removed somehow)

                  if (node.parentNode || tagData.readonly) return tagData;else this.trigger('remove', {
                    tag: node,
                    index: nodeIdx,
                    data: tagData
                  });
                }).filter(n => n); // remove empty items in the mapped array
              }, 20); // Firefox needs this higher duration for some reason or things get buggy when deleting text from the end

              break;
            }
          // currently commented to allow new lines in mixed-mode
          // case 'Enter' :
          //     // e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380
        }

        return true;
      }

      switch (e.key) {
        case 'Backspace':
          if (_s.mode == 'select' && _s.enforceWhitelist && this.value.length) this.removeTags();else if (!this.state.dropdown.visible || _s.dropdown.position == 'manual') {
            if (e.target.textContent == "" || s.charCodeAt(0) == 8203) {
              // 8203: ZERO WIDTH SPACE unicode
              if (_s.backspace === true) this.removeTags();else if (_s.backspace == 'edit') setTimeout(this.editTag.bind(this), 0); // timeout reason: when edited tag gets focused and the caret is placed at the end, the last character gets deletec (because of backspace)
            }
          }
          break;

        case 'Esc':
        case 'Escape':
          if (this.state.dropdown.visible) return;
          e.target.blur();
          break;

        case 'Down':
        case 'ArrowDown':
          // if( _s.mode == 'select' ) // issue #333
          if (!this.state.dropdown.visible) this.dropdown.show();
          break;

        case 'ArrowRight':
          {
            let tagData = this.state.inputSuggestion || this.state.ddItemData;

            if (tagData && _s.autoComplete.rightKey) {
              this.addTags([tagData], true);
              return;
            }

            break;
          }

        case 'Tab':
          {
            let selectMode = _s.mode == 'select';
            if (s && !selectMode) e.preventDefault();else return true;
          }

        case 'Enter':
          if (this.state.dropdown.visible || e.keyCode == 229) return;
          e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380
          // because the main "keydown" event is bound before the dropdown events, this will fire first and will not *yet*
          // know if an option was just selected from the dropdown menu. If an option was selected,
          // the dropdown events should handle adding the tag

          setTimeout(() => {
            if (this.state.actions.selectOption) return;
            this.addTags(s, true);
          });
      }
    },

    onInput(e) {
      this.postUpdate(); // toggles "tagify--empty" class

      if (this.settings.mode == 'mix') return this.events.callbacks.onMixTagsInput.call(this, e);
      var value = this.input.normalize.call(this),
          showSuggestions = value.length >= this.settings.dropdown.enabled,
          eventData = {
        value,
        inputElm: this.DOM.input
      };
      eventData.isValid = this.validateTag({
        value
      }); // for IE; since IE doesn't have an "input" event so "keyDown" is used instead to trigger the "onInput" callback,
      // and so many keys do not change the input, and for those do not continue.

      if (this.state.inputText == value) return; // save the value on the input's State object

      this.input.set.call(this, value, false); // update the input with the normalized value and run validations
      // this.setRangeAtStartEnd(); // fix caret position

      if (value.search(this.settings.delimiters) != -1) {
        if (this.addTags(value)) {
          this.input.set.call(this); // clear the input field's value
        }
      } else if (this.settings.dropdown.enabled >= 0) {
        this.dropdown[showSuggestions ? "show" : "hide"](value);
      }

      this.trigger('input', eventData); // "input" event must be triggered at this point, before the dropdown is shown
    },

    onMixTagsInput(e) {
      var rangeText,
          match,
          matchedPatternCount,
          tag,
          showSuggestions,
          selection,
          _s = this.settings,
          lastTagsCount = this.value.length,
          matchFlaggedTag,
          matchDelimiters,
          tagsElems = this.getTagElms(),
          fragment = document.createDocumentFragment(),
          range = window.getSelection().getRangeAt(0),
          remainingTagsValues = [].map.call(tagsElems, node => this.tagData(node).value); // Android Chrome "keydown" event argument does not report the correct "key".
      // this workaround is needed to manually call "onKeydown" method with a synthesized event object

      if (e.inputType == "deleteContentBackward" && isChromeAndroidBrowser()) {
        this.events.callbacks.onKeydown.call(this, {
          target: e.target,
          key: "Backspace"
        });
      } // re-add "readonly" tags which might have been removed


      this.value.slice().forEach(item => {
        if (item.readonly && !remainingTagsValues.includes(item.value)) fragment.appendChild(this.createTagElem(item));
      });

      if (fragment.childNodes.length) {
        range.insertNode(fragment);
        this.setRangeAtStartEnd(false, fragment.lastChild);
      } // check if tags were "magically" added/removed (browser redo/undo or CTRL-A -> delete)


      if (tagsElems.length != lastTagsCount) {
        this.value = [].map.call(this.getTagElms(), node => this.tagData(node));
        this.update({
          withoutChangeEvent: true
        });
        return;
      }

      if (this.hasMaxTags()) return true;

      if (window.getSelection) {
        selection = window.getSelection(); // only detect tags if selection is inside a textNode (not somehow on already-existing tag)

        if (selection.rangeCount > 0 && selection.anchorNode.nodeType == 3) {
          range = selection.getRangeAt(0).cloneRange();
          range.collapse(true);
          range.setStart(selection.focusNode, 0);
          rangeText = range.toString().slice(0, range.endOffset); // slice the range so everything AFTER the caret will be trimmed
          // split = range.toString().split(_s.mixTagsAllowedAfter)  // ["foo", "bar", "@baz"]

          matchedPatternCount = rangeText.split(_s.pattern).length - 1;
          match = rangeText.match(_s.pattern);
          if (match) // tag string, example: "@aaa ccc"
            tag = rangeText.slice(rangeText.lastIndexOf(match[match.length - 1]));

          if (tag) {
            this.state.actions.ArrowLeft = false; // start fresh, assuming the user did not (yet) used any arrow to move the caret

            this.state.tag = {
              prefix: tag.match(_s.pattern)[0],
              value: tag.replace(_s.pattern, '') // get rid of the prefix

            };
            this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length;
            matchDelimiters = this.state.tag.value.match(_s.delimiters); // if a delimeter exists, add the value as tag (exluding the delimiter)

            if (matchDelimiters) {
              this.state.tag.value = this.state.tag.value.replace(_s.delimiters, '');
              this.state.tag.delimiters = matchDelimiters[0];
              this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect);
              this.dropdown.hide();
              return;
            }

            showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled; // When writeing something that might look like a tag (an email address) but isn't one - it is unwanted
            // the suggestions dropdown be shown, so the user closes it (in any way), and while continue typing,
            // dropdown should stay closed until another tag is typed.
            // if( this.state.tag.value.length && this.state.dropdown.visible === false )
            //     showSuggestions = false
            // test for similar flagged tags to the current tag

            try {
              matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset];
              matchFlaggedTag = matchFlaggedTag.prefix == this.state.tag.prefix && matchFlaggedTag.value[0] == this.state.tag.value[0]; // reset

              if (this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value) delete this.state.flaggedTags[this.state.tag.baseOffset];
            } catch (err) {} // scenario: (do not show suggestions of previous matched tag, if more than 1 detected)
            // (2 tags exist)                          " a@a.com and @"
            // (second tag is removed by backspace)    " a@a.com and "


            if (matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount) showSuggestions = false;
          } // no (potential) tag found
          else {
            this.state.flaggedTags = {};
          }

          this.state.mixMode.matchedPatternCount = matchedPatternCount;
        }
      } // wait until the "this.value" has been updated (see "onKeydown" method for "mix-mode")
      // the dropdown must be shown only after this event has been driggered, so an implementer could
      // dynamically change the whitelist.


      setTimeout(() => {
        this.update({
          withoutChangeEvent: true
        });
        this.trigger("input", extend({}, this.state.tag, {
          textContent: this.DOM.input.textContent
        }));
        if (this.state.tag) this.dropdown[showSuggestions ? "show" : "hide"](this.state.tag.value);
      }, 10);
    },

    onInputIE(e) {
      var _this = this; // for the "e.target.textContent" to be changed, the browser requires a small delay


      setTimeout(function () {
        _this.events.callbacks.onInput.call(_this, e);
      });
    },

    observeOriginalInputValue() {
      // if original input value changed for some reason (for exmaple a form reset)
      if (this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue) this.loadOriginalValues();
    },

    onClickScope(e) {
      var _s = this.settings,
          tagElm = e.target.closest('.' + _s.classNames.tag),
          timeDiffFocus = +new Date() - this.state.hasFocus;

      if (e.target == this.DOM.scope) {
        if (!this.state.hasFocus) this.DOM.input.focus();
        return;
      } else if (e.target.classList.contains(_s.classNames.tagX)) {
        this.removeTags(e.target.parentNode);
        return;
      } else if (tagElm) {
        this.trigger("click", {
          tag: tagElm,
          index: this.getNodeIndex(tagElm),
          data: this.tagData(tagElm),
          originalEvent: this.cloneEvent(e)
        });
        if (_s.editTags === 1 || _s.editTags.clicks === 1) this.events.callbacks.onDoubleClickScope.call(this, e);
        return;
      } // when clicking on the input itself
      else if (e.target == this.DOM.input) {
        if (_s.mode == 'mix') {
          // firefox won't show caret if last element is a tag (and not a textNode),
          // so an empty textnode should be added
          this.fixFirefoxLastTagNoCaret();
        }

        if (timeDiffFocus > 500) {
          if (this.state.dropdown.visible) this.dropdown.hide();else if (_s.dropdown.enabled === 0 && _s.mode != 'mix') this.dropdown.show(this.value.length ? '' : undefined);
          return;
        }
      }

      if (_s.mode == 'select') !this.state.dropdown.visible && this.dropdown.show();
    },

    // special proccess is needed for pasted content in order to "clean" it
    onPaste(e) {
      e.preventDefault();
      var _s = this.settings,
          selectModeWithoutInput = _s.mode == 'select' && _s.enforceWhitelist;

      if (selectModeWithoutInput || !_s.userInput) {
        return false;
      }

      var clipboardData, pastedText;
      if (_s.readonly) return; // Get pasted data via clipboard API

      clipboardData = e.clipboardData || window.clipboardData;
      pastedText = clipboardData.getData('Text');

      _s.hooks.beforePaste(e, {
        tagify: this,
        pastedText,
        clipboardData
      }).then(result => {
        if (result === undefined) result = pastedText;

        if (result) {
          this.injectAtCaret(result, window.getSelection().getRangeAt(0));

          if (this.settings.mode == 'mix') {
            this.events.callbacks.onMixTagsInput.call(this, e);
          } else if (this.settings.pasteAsTags) {
            this.addTags(this.state.inputText + result, true);
          } else this.state.inputText = result;
        }
      }).catch(err => err);
    },

    onDrop(e) {
      e.preventDefault();
    },

    onEditTagInput(editableElm, e) {
      var tagElm = editableElm.closest('.' + this.settings.classNames.tag),
          tagElmIdx = this.getNodeIndex(tagElm),
          tagData = this.tagData(tagElm),
          value = this.input.normalize.call(this, editableElm),
          hasChanged = tagElm.innerHTML != tagElm.__tagifyTagData.__originalHTML,
          isValid = this.validateTag({
        [this.settings.tagTextProp]: value
      }); // the value could have been invalid in the first-place so make sure to re-validate it (via "addEmptyTag" method)
      // if the value is same as before-editing and the tag was valid before as well, ignore the  current "isValid" result, which is false-positive

      if (!hasChanged && editableElm.originalIsValid === true) isValid = true;
      tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true);
      tagData.__isValid = isValid;
      tagElm.title = isValid === true ? tagData.title || tagData.value : isValid; // change the tag's title to indicate why is the tag invalid (if it's so)
      // show dropdown if typed text is equal or more than the "enabled" dropdown setting

      if (value.length >= this.settings.dropdown.enabled) {
        // this check is needed apparently because doing browser "undo" will fire
        //  "onEditTagInput" but "this.state.editing" will be "false"
        if (this.state.editing) this.state.editing.value = value;
        this.dropdown.show(value);
      }

      this.trigger("edit:input", {
        tag: tagElm,
        index: tagElmIdx,
        data: extend({}, this.value[tagElmIdx], {
          newValue: value
        }),
        originalEvent: this.cloneEvent(e)
      });
    },

    onEditTagFocus(tagElm) {
      this.state.editing = {
        scope: tagElm,
        input: tagElm.querySelector("[contenteditable]")
      };
    },

    onEditTagBlur(editableElm) {
      if (!this.state.hasFocus) this.toggleFocusClass(); // one scenario is when selecting a suggestion from the dropdown, when editing, and by selecting it
      // the "onEditTagDone" is called directly, already replacing the tag, so the argument "editableElm"
      // node isn't in the DOM anynmore because it has been replaced.

      if (!this.DOM.scope.contains(editableElm)) return;

      var _s = this.settings,
          tagElm = editableElm.closest('.' + _s.classNames.tag),
          textValue = this.input.normalize.call(this, editableElm),
          originalData = this.tagData(tagElm).__originalData,
          // pre-edit data
      hasChanged = tagElm.innerHTML != tagElm.__tagifyTagData.__originalHTML,
          isValid = this.validateTag({
        [_s.tagTextProp]: textValue
      }),
          hasMaxTags,
          newTagData; //  this.DOM.input.focus()


      if (!textValue) {
        this.onEditTagDone(tagElm);
        return;
      } // if nothing changed revert back to how it was before editing


      if (!hasChanged) {
        this.onEditTagDone(tagElm, originalData);
        return;
      }

      hasMaxTags = this.hasMaxTags();
      newTagData = this.getWhitelistItem(textValue) || extend({}, originalData, {
        [_s.tagTextProp]: textValue,
        value: textValue,
        __isValid: isValid
      });

      _s.transformTag.call(this, newTagData, originalData); // MUST re-validate after tag transformation
      // only validate the "tagTextProp" because is the only thing that metters for validating an edited tag.
      // -- Scenarios: --
      // 1. max 3 tags allowd. there are 4 tags, one has invalid input and is edited to a valid one, and now should be marked as "not allowed" because limit of tags has reached
      // 2. max 3 tags allowed. there are 3 tags, one is edited, and so max-tags vaildation should be OK


      isValid = !hasMaxTags && this.validateTag({
        [_s.tagTextProp]: newTagData[_s.tagTextProp]
      });

      if (isValid !== true) {
        this.trigger("invalid", {
          data: newTagData,
          tag: tagElm,
          message: isValid
        }); // do nothing if invalid, stay in edit-mode until corrected or reverted by presssing esc

        if (_s.editTags.keepInvalid) return;
        if (_s.keepInvalidTags) newTagData.__isValid = isValid;else // revert back if not specified to keep
          newTagData = originalData;
      } else if (_s.keepInvalidTags) {
        // cleaup any previous leftovers if the tag was
        delete newTagData.title;
        delete newTagData["aria-invalid"];
        delete newTagData.class;
      } // tagElm.classList.toggle(_s.classNames.tagInvalid, true)


      this.onEditTagDone(tagElm, newTagData);
    },

    onEditTagkeydown(e, tagElm) {
      this.trigger("edit:keydown", {
        originalEvent: this.cloneEvent(e)
      });

      switch (e.key) {
        case 'Esc':
        case 'Escape':
          tagElm.innerHTML = tagElm.__tagifyTagData.__originalHTML;

        case 'Enter':
        case 'Tab':
          e.preventDefault();
          e.target.blur();
      }
    },

    onDoubleClickScope(e) {
      var tagElm = e.target.closest('.' + this.settings.classNames.tag),
          _s = this.settings,
          isEditingTag,
          isReadyOnlyTag;
      if (!tagElm || !_s.userInput) return;
      isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing);
      isReadyOnlyTag = tagElm.hasAttribute('readonly');
      if (_s.mode != 'select' && !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags) this.editTag(tagElm);
      this.toggleFocusClass(true);
      this.trigger('dblclick', {
        tag: tagElm,
        index: this.getNodeIndex(tagElm),
        data: this.tagData(tagElm)
      });
    },

    /**
     *
     * @param {Object} m an object representing the observed DOM changes
     */
    onInputDOMChange(m) {
      // iterate all DOm mutation
      m.forEach(record => {
        // only the ADDED nodes
        record.addedNodes.forEach(addedNode => {
          if (addedNode) {
            // fix chrome's placing '<div><br></div>' everytime ENTER key is pressed, and replace with just `<br'
            if (addedNode.outerHTML == '<div><br></div>') {
              addedNode.replaceWith(document.createElement('br'));
            } // if the added element is a div containing a tag within it (chrome does this when pressing ENTER before a tag)
            else if (addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector)) {
              let newlineText = document.createTextNode('');
              if (addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != 'BR') newlineText = document.createTextNode('\n'); // unwrap the useless div
              // chrome adds a BR at the end which should be removed

              addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0, -1)]);
              this.placeCaretAfterNode(newlineText.previousSibling);
            } // if this is a tag
            else if (isNodeTag.call(this, addedNode)) {
              // and it is the first node in a new line
              if (addedNode.previousSibling && addedNode.previousSibling.nodeName == 'BR') {
                // allows placing the caret just before the tag, when the tag is the first node in that line
                addedNode.previousSibling.replaceWith('\n\u200B'); // when hitting ENTER for new line just before a tag

                this.placeCaretAfterNode(addedNode.previousSibling.previousSibling);
              }
            }
          }
        });
        record.removedNodes.forEach(removedNode => {
          // when trying to delete a tag which is in a new line and there's nothing else there (caret is after the tag)
          if (removedNode && removedNode.nodeName == 'BR' && isNodeTag.call(this, lastInputChild)) {
            this.removeTags(lastInputChild);
            this.fixFirefoxLastTagNoCaret();
          }
        });
      }); // get the last child only after the above DOM modifications
      // check these scenarios:
      // 1. after a single line, press ENTER once - should add only 1 BR
      // 2. presss ENTER right before a tag
      // 3. press enter within a text node before a tag

      var lastInputChild = this.DOM.input.lastChild;
      if (lastInputChild && lastInputChild.nodeValue == '') lastInputChild.remove(); // make sure the last element is always a BR

      if (!lastInputChild || lastInputChild.nodeName != 'BR') {
        this.DOM.input.appendChild(document.createElement('br'));
      }
    }

  }
};

/**
 * @constructor
 * @param {Object} input    DOM element
 * @param {Object} settings settings object
 */

function Tagify(input, settings) {
  if (!input) {
    console.warn('Tagify: ', 'input element not found', input);
    return this;
  }

  if (input.previousElementSibling && input.previousElementSibling.classList.contains('tagify')) {
    console.warn('Tagify: ', 'input element is already Tagified', input);
    return this;
  }

  extend(this, EventDispatcher(this));
  this.isFirefox = typeof InstallTrigger !== 'undefined';
  this.isIE = window.document.documentMode; // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode#Browser_compatibility

  settings = settings || {};
  this.getPersistedData = getPersistedData(settings.id);
  this.setPersistedData = setPersistedData(settings.id);
  this.clearPersistedData = clearPersistedData(settings.id);
  this.applySettings(input, settings);
  this.state = {
    inputText: '',
    editing: false,
    actions: {},
    // UI actions for state-locking
    mixMode: {},
    dropdown: {},
    flaggedTags: {} // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here

  };
  this.value = []; // tags' data
  // events' callbacks references will be stores here, so events could be unbinded

  this.listeners = {};
  this.DOM = {}; // Store all relevant DOM elements in an Object

  this.build(input);
  initDropdown.call(this);
  this.getCSSVars();
  this.loadOriginalValues();
  this.events.customBinding.call(this);
  this.events.binding.call(this);
  input.autofocus && this.DOM.input.focus();
}

Tagify.prototype = {
  _dropdown,
  customEventsList: ['change', 'add', 'remove', 'invalid', 'input', 'click', 'keydown', 'focus', 'blur', 'edit:input', 'edit:beforeUpdate', 'edit:updated', 'edit:start', 'edit:keydown', 'dropdown:show', 'dropdown:hide', 'dropdown:select', 'dropdown:updated', 'dropdown:noMatch', 'dropdown:scroll'],
  dataProps: ['__isValid', '__removed', '__originalData', '__originalHTML', '__tagId'],

  // internal-uasge props
  trim(text) {
    return this.settings.trim && text && typeof text == "string" ? text.trim() : text;
  },

  // expose this handy utility function
  parseHTML,
  templates,

  parseTemplate(template, data) {
    template = this.settings.templates[template] || template;
    return this.parseHTML(template.apply(this, data));
  },

  set whitelist(arr) {
    const isArray = arr && Array.isArray(arr);
    this.settings.whitelist = isArray ? arr : [];
    this.setPersistedData(isArray ? arr : [], 'whitelist');
  },

  get whitelist() {
    return this.settings.whitelist;
  },

  applySettings(input, settings) {
    DEFAULTS.templates = this.templates;

    var _s = this.settings = extend({}, DEFAULTS, settings);

    _s.disabled = input.hasAttribute('disabled');
    _s.readonly = input.hasAttribute('readonly'); // if "readonly" do not include an "input" element inside the Tags component

    _s.placeholder = input.getAttribute('placeholder') || _s.placeholder || "";
    _s.required = input.hasAttribute('required');

    for (let name in _s.classNames) Object.defineProperty(_s.classNames, name + "Selector", {
      get() {
        return "." + this[name].split(" ")[0];
      }

    });

    if (this.isIE) _s.autoComplete = false; // IE goes crazy if this isn't false

    ["whitelist", "blacklist"].forEach(name => {
      var attrVal = input.getAttribute('data-' + name);

      if (attrVal) {
        attrVal = attrVal.split(_s.delimiters);
        if (attrVal instanceof Array) _s[name] = attrVal;
      }
    }); // backward-compatibility for old version of "autoComplete" setting:

    if ("autoComplete" in settings && !isObject(settings.autoComplete)) {
      _s.autoComplete = DEFAULTS.autoComplete;
      _s.autoComplete.enabled = settings.autoComplete;
    }

    if (_s.mode == 'mix') {
      _s.autoComplete.rightKey = true;
      _s.delimiters = settings.delimiters || null; // default dlimiters in mix-mode must be NULL
      // needed for "filterListItems". This assumes the user might have forgotten to manually
      // define the same term in "dropdown.searchKeys" as defined in "tagTextProp" setting, so
      // by automatically adding it, tagify is "helping" out, guessing the intesntions of the developer.

      if (_s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp)) _s.dropdown.searchKeys.push(_s.tagTextProp);
    }

    if (input.pattern) try {
      _s.pattern = new RegExp(input.pattern);
    } catch (e) {} // Convert the "delimiters" setting into a REGEX object

    if (this.settings.delimiters) {
      try {
        _s.delimiters = new RegExp(this.settings.delimiters, "g");
      } catch (e) {}
    }

    if (_s.disabled) _s.userInput = false;
    this.TEXTS = _objectSpread2(_objectSpread2({}, TEXTS), _s.texts || {}); // make sure the dropdown will be shown on "focus" and not only after typing something (in "select" mode)

    if (_s.mode == 'select' || !_s.userInput) _s.dropdown.enabled = 0;
    _s.dropdown.appendTarget = settings.dropdown && settings.dropdown.appendTarget ? settings.dropdown.appendTarget : document.body; // get & merge persisted data with current data

    let persistedWhitelist = this.getPersistedData('whitelist');
    if (Array.isArray(persistedWhitelist)) this.whitelist = Array.isArray(_s.whitelist) ? concatWithoutDups(_s.whitelist, persistedWhitelist) : persistedWhitelist;
  },

  /**
   * Returns a string of HTML element attributes
   * @param {Object} data [Tag data]
   */
  getAttributes(data) {
    var attrs = this.getCustomAttributes(data),
        s = '',
        k;

    for (k in attrs) s += " " + k + (data[k] !== undefined ? `="${attrs[k]}"` : "");

    return s;
  },

  /**
   * Returns an object of attributes to be used for the templates
   */
  getCustomAttributes(data) {
    // only items which are objects have properties which can be used as attributes
    if (!isObject(data)) return '';
    var output = {},
        propName;

    for (propName in data) {
      if (propName.slice(0, 2) != '__' && propName != 'class' && data.hasOwnProperty(propName) && data[propName] !== undefined) output[propName] = escapeHTML(data[propName]);
    }

    return output;
  },

  setStateSelection() {
    var selection = window.getSelection(); // save last selection place to be able to inject anything from outside to that specific place

    var sel = {
      anchorOffset: selection.anchorOffset,
      anchorNode: selection.anchorNode,
      range: selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)
    };
    this.state.selection = sel;
    return sel;
  },

  /**
   * Get the caret position relative to the viewport
   * https://stackoverflow.com/q/58985076/104380
   *
   * @returns {object} left, top distance in pixels
   */
  getCaretGlobalPosition() {
    const sel = document.getSelection();

    if (sel.rangeCount) {
      const r = sel.getRangeAt(0);
      const node = r.startContainer;
      const offset = r.startOffset;
      let rect, r2;

      if (offset > 0) {
        r2 = document.createRange();
        r2.setStart(node, offset - 1);
        r2.setEnd(node, offset);
        rect = r2.getBoundingClientRect();
        return {
          left: rect.right,
          top: rect.top,
          bottom: rect.bottom
        };
      }

      if (node.getBoundingClientRect) return node.getBoundingClientRect();
    }

    return {
      left: -9999,
      top: -9999
    };
  },

  /**
   * Get specific CSS variables which are relevant to this script and parse them as needed.
   * The result is saved on the instance in "this.CSSVars"
   */
  getCSSVars() {
    var compStyle = getComputedStyle(this.DOM.scope, null);

    const getProp = name => compStyle.getPropertyValue('--' + name);

    function seprateUnitFromValue(a) {
      if (!a) return {};
      a = a.trim().split(' ')[0];
      var unit = a.split(/\d+/g).filter(n => n).pop().trim(),
          value = +a.split(unit).filter(n => n)[0].trim();
      return {
        value,
        unit
      };
    }

    this.CSSVars = {
      tagHideTransition: (({
        value,
        unit
      }) => unit == 's' ? value * 1000 : value)(seprateUnitFromValue(getProp('tag-hide-transition')))
    };
  },

  /**
   * builds the HTML of this component
   * @param  {Object} input [DOM element which would be "transformed" into "Tags"]
   */
  build(input) {
    var DOM = this.DOM;

    if (this.settings.mixMode.integrated) {
      DOM.originalInput = null;
      DOM.scope = input;
      DOM.input = input;
    } else {
      DOM.originalInput = input;
      DOM.scope = this.parseTemplate('wrapper', [input, this.settings]);
      DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector);
      input.parentNode.insertBefore(DOM.scope, input);
    }
  },

  /**
   * revert any changes made by this component
   */
  destroy() {
    this.events.unbindGlobal.call(this);
    this.DOM.scope.parentNode.removeChild(this.DOM.scope);
    this.dropdown.hide(true);
    clearTimeout(this.dropdownHide__bindEventsTimeout);
  },

  /**
   * if the original input had any values, add them as tags
   */
  loadOriginalValues(value) {
    var lastChild,
        _s = this.settings;

    if (value === undefined) {
      const persistedOriginalValue = this.getPersistedData('value'); // if the field already has a field, trust its the desired
      // one to be rendered and do not use the persisted one

      if (persistedOriginalValue && !this.DOM.originalInput.value) value = persistedOriginalValue;else value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
    }

    this.removeAllTags({
      withoutChangeEvent: true
    });

    if (value) {
      if (_s.mode == 'mix') {
        this.parseMixTags(value.trim());
        lastChild = this.DOM.input.lastChild;
        if (!lastChild || lastChild.tagName != 'BR') this.DOM.input.insertAdjacentHTML('beforeend', '<br>');
      } else {
        try {
          if (JSON.parse(value) instanceof Array) value = JSON.parse(value);
        } catch (err) {}

        this.addTags(value).forEach(tag => tag && tag.classList.add(_s.classNames.tagNoAnimation));
      }
    } else this.postUpdate();

    this.state.lastOriginalValueReported = _s.mixMode.integrated ? '' : this.DOM.originalInput.value;
    this.state.loadedOriginalValues = true;
  },

  cloneEvent(e) {
    var clonedEvent = {};

    for (var v in e) clonedEvent[v] = e[v];

    return clonedEvent;
  },

  /**
   * Toogle global loading state on/off
   * Useful when fetching async whitelist while user is typing
   * @param {Boolean} isLoading
   */
  loading(isLoading) {
    this.state.isLoading = isLoading; // IE11 doesn't support toggle with second parameter

    this.DOM.scope.classList[isLoading ? "add" : "remove"](this.settings.classNames.scopeLoading);
    return this;
  },

  /**
   * Toogle specieif tag loading state on/off
   * @param {Boolean} isLoading
   */
  tagLoading(tagElm, isLoading) {
    if (tagElm) // IE11 doesn't support toggle with second parameter
      tagElm.classList[isLoading ? "add" : "remove"](this.settings.classNames.tagLoading);
    return this;
  },

  /**
   * Toggles class on the main tagify container ("scope")
   * @param {String} className
   * @param {Boolean} force
   */
  toggleClass(className, force) {
    if (typeof className == 'string') this.DOM.scope.classList.toggle(className, force);
  },

  toggleFocusClass(force) {
    this.toggleClass(this.settings.classNames.focus, !!force);
  },

  triggerChangeEvent,
  events,

  fixFirefoxLastTagNoCaret() {
    return; // seems to be fixed in newer version of FF, so retiring below code (for now)
  },

  placeCaretAfterNode(node) {
    if (!node || !node.parentNode) return;
    var nextSibling = node.nextSibling,
        sel = window.getSelection(),
        range = sel.getRangeAt(0);

    if (sel.rangeCount) {
      range.setStartAfter(nextSibling || node);
      range.collapse(true); // range.setEndBefore(nextSibling || node);

      sel.removeAllRanges();
      sel.addRange(range);
    }
  },

  insertAfterTag(tagElm, newNode) {
    newNode = newNode || this.settings.mixMode.insertAfterTag;
    if (!tagElm || !tagElm.parentNode || !newNode) return;
    newNode = typeof newNode == 'string' ? document.createTextNode(newNode) : newNode;
    tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling);
    return newNode;
  },

  /**
   * Enters a tag into "edit" mode
   * @param {Node} tagElm the tag element to edit. if nothing specified, use last last
   */
  editTag(tagElm, opts) {
    tagElm = tagElm || this.getLastTag();
    opts = opts || {};
    this.dropdown.hide();
    var _s = this.settings;

    function getEditableElm() {
      return tagElm.querySelector(_s.classNames.tagTextSelector);
    }

    var editableElm = getEditableElm(),
        tagIdx = this.getNodeIndex(tagElm),
        tagData = this.tagData(tagElm),
        _CB = this.events.callbacks,
        that = this,
        isValid = true,
        delayed_onEditTagBlur = function () {
      setTimeout(() => _CB.onEditTagBlur.call(that, getEditableElm()));
    };

    if (!editableElm) {
      console.warn('Cannot find element in Tag template: .', _s.classNames.tagTextSelector);
      return;
    }

    if (tagData instanceof Object && "editable" in tagData && !tagData.editable) return;
    editableElm.setAttribute('contenteditable', true);
    tagElm.classList.add(_s.classNames.tagEditing); // cache the original data, on the DOM node, before any modification ocurs, for possible revert

    this.tagData(tagElm, {
      __originalData: extend({}, tagData),
      __originalHTML: tagElm.innerHTML
    });
    editableElm.addEventListener('focus', _CB.onEditTagFocus.bind(this, tagElm));
    editableElm.addEventListener('blur', delayed_onEditTagBlur);
    editableElm.addEventListener('input', _CB.onEditTagInput.bind(this, editableElm));
    editableElm.addEventListener('keydown', e => _CB.onEditTagkeydown.call(this, e, tagElm));
    editableElm.focus();
    this.setRangeAtStartEnd(false, editableElm);
    if (!opts.skipValidation) isValid = this.editTagToggleValidity(tagElm);
    editableElm.originalIsValid = isValid;
    this.trigger("edit:start", {
      tag: tagElm,
      index: tagIdx,
      data: tagData,
      isValid
    });
    return this;
  },

  /**
   * If a tag is invalid, for any reason, set its class to as "not allowed" (see defaults file)
   * @param {Node} tagElm required
   * @param {Object} tagData optional
   * @returns true if valid, a string (reason) if not
   */
  editTagToggleValidity(tagElm, tagData) {
    var tagData = tagData || this.tagData(tagElm),
        isValid;

    if (!tagData) {
      console.warn("tag has no data: ", tagElm, tagData);
      return;
    }

    isValid = !("__isValid" in tagData) || tagData.__isValid === true;

    if (!isValid) {
      this.removeTagsFromValue(tagElm);
    }

    this.update(); //this.validateTag(tagData);

    tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid);
    return tagData.__isValid;
  },

  onEditTagDone(tagElm, tagData) {
    tagElm = tagElm || this.state.editing.scope;
    tagData = tagData || {};
    var eventData = {
      tag: tagElm,
      index: this.getNodeIndex(tagElm),
      previousData: this.tagData(tagElm),
      data: tagData
    };
    this.trigger("edit:beforeUpdate", eventData, {
      cloneData: false
    });
    this.state.editing = false;
    delete tagData.__originalData;
    delete tagData.__originalHTML;

    if (tagElm && tagData[this.settings.tagTextProp]) {
      tagElm = this.replaceTag(tagElm, tagData);
      this.editTagToggleValidity(tagElm, tagData);
      if (this.settings.a11y.focusableTags) tagElm.focus();
    } else if (tagElm) this.removeTags(tagElm);

    this.trigger("edit:updated", eventData);
    this.dropdown.hide(); // check if any of the current tags which might have been marked as "duplicate" should be now un-marked

    if (this.settings.keepInvalidTags) this.reCheckInvalidTags();
  },

  /**
   * Replaces an exisitng tag with a new one. Used for updating a tag's data
   * @param {Object} tagElm  [DOM node to replace]
   * @param {Object} tagData [data to create new tag from]
   */
  replaceTag(tagElm, tagData) {
    if (!tagData || !tagData.value) tagData = tagElm.__tagifyTagData; // if tag is invalid, make the according changes in the newly created element

    if (tagData.__isValid && tagData.__isValid != true) extend(tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid));
    var newTagElm = this.createTagElem(tagData); // update DOM

    tagElm.parentNode.replaceChild(newTagElm, tagElm);
    this.updateValueByDOMTags();
    return newTagElm;
  },

  /**
   * update "value" (Array of Objects) by traversing all valid tags
   */
  updateValueByDOMTags() {
    this.value.length = 0;
    [].forEach.call(this.getTagElms(), node => {
      if (node.classList.contains(this.settings.classNames.tagNotAllowed.split(' ')[0])) return;
      this.value.push(this.tagData(node));
    });
    this.update();
  },

  /** https://stackoverflow.com/a/59156872/104380
   * @param {Boolean} start indicating where to place it (start or end of the node)
   * @param {Object}  node  DOM node to place the caret at
   */
  setRangeAtStartEnd(start, node) {
    start = typeof start == 'number' ? start : !!start;
    node = node || this.DOM.input;
    node = node.lastChild || node;
    var sel = document.getSelection();

    try {
      if (sel.rangeCount >= 1) {
        ['Start', 'End'].forEach(pos => sel.getRangeAt(0)["set" + pos](node, start ? start : node.length));
      }
    } catch (err) {// console.warn("Tagify: ", err)
    }
  },

  /**
   * injects nodes/text at caret position, which is saved on the "state" when "blur" event gets triggered
   * @param {Node} injectedNode [the node to inject at the caret position]
   * @param {Object} selection [optional range Object. must have "anchorNode" & "anchorOffset"]
   */
  injectAtCaret(injectedNode, range) {
    range = range || this.state.selection.range;
    if (!range) return;
    if (typeof injectedNode == 'string') injectedNode = document.createTextNode(injectedNode);
    range.deleteContents();
    range.insertNode(injectedNode);
    this.setRangeAtStartEnd(false, injectedNode);
    this.updateValueByDOMTags(); // updates internal "this.value"

    this.update(); // updates original input/textarea

    return this;
  },

  /**
   * input bridge for accessing & setting
   * @type {Object}
   */
  input: {
    set(s = '', updateDOM = true) {
      var hideDropdown = this.settings.dropdown.closeOnSelect;
      this.state.inputText = s;
      if (updateDOM) this.DOM.input.innerHTML = escapeHTML("" + s);
      if (!s && hideDropdown) this.dropdown.hide.bind(this);
      this.input.autocomplete.suggest.call(this);
      this.input.validate.call(this);
    },

    raw() {
      return this.DOM.input.textContent;
    },

    /**
     * Marks the tagify's input as "invalid" if the value did not pass "validateTag()"
     */
    validate() {
      var isValid = !this.state.inputText || this.validateTag({
        value: this.state.inputText
      }) === true;
      this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid);
      return isValid;
    },

    // remove any child DOM elements that aren't of type TEXT (like <br>)
    normalize(node) {
      var clone = node || this.DOM.input,
          //.cloneNode(true),
      v = []; // when a text was pasted in FF, the "this.DOM.input" element will have <br> but no newline symbols (\n), and this will
      // result in tags not being properly created if one wishes to create a separate tag per newline.

      clone.childNodes.forEach(n => n.nodeType == 3 && v.push(n.nodeValue));
      v = v.join("\n");

      try {
        // "delimiters" might be of a non-regex value, where this will fail ("Tags With Properties" example in demo page):
        v = v.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
      } catch (err) {}

      v = v.replace(/\s/g, ' '); // replace NBSPs with spaces characters

      if (this.settings.trim) v = v.replace(/^\s+/, ''); // trimLeft

      return v;
    },

    /**
     * suggest the rest of the input's value (via CSS "::after" using "content:attr(...)")
     * @param  {String} s [description]
     */
    autocomplete: {
      suggest(data) {
        if (!this.settings.autoComplete.enabled) return;
        data = data || {};
        if (typeof data == 'string') data = {
          value: data
        };
        var suggestedText = data.value ? '' + data.value : '',
            suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(),
            suggestionTrimmed = suggestedText.substring(this.state.inputText.length);

        if (!suggestedText || !this.state.inputText || suggestionStart != this.state.inputText.toLowerCase()) {
          this.DOM.input.removeAttribute("data-suggest");
          delete this.state.inputSuggestion;
        } else {
          this.DOM.input.setAttribute("data-suggest", suggestionTrimmed);
          this.state.inputSuggestion = data;
        }
      },

      /**
       * sets the suggested text as the input's value & cleanup the suggestion autocomplete.
       * @param {String} s [text]
       */
      set(s) {
        var dataSuggest = this.DOM.input.getAttribute('data-suggest'),
            suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);

        if (suggestion) {
          if (this.settings.mode == 'mix') {
            this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + suggestion));
          } else {
            this.input.set.call(this, suggestion);
            this.setRangeAtStartEnd();
          }

          this.input.autocomplete.suggest.call(this);
          this.dropdown.hide();
          return true;
        }

        return false;
      }

    }
  },

  /**
   * returns the index of the the tagData within the "this.value" array collection.
   * since values should be unique, it is suffice to only search by "value" property
   * @param {Object} tagData
   */
  getTagIdx(tagData) {
    return this.value.findIndex(item => item.__tagId == (tagData || {}).__tagId);
  },

  getNodeIndex(node) {
    var index = 0;
    if (node) while (node = node.previousElementSibling) index++;
    return index;
  },

  getTagElms(...classess) {
    var classname = '.' + [...this.settings.classNames.tag.split(' '), ...classess].join('.');
    return [].slice.call(this.DOM.scope.querySelectorAll(classname)); // convert nodeList to Array - https://stackoverflow.com/a/3199627/104380
  },

  /**
   * gets the last non-readonly, not-in-the-proccess-of-removal tag
   */
  getLastTag() {
    var lastTag = this.DOM.scope.querySelectorAll(`${this.settings.classNames.tagSelector}:not(.${this.settings.classNames.tagHide}):not([readonly])`);
    return lastTag[lastTag.length - 1];
  },

  /** Setter/Getter
   * Each tag DOM node contains a custom property called "__tagifyTagData" which hosts its data
   * @param {Node}   tagElm
   * @param {Object} data
   */
  tagData(tagElm, data, override) {
    if (!tagElm) {
      console.warn("tag elment doesn't exist", tagElm, data);
      return data;
    }

    if (data) tagElm.__tagifyTagData = override ? data : extend({}, tagElm.__tagifyTagData || {}, data);
    return tagElm.__tagifyTagData;
  },

  /**
   * Searches if any tag with a certain value already exis
   * @param  {String/Object} v [text value / tag data object]
   * @return {Boolean}
   */
  isTagDuplicate(value, caseSensitive) {
    var duplications,
        _s = this.settings; // duplications are irrelevant for this scenario

    if (_s.mode == 'select') return false;
    duplications = this.value.reduce((acc, item) => sameStr(this.trim("" + value), item.value, caseSensitive || _s.dropdown.caseSensitive) ? acc + 1 : acc, 0);
    return duplications;
  },

  getTagIndexByValue(value) {
    var indices = [];
    this.getTagElms().forEach((tagElm, i) => {
      if (sameStr(this.trim(tagElm.textContent), value, this.settings.dropdown.caseSensitive)) indices.push(i);
    });
    return indices;
  },

  getTagElmByValue(value) {
    var tagIdx = this.getTagIndexByValue(value)[0];
    return this.getTagElms()[tagIdx];
  },

  /**
   * Temporarily marks a tag element (by value or Node argument)
   * @param  {Object} tagElm [a specific "tag" element to compare to the other tag elements siblings]
   */
  flashTag(tagElm) {
    if (tagElm) {
      tagElm.classList.add(this.settings.classNames.tagFlash);
      setTimeout(() => {
        tagElm.classList.remove(this.settings.classNames.tagFlash);
      }, 100);
    }
  },

  /**
   * checks if text is in the blacklist
   */
  isTagBlacklisted(v) {
    v = this.trim(v.toLowerCase());
    return this.settings.blacklist.filter(x => ("" + x).toLowerCase() == v).length;
  },

  /**
   * checks if text is in the whitelist
   */
  isTagWhitelisted(v) {
    return !!this.getWhitelistItem(v);
    /*
    return this.settings.whitelist.some(item =>
        typeof v == 'string'
            ? sameStr(this.trim(v), (item.value || item))
            : sameStr(JSON.stringify(item), JSON.stringify(v))
    )
    */
  },

  /**
   * Returns the first whitelist item matched, by value (if match found)
   * @param {String} value [text to match by]
   */
  getWhitelistItem(value, prop, whitelist) {
    var result,
        prop = prop || 'value',
        _s = this.settings,
        whitelist = whitelist || _s.whitelist;
    whitelist.some(_wi => {
      var _wiv = typeof _wi == 'string' ? _wi : _wi[prop] || _wi.value,
          isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim);

      if (isSameStr) {
        result = typeof _wi == 'string' ? {
          value: _wi
        } : _wi;
        return true;
      }
    }); // first iterate the whitelist, try find maches by "value" and if that fails
    // and a "tagTextProp" is set to be other than "value", try that also

    if (!result && prop == 'value' && _s.tagTextProp != 'value') {
      // if found, adds the first which matches
      result = this.getWhitelistItem(value, _s.tagTextProp, whitelist);
    }

    return result;
  },

  /**
   * validate a tag object BEFORE the actual tag will be created & appeneded
   * @param  {String} s
   * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]
   * @return {Boolean/String}  ["true" if validation has passed, String for a fail]
   */
  validateTag(tagData) {
    var _s = this.settings,
        // when validating a tag in edit-mode, need to take "tagTextProp" into consideration
    prop = "value" in tagData ? "value" : _s.tagTextProp,
        v = this.trim(tagData[prop] + ""); // check for definitive empty value

    if (!(tagData[prop] + "").trim()) return this.TEXTS.empty; // check if pattern should be used and if so, use it to test the value

    if (_s.pattern && _s.pattern instanceof RegExp && !_s.pattern.test(v)) return this.TEXTS.pattern; // if duplicates are not allowed and there is a duplicate

    if (!_s.duplicates && this.isTagDuplicate(v, this.state.editing)) return this.TEXTS.duplicate;
    if (this.isTagBlacklisted(v) || _s.enforceWhitelist && !this.isTagWhitelisted(v)) return this.TEXTS.notAllowed;
    if (_s.validate) return _s.validate(tagData);
    return true;
  },

  getInvalidTagAttrs(tagData, validation) {
    return {
      "aria-invalid": true,
      "class": `${tagData.class || ''} ${this.settings.classNames.tagNotAllowed}`.trim(),
      "title": validation
    };
  },

  hasMaxTags() {
    return this.value.length >= this.settings.maxTags ? this.TEXTS.exceed : false;
  },

  setReadonly(toggle, attrribute) {
    var _s = this.settings;
    document.activeElement.blur(); // exists possible edit-mode

    _s[attrribute || 'readonly'] = toggle;
    this.DOM.scope[(toggle ? 'set' : 'remove') + 'Attribute'](attrribute || 'readonly', true);

    if (_s.mode == 'mix') {
      this.setContentEditable(!toggle);
    }
  },

  setContentEditable(state) {
    if (!this.settings.readonly && this.settings.userInput) this.DOM.input.contentEditable = state;
  },

  setDisabled(isDisabled) {
    this.setReadonly(isDisabled, 'disabled');
  },

  /**
   * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words
   * so each item should be iterated on and a tag created for.
   * @return {Array} [Array of Objects]
   */
  normalizeTags(tagsItems) {
    var _this$settings = this.settings,
        whitelist = _this$settings.whitelist,
        delimiters = _this$settings.delimiters,
        mode = _this$settings.mode,
        tagTextProp = _this$settings.tagTextProp;
        _this$settings.enforceWhitelist;
        var whitelistMatches = [],
        whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false,
        isArray = tagsItems instanceof Array,
        mapStringToCollection = s => (s + "").split(delimiters).filter(n => n).map(v => ({
      [tagTextProp]: this.trim(v),
      value: this.trim(v)
    }));

    if (typeof tagsItems == 'number') tagsItems = tagsItems.toString(); // if the argument is a "simple" String, ex: "aaa, bbb, ccc"

    if (typeof tagsItems == 'string') {
      if (!tagsItems.trim()) return []; // go over each tag and add it (if there were multiple ones)

      tagsItems = mapStringToCollection(tagsItems);
    } // is is an Array of Strings, convert to an Array of Objects
    else if (isArray) {
      // flatten the 2D array
      tagsItems = [].concat(...tagsItems.map(item => item.value ? item // mapStringToCollection(item.value).map(newItem => ({...item,...newItem}))
      : mapStringToCollection(item)));
    } // search if the tag exists in the whitelist as an Object (has props),
    // to be able to use its properties


    if (whitelistWithProps) {
      tagsItems.forEach(item => {
        var whitelistMatchesValues = whitelistMatches.map(a => a.value); // if suggestions are shown, they are already filtered, so it's easier to use them,
        // because the whitelist might also include items which have already been added

        var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], {
          exact: true
        });
        if (!this.settings.duplicates) // also filter out items which have already been matched in previous iterations
          filteredList = filteredList.filter(filteredItem => !whitelistMatchesValues.includes(filteredItem.value)); // get the best match out of list of possible matches.
        // if there was a single item in the filtered list, use that one

        var matchObj = filteredList.length > 1 ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList) : filteredList[0];

        if (matchObj && matchObj instanceof Object) {
          whitelistMatches.push(matchObj); // set the Array (with the found Object) as the new value
        } else if (mode != 'mix') {
          if (item.value == undefined) item.value = item[tagTextProp];
          whitelistMatches.push(item);
        }
      });
      if (whitelistMatches.length) tagsItems = whitelistMatches;
    }

    return tagsItems;
  },

  /**
   * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags
   * https://stackoverflow.com/a/57598892/104380
   * @param {String} s
   */
  parseMixTags(s) {
    var _this$settings2 = this.settings,
        mixTagsInterpolator = _this$settings2.mixTagsInterpolator,
        duplicates = _this$settings2.duplicates,
        transformTag = _this$settings2.transformTag,
        enforceWhitelist = _this$settings2.enforceWhitelist,
        maxTags = _this$settings2.maxTags,
        tagTextProp = _this$settings2.tagTextProp,
        tagsDataSet = [];
    s = s.split(mixTagsInterpolator[0]).map((s1, i) => {
      var s2 = s1.split(mixTagsInterpolator[1]),
          preInterpolated = s2[0],
          maxTagsReached = tagsDataSet.length == maxTags,
          textProp,
          tagData,
          tagElm;

      try {
        // skip numbers and go straight to the "catch" statement
        if (preInterpolated == +preInterpolated) throw Error;
        tagData = JSON.parse(preInterpolated);
      } catch (err) {
        tagData = this.normalizeTags(preInterpolated)[0] || {
          value: preInterpolated
        };
      }

      transformTag.call(this, tagData);

      if (!maxTagsReached && s2.length > 1 && (!enforceWhitelist || this.isTagWhitelisted(tagData.value)) && !(!duplicates && this.isTagDuplicate(tagData.value))) {
        // in case "tagTextProp" setting is set to other than "value" and this tag does not have this prop
        textProp = tagData[tagTextProp] ? tagTextProp : 'value';
        tagData[textProp] = this.trim(tagData[textProp]);
        tagElm = this.createTagElem(tagData);
        tagsDataSet.push(tagData);
        tagElm.classList.add(this.settings.classNames.tagNoAnimation);
        s2[0] = tagElm.outerHTML; //+ "&#8288;"  // put a zero-space at the end so the caret won't jump back to the start (when the last input's child element is a tag)

        this.value.push(tagData);
      } else if (s1) return i ? mixTagsInterpolator[0] + s1 : s1;

      return s2.join('');
    }).join('');
    this.DOM.input.innerHTML = s;
    this.DOM.input.appendChild(document.createTextNode(''));
    this.DOM.input.normalize();
    this.getTagElms().forEach((elm, idx) => this.tagData(elm, tagsDataSet[idx]));
    this.update({
      withoutChangeEvent: true
    });
    return s;
  },

  /**
   * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)
   * First there *has* to be a "this.state.tag" which is a string that was just typed and is staring with a prefix
   */
  replaceTextWithNode(newWrapperNode, strToReplace) {
    if (!this.state.tag && !strToReplace) return;
    strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;
    var idx,
        nodeToReplace,
        selection = window.getSelection(),
        nodeAtCaret = selection.anchorNode,
        firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0; // STEP 1: ex. replace #ba with the tag "bart" where "|" is where the caret is:
    // CURRENT STATE: "foo #ba #ba| #ba"
    // split the text node at the index of the caret

    nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset); // node 0: "foo #ba #ba|"
    // node 1: " #ba"
    // get index of LAST occurence of "#ba"

    idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace);
    if (idx == -1) return true;
    nodeToReplace = nodeAtCaret.splitText(idx); // node 0: "foo #ba "
    // node 1: "#ba"    <- nodeToReplace

    newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace); // must NOT normalize contenteditable or it will cause unwanted issues:
    // https://monosnap.com/file/ZDVmRvq5upYkidiFedvrwzSswegWk7
    // nodeAtCaret.parentNode.normalize()

    return true;
  },

  /**
   * For selecting a single option (not used for multiple tags, but for "mode:select" only)
   * @param {Object} tagElm   Tag DOM node
   * @param {Object} tagData  Tag data
   */
  selectTag(tagElm, tagData) {
    var _s = this.settings;
    if (_s.enforceWhitelist && !this.isTagWhitelisted(tagData.value)) return;
    this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true); // place the caret at the end of the input, only if a dropdown option was selected (and not by manually typing another value and clicking "TAB")

    if (this.state.actions.selectOption) setTimeout(this.setRangeAtStartEnd.bind(this));
    var lastTagElm = this.getLastTag();
    if (lastTagElm) this.replaceTag(lastTagElm, tagData);else this.appendTag(tagElm);
    if (_s.enforceWhitelist) this.setContentEditable(false);
    this.value[0] = tagData;
    this.update();
    this.trigger('add', {
      tag: tagElm,
      data: tagData
    });
    return [tagElm];
  },

  /**
   * add an empty "tag" element in an editable state
   */
  addEmptyTag(initialData) {
    var tagData = extend({
      value: ""
    }, initialData || {}),
        tagElm = this.createTagElem(tagData);
    this.tagData(tagElm, tagData); // add the tag to the component's DOM

    this.appendTag(tagElm);
    this.editTag(tagElm, {
      skipValidation: true
    });
  },

  /**
   * add a "tag" element to the "tags" component
   * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]
   * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]
   * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]
   * @return {Array} Array of DOM elements (tags)
   */
  addTags(tagsItems, clearInput, skipInvalid) {
    var tagElems = [],
        _s = this.settings,
        frag = document.createDocumentFragment();
    skipInvalid = skipInvalid || _s.skipInvalid;

    if (!tagsItems || tagsItems.length == 0) {
      if (_s.mode == 'select') this.removeAllTags();
      return tagElems;
    } // converts Array/String/Object to an Array of Objects


    tagsItems = this.normalizeTags(tagsItems);

    if (_s.mode == 'mix') {
      return this.addMixTags(tagsItems);
    }

    if (_s.mode == 'select') clearInput = false;
    this.DOM.input.removeAttribute('style');
    tagsItems.forEach(tagData => {
      var tagElm,
          tagElmParams = {},
          originalData = Object.assign({}, tagData, {
        value: tagData.value + ""
      }); // shallow-clone tagData so later modifications will not apply to the source

      tagData = Object.assign({}, originalData);

      _s.transformTag.call(this, tagData);

      tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData);

      if (tagData.__isValid !== true) {
        if (skipInvalid) return; // originalData is kept because it might be that this tag is invalid because it is a duplicate of another,
        // and if that other tags is edited/deleted, this one should be re-validated and if is no more a duplicate - restored

        extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {
          __preInvalidData: originalData
        });
        if (tagData.__isValid == this.TEXTS.duplicate) // mark, for a brief moment, the tag (this this one) which THIS CURRENT tag is a duplcate of
          this.flashTag(this.getTagElmByValue(tagData.value));
      } /////////////////////////////////////////////////////


      if ('readonly' in tagData) {
        if (tagData.readonly) tagElmParams["aria-readonly"] = true; // if "readonly" is "false", remove it from the tagData so it won't be added as an attribute in the template
        else delete tagData.readonly;
      } // Create tag HTML element


      tagElm = this.createTagElem(tagData, tagElmParams);
      tagElems.push(tagElm); // mode-select overrides

      if (_s.mode == 'select') {
        return this.selectTag(tagElm, tagData);
      } // add the tag to the component's DOM
      // this.appendTag(tagElm)


      frag.appendChild(tagElm);

      if (tagData.__isValid && tagData.__isValid === true) {
        // update state
        this.value.push(tagData);
        this.trigger('add', {
          tag: tagElm,
          index: this.value.length - 1,
          data: tagData
        });
      } else {
        this.trigger("invalid", {
          data: tagData,
          index: this.value.length,
          tag: tagElm,
          message: tagData.__isValid
        });
        if (!_s.keepInvalidTags) // remove invalid tags (if "keepInvalidTags" is set to "false")
          setTimeout(() => this.removeTags(tagElm, true), 1000);
      }

      this.dropdown.position(); // reposition the dropdown because the just-added tag might cause a new-line
    });
    this.appendTag(frag);
    this.update();

    if (tagsItems.length && clearInput) {
      this.input.set.call(this);
    }

    this.dropdown.refilter();
    return tagElems;
  },

  /**
   * Adds a mix-content tag
   * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings
   */
  addMixTags(tagsData) {
    tagsData = this.normalizeTags(tagsData);

    if (tagsData[0].prefix || this.state.tag) {
      return this.prefixedTextToTag(tagsData[0]);
    }

    if (typeof tagsData == 'string') tagsData = [{
      value: tagsData
    }];
    var selection = !!this.state.selection,
        // must be cast, not to use the reference which is changing
    frag = document.createDocumentFragment();
    tagsData.forEach(tagData => {
      var tagElm = this.createTagElem(tagData);
      frag.appendChild(tagElm);
      this.insertAfterTag(tagElm);
    }); // if "selection" exists, assumes intention of inecting the new tag at the last
    // saved location of the caret inside "this.DOM.input"

    if (selection) {
      this.injectAtCaret(frag);
    } // else, create a range and inject the new tag as the last child of "this.DOM.input"
    else {
      this.DOM.input.focus();
      selection = this.setStateSelection();
      selection.range.setStart(this.DOM.input, selection.range.endOffset);
      selection.range.setEnd(this.DOM.input, selection.range.endOffset);
      this.DOM.input.appendChild(frag);
      this.updateValueByDOMTags(); // updates internal "this.value"

      this.update(); // updates original input/textarea
    }

    return frag;
  },

  /**
   * Adds a tag which was activly typed by the user
   * @param {String/Array} tagItem   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]
   */
  prefixedTextToTag(tagItem) {
    var _s = this.settings,
        tagElm,
        createdFromDelimiters = this.state.tag.delimiters;

    _s.transformTag.call(this, tagItem);

    tagItem.prefix = tagItem.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source || _s.pattern)[0]; // TODO: should check if the tag is valid

    tagElm = this.createTagElem(tagItem); // tries to replace a taged textNode with a tagElm, and if not able,
    // insert the new tag to the END if "addTags" was called from outside

    if (!this.replaceTextWithNode(tagElm)) {
      this.DOM.input.appendChild(tagElm);
    }

    setTimeout(() => tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300);
    this.value.push(tagItem);
    this.update();

    if (!createdFromDelimiters) {
      var elm = this.insertAfterTag(tagElm) || tagElm;
      this.placeCaretAfterNode(elm);
    }

    this.state.tag = null;
    this.trigger('add', extend({}, {
      tag: tagElm
    }, {
      data: tagItem
    }));
    return tagElm;
  },

  /**
   * appened (validated) tag to the component's DOM scope
   */
  appendTag(tagElm) {
    var DOM = this.DOM,
        insertBeforeNode = DOM.scope.lastElementChild;
    if (insertBeforeNode === DOM.input) DOM.scope.insertBefore(tagElm, insertBeforeNode);else DOM.scope.appendChild(tagElm);
  },

  /**
   * creates a DOM tag element and injects it into the component (this.DOM.scope)
   * @param  {Object}  tagData [text value & properties for the created tag]
   * @param  {Object}  extraData [properties which are for the HTML template only]
   * @return {Object} [DOM element]
   */
  createTagElem(tagData, extraData) {
    tagData.__tagId = getUID();
    var tagElm,
        templateData = extend({}, tagData, _objectSpread2({
      value: escapeHTML(tagData.value + "")
    }, extraData)); // if( this.settings.readonly )
    //     tagData.readonly = true

    tagElm = this.parseTemplate('tag', [templateData]); // crucial for proper caret placement when deleting content. if textNodes are allowed as children of
    // a tag element, a browser bug casues the caret to misplaced inside the tag element (especcially affects "readonly" tags)

    removeTextChildNodes(tagElm); // while( tagElm.lastChild.nodeType == 3 )
    //     tagElm.lastChild.parentNode.removeChild(tagElm.lastChild)

    this.tagData(tagElm, tagData);
    return tagElm;
  },

  /**
   * re-check all invalid tags.
   * called after a tag was edited or removed
   */
  reCheckInvalidTags() {
    var _s = this.settings;
    this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {
      var tagData = this.tagData(tagElm),
          hasMaxTags = this.hasMaxTags(),
          tagValidation = this.validateTag(tagData); // if the tag has become valid

      if (tagValidation === true && !hasMaxTags) {
        tagData = tagData.__preInvalidData ? tagData.__preInvalidData : {
          value: tagData.value
        };
        return this.replaceTag(tagElm, tagData);
      } // if the tag is still invaild, set its title as such (reson of invalid might have changed)


      tagElm.title = hasMaxTags || tagValidation;
    });
  },

  /**
   * Removes a tag
   * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]
   * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]
   * @param  {Number}             tranDuration    [Transition duration in MS]
   * TODO: Allow multiple tags to be removed at-once
   */
  removeTags(tagElms, silent, tranDuration) {
    var tagsToRemove;
    tagElms = tagElms && tagElms instanceof HTMLElement ? [tagElms] : tagElms instanceof Array ? tagElms : tagElms ? [tagElms] : [this.getLastTag()]; // normalize tagElms array values:
    // 1. removing invalid items
    // 2, if an item is String try to get the matching Tag HTML node
    // 3. get the tag data
    // 4. return a collection of Objects

    tagsToRemove = tagElms.reduce((elms, tagElm) => {
      if (tagElm && typeof tagElm == 'string') tagElm = this.getTagElmByValue(tagElm);
      var tagData = this.tagData(tagElm);
      if (tagElm && tagData && !tagData.readonly) // make sure it's a tag and not some other node
        // because the DOM node might be removed by async animation, the state will be updated while
        // the node might still be in the DOM, so the "update" method should know which nodes to ignore
        elms.push({
          node: tagElm,
          idx: this.getTagIdx(tagData),
          // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)
          data: this.tagData(tagElm, {
            '__removed': true
          })
        });
      return elms;
    }, []);
    tranDuration = typeof tranDuration == "number" ? tranDuration : this.CSSVars.tagHideTransition;

    if (this.settings.mode == 'select') {
      tranDuration = 0;
      this.input.set.call(this);
    } // if only a single tag is to be removed


    if (tagsToRemove.length == 1) {
      if (tagsToRemove[0].node.classList.contains(this.settings.classNames.tagNotAllowed)) silent = true;
    }

    if (!tagsToRemove.length) return;
    this.settings.hooks.beforeRemoveTag(tagsToRemove, {
      tagify: this
    }).then(() => {
      function removeNode(tag) {
        if (!tag.node.parentNode) return;
        tag.node.parentNode.removeChild(tag.node);

        if (!silent) {
          // this.removeValueById(tagData.__uid)
          this.trigger('remove', {
            tag: tag.node,
            index: tag.idx,
            data: tag.data
          });
          this.dropdown.refilter();
          this.dropdown.position();
          this.DOM.input.normalize(); // best-practice when in mix-mode (safe to do always anyways)
          // check if any of the current tags which might have been marked as "duplicate" should be un-marked

          if (this.settings.keepInvalidTags) this.reCheckInvalidTags();
        } else if (this.settings.keepInvalidTags) this.trigger('remove', {
          tag: tag.node,
          index: tag.idx
        });
      }

      function animation(tag) {
        tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + 'px';
        document.body.clientTop; // force repaint for the width to take affect before the "hide" class below

        tag.node.classList.add(this.settings.classNames.tagHide); // manual timeout (hack, since transitionend cannot be used because of hover)

        setTimeout(removeNode.bind(this), tranDuration, tag);
      }

      if (tranDuration && tranDuration > 10 && tagsToRemove.length == 1) animation.call(this, tagsToRemove[0]);else tagsToRemove.forEach(removeNode.bind(this)); // update state regardless of animation

      if (!silent) {
        this.removeTagsFromValue(tagsToRemove.map(tag => tag.node));
        this.update(); // update the original input with the current value

        if (this.settings.mode == 'select') this.setContentEditable(true);
      }
    }).catch(reason => {});
  },

  removeTagsFromDOM() {
    [].slice.call(this.getTagElms()).forEach(elm => elm.parentNode.removeChild(elm));
  },

  /**
   * @param {Array/Node} tags to be removed from the this.value array
   */
  removeTagsFromValue(tags) {
    tags = Array.isArray(tags) ? tags : [tags];
    tags.forEach(tag => {
      var tagData = this.tagData(tag),
          tagIdx = this.getTagIdx(tagData); //  delete tagData.__removed

      if (tagIdx > -1) this.value.splice(tagIdx, 1);
    });
  },

  removeAllTags(opts) {
    opts = opts || {};
    this.value = [];
    if (this.settings.mode == 'mix') this.DOM.input.innerHTML = '';else this.removeTagsFromDOM();
    this.dropdown.position();

    if (this.settings.mode == 'select') {
      this.input.set.call(this);
      this.setContentEditable(true);
    } // technically for now only "withoutChangeEvent" exists in the opts.
    // if more properties will be added later, only pass what's needed to "update"


    this.update(opts);
  },

  postUpdate() {
    var classNames = this.settings.classNames,
        hasValue = this.settings.mode == 'mix' ? this.settings.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
    this.toggleClass(classNames.hasMaxTags, this.value.length >= this.settings.maxTags);
    this.toggleClass(classNames.hasNoTags, !this.value.length);
    this.toggleClass(classNames.empty, !hasValue);
  },

  setOriginalInputValue(v) {
    var inputElm = this.DOM.originalInput;

    if (!this.settings.mixMode.integrated) {
      inputElm.value = v;
      inputElm.tagifyValue = inputElm.value; // must set to "inputElm.value" and not again to "inputValue" because for some reason the browser changes the string afterwards a bit.

      this.setPersistedData(v, 'value');
    }
  },

  /**
   * update the origianl (hidden) input field's value
   * see - https://stackoverflow.com/q/50957841/104380
   */
  update(args) {
    var inputValue = this.getInputValue();
    this.setOriginalInputValue(inputValue);
    this.postUpdate();
    if (!(args || {}).withoutChangeEvent && this.state.loadedOriginalValues) this.triggerChangeEvent();
  },

  getInputValue() {
    var value = this.getCleanValue();
    return this.settings.mode == 'mix' ? this.getMixedTagsAsString(value) : value.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(value) : JSON.stringify(value) : "";
  },

  /**
   * removes properties from `this.value` which are only used internally
   */
  getCleanValue(v) {
    return removeCollectionProp(v || this.value, this.dataProps);
  },

  getMixedTagsAsString() {
    var result = "",
        that = this,
        _interpolator = this.settings.mixTagsInterpolator;

    function iterateChildren(rootNode) {
      rootNode.childNodes.forEach(node => {
        if (node.nodeType == 1) {
          const tagData = that.tagData(node);

          if (node.tagName == 'BR') {
            result += "\r\n";
          }

          if (node.tagName == 'DIV' || node.tagName == 'P') {
            result += "\r\n"; //  if( !node.children.length && node.textContent )
            //  result += node.textContent;

            iterateChildren(node);
          } else if (isNodeTag.call(that, node) && tagData) {
            if (tagData.__removed) return;else result += _interpolator[0] + JSON.stringify(omit(tagData, that.dataProps)) + _interpolator[1];
          }
        } else result += node.textContent;
      });
    }

    iterateChildren(this.DOM.input);
    return result;
  }

}; // legacy support for changed methods names

Tagify.prototype.removeTag = Tagify.prototype.removeTags;




/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-non-extensible.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-non-extensible.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ "./node_modules/core-js/internals/array-fill.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-fill.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = lengthOfArrayLike(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-from.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

var Array = global.Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (;!(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-strong.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/collection-strong.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fastKey = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").fastKey);
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(Prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/collection.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-is-regexp-logic.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-is-regexp-logic.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "./node_modules/core-js/internals/date-to-iso-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/date-to-iso-string.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var padStart = (__webpack_require__(/*! ../internals/string-pad */ "./node_modules/core-js/internals/string-pad.js").start);

var RangeError = global.RangeError;
var abs = Math.abs;
var DatePrototype = Date.prototype;
var n$DateToISOString = DatePrototype.toISOString;
var getTime = uncurryThis(DatePrototype.getTime);
var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);

// `Date.prototype.toISOString` method implementation
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:
module.exports = (fails(function () {
  return n$DateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  n$DateToISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime(this))) throw RangeError('Invalid time value');
  var date = this;
  var year = getUTCFullYear(date);
  var milliseconds = getUTCMilliseconds(date);
  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
  return sign + padStart(abs(year), sign ? 6 : 4, 0) +
    '-' + padStart(getUTCMonth(date) + 1, 2, 0) +
    '-' + padStart(getUTCDate(date), 2, 0) +
    'T' + padStart(getUTCHours(date), 2, 0) +
    ':' + padStart(getUTCMinutes(date), 2, 0) +
    ':' + padStart(getUTCSeconds(date), 2, 0) +
    '.' + padStart(milliseconds, 3, 0) +
    'Z';
} : n$DateToISOString;


/***/ }),

/***/ "./node_modules/core-js/internals/freezing.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/freezing.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "./node_modules/core-js/internals/internal-metadata.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/internal-metadata.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternalModule = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js/internals/object-is-extensible.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/math-log10.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-log10.js ***!
  \******************************************************/
/***/ ((module) => {

var log = Math.log;
var LOG10E = Math.LOG10E;

// eslint-disable-next-line es/no-math-log10 -- safe
module.exports = Math.log10 || function log10(x) {
  return log(x) * LOG10E;
};


/***/ }),

/***/ "./node_modules/core-js/internals/native-url.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/native-url.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return (IS_PURE && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?a=1&c=3'
    || searchParams.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://тест').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#б').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('http://x', undefined).host !== 'x';
});


/***/ }),

/***/ "./node_modules/core-js/internals/not-a-regexp.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/not-a-regexp.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");

var TypeError = global.TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-is-extensible.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-extensible.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(/*! ../internals/array-buffer-non-extensible */ "./node_modules/core-js/internals/array-buffer-non-extensible.js");

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ "./node_modules/core-js/internals/string-pad.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/string-pad.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/tc39/proposal-string-pad-start-end
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var $repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var ceil = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = toString(requireObjectCoercible($this));
    var intMaxLength = toLength(maxLength);
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : toString(fillString);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

module.exports = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-punycode-to-ascii.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/string-punycode-to-ascii.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;

var RangeError = global.RangeError;
var exec = uncurryThis(regexSeparators.exec);
var floor = Math.floor;
var fromCharCode = String.fromCharCode;
var charCodeAt = uncurryThis(''.charCodeAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var split = uncurryThis(''.split);
var toLowerCase = uncurryThis(''.toLowerCase);

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = charCodeAt(string, counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = charCodeAt(string, counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        push(output, value);
        counter--;
      }
    } else {
      push(output, value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  while (delta > baseMinusTMin * tMax >> 1) {
    delta = floor(delta / baseMinusTMin);
    k += base;
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      push(output, fromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    push(output, delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        var k = base;
        while (true) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
          k += base;
        }

        push(output, fromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        handledCPCount++;
      }
    }

    delta++;
    n++;
  }
  return join(output, '');
};

module.exports = function (input) {
  var encoded = [];
  var labels = split(replace(toLowerCase(input), regexSeparators, '\u002E'), '.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);
  }
  return join(encoded, '.');
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.every.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.every.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $every = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").every);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var STRICT_METHOD = arrayMethodIsStrict('every');

// `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: !STRICT_METHOD }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.fill.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.fill.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.from.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.includes.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.includes.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $includes = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes);
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-iso-string.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-iso-string.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toISOString = __webpack_require__(/*! ../internals/date-to-iso-string */ "./node_modules/core-js/internals/date-to-iso-string.js");

// `Date.prototype.toISOString` method
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations
$({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== toISOString }, {
  toISOString: toISOString
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.global-this.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.global-this.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

// `globalThis` object
// https://tc39.es/ecma262/#sec-globalthis
$({ global: true }, {
  globalThis: global
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.json.to-string-tag.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.json.to-string-tag.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.map.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/es.map.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.log10.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.log10.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var log10 = __webpack_require__(/*! ../internals/math-log10 */ "./node_modules/core-js/internals/math-log10.js");

// `Math.log10` method
// https://tc39.es/ecma262/#sec-math.log10
$({ target: 'Math', stat: true }, {
  log10: log10
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.to-string-tag.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.to-string-tag.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

// Math[@@toStringTag] property
// https://tc39.es/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.parse-float.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.parse-float.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseFloat = __webpack_require__(/*! ../internals/number-parse-float */ "./node_modules/core-js/internals/number-parse-float.js");

// `Number.parseFloat` method
// https://tc39.es/ecma262/#sec-number.parseFloat
// eslint-disable-next-line es/no-number-parsefloat -- required for testing
$({ target: 'Number', stat: true, forced: Number.parseFloat != parseFloat }, {
  parseFloat: parseFloat
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.parse-int.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.parse-int.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseInt = __webpack_require__(/*! ../internals/number-parse-int */ "./node_modules/core-js/internals/number-parse-int.js");

// `Number.parseInt` method
// https://tc39.es/ecma262/#sec-number.parseint
// eslint-disable-next-line es/no-number-parseint -- required for testing
$({ target: 'Number', stat: true, forced: Number.parseInt != parseInt }, {
  parseInt: parseInt
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-properties.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-properties.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperties = (__webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js").f);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperties !== defineProperties, sham: !DESCRIPTORS }, {
  defineProperties: defineProperties
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.freeze.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.freeze.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var onFreeze = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").onFreeze);

// eslint-disable-next-line es/no-object-freeze -- safe
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { $freeze(1); });

// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptors.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptors.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.prevent-extensions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.prevent-extensions.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var onFreeze = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").onFreeze);
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// eslint-disable-next-line es/no-object-preventextensions -- safe
var $preventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function () { $preventExtensions(1); });

// `Object.preventExtensions` method
// https://tc39.es/ecma262/#sec-object.preventextensions
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  preventExtensions: function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.set-prototype-of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.construct.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");
var aConstructor = __webpack_require__(/*! ../internals/a-constructor */ "./node_modules/core-js/internals/a-constructor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.set.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/es.set.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.fixed.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.fixed.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/string-html-forced */ "./node_modules/core-js/internals/string-html-forced.js");

// `String.prototype.fixed` method
// https://tc39.es/ecma262/#sec-string.prototype.fixed
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fixed') }, {
  fixed: function fixed() {
    return createHTML(this, 'tt', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.includes.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.starts-with.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.starts-with.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

// eslint-disable-next-line es/no-string-prototype-startswith -- safe
var un$StartsWith = uncurryThis(''.startsWith);
var stringSlice = uncurryThis(''.slice);
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = toString(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = toString(searchString);
    return un$StartsWith
      ? un$StartsWith(that, search, index)
      : stringSlice(that, index, index + search.length) === search;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.to-string-tag.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.to-string-tag.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');


/***/ }),

/***/ "./node_modules/core-js/modules/esnext.global-this.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.global-this.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.global-this */ "./node_modules/core-js/modules/es.global-this.js");


/***/ }),

/***/ "./node_modules/core-js/modules/web.url-search-params.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/web.url-search-params.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var arraySort = __webpack_require__(/*! ../internals/array-sort */ "./node_modules/core-js/internals/array-sort.js");

var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var n$Fetch = getBuiltIn('fetch');
var N$Request = getBuiltIn('Request');
var Headers = getBuiltIn('Headers');
var RequestPrototype = N$Request && N$Request.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var RegExp = global.RegExp;
var TypeError = global.TypeError;
var decodeURIComponent = global.decodeURIComponent;
var encodeURIComponent = global.encodeURIComponent;
var charAt = uncurryThis(''.charAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var splice = uncurryThis([].splice);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = replace(it, plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = replace(result, percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};

var find = /[!'()~]|%20/g;

var replacements = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replacements[match];
};

var serialize = function (it) {
  return replace(encodeURIComponent(it), find, replacer);
};

var validateArgumentsLength = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
}, true);

var URLSearchParamsState = function (init) {
  this.entries = [];
  this.url = null;

  if (init !== undefined) {
    if (isObject(init)) this.parseObject(init);
    else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
  }
};

URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function (url) {
    this.url = url;
    this.update();
  },
  parseObject: function (object) {
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next, step, entryIterator, entryNext, first, second;

    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next = iterator.next;
      while (!(step = call(next, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if (
          (first = call(entryNext, entryIterator)).done ||
          (second = call(entryNext, entryIterator)).done ||
          !call(entryNext, entryIterator).done
        ) throw TypeError('Expected sequence with length 2');
        push(this.entries, { key: $toString(first.value), value: $toString(second.value) });
      }
    } else for (var key in object) if (hasOwn(object, key)) {
      push(this.entries, { key: key, value: $toString(object[key]) });
    }
  },
  parseQuery: function (query) {
    if (query) {
      var attributes = split(query, '&');
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split(attribute, '=');
          push(this.entries, {
            key: deserialize(shift(entry)),
            value: deserialize(join(entry, '='))
          });
        }
      }
    }
  },
  serialize: function () {
    var entries = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      push(result, serialize(entry.key) + '=' + serialize(entry.value));
    } return join(result, '&');
  },
  update: function () {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function () {
    if (this.url) this.url.update();
  }
};

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsPrototype);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  setInternalState(this, new URLSearchParamsState(init));
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    push(state.entries, { key: $toString(name), value: $toString(value) });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = $toString(name);
    var index = 0;
    while (index < entries.length) {
      if (entries[index].key === key) splice(entries, index, 1);
      else index++;
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) push(result, entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = $toString(name);
    var index = 0;
    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = $toString(name);
    var val = $toString(value);
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) splice(entries, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push(entries, { key: key, value: val });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function (a, b) {
      return a.key > b.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && isCallable(Headers)) {
  var headersHas = uncurryThis(HeadersPrototype.has);
  var headersSet = uncurryThis(HeadersPrototype.set);

  var wrapRequestOptions = function (init) {
    if (isObject(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers(init.headers) : new Headers();
        if (!headersHas(headers, 'content-type')) {
          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
        return create(init, {
          body: createPropertyDescriptor(0, $toString(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    } return init;
  };

  if (isCallable(n$Fetch)) {
    $({ global: true, enumerable: true, forced: true }, {
      fetch: function fetch(input /* , init */) {
        return n$Fetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }

  if (isCallable(N$Request)) {
    var RequestConstructor = function Request(input /* , init */) {
      anInstance(this, RequestPrototype);
      return new N$Request(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };

    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;

    $({ global: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ "./node_modules/core-js/modules/web.url.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/web.url.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var defineProperties = (__webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js").f);
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");
var arrayFrom = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");
var codeAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").codeAt);
var toASCII = __webpack_require__(/*! ../internals/string-punycode-to-ascii */ "./node_modules/core-js/internals/string-punycode-to-ascii.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var URLSearchParamsModule = __webpack_require__(/*! ../modules/web.url-search-params */ "./node_modules/core-js/modules/web.url-search-params.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;

var NativeURL = global.URL;
var TypeError = global.TypeError;
var parseInt = global.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(/./.exec);
var join = uncurryThis([].join);
var numberToString = uncurryThis(1.0.toString);
var pop = uncurryThis([].pop);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var toLowerCase = uncurryThis(''.toLowerCase);
var unshift = uncurryThis([].unshift);

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[a-z]/i;
// eslint-disable-next-line regexp/no-obscure-range -- safe
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
/* eslint-disable regexp/no-control-character -- safe */
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
/* eslint-enable regexp/no-control-character -- safe */
var EOF;

// https://url.spec.whatwg.org/#ipv4-number-parser
var parseIPv4 = function (input) {
  var parts = split(input, '.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == '') {
    parts.length--;
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;
    if (part.length > 1 && charAt(part, 0) == '0') {
      radix = exec(HEX_START, part) ? 16 : 8;
      part = stringSlice(part, radix == 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!exec(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;
      number = parseInt(part, radix);
    }
    push(numbers, number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = pop(numbers);
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// https://url.spec.whatwg.org/#concept-ipv6-parser
// eslint-disable-next-line max-statements -- TODO
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var chr = function () {
    return charAt(input, pointer);
  };

  if (chr() == ':') {
    if (charAt(input, 1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (chr()) {
    if (pieceIndex == 8) return;
    if (chr() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && exec(HEX, chr())) {
      value = value * 16 + parseInt(chr(), 16);
      pointer++;
      length++;
    }
    if (chr() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (chr()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (chr() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!exec(DIGIT, chr())) return;
        while (exec(DIGIT, chr())) {
          number = parseInt(chr(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (chr() == ':') {
      pointer++;
      if (!chr()) return;
    } else if (chr()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

// https://url.spec.whatwg.org/#host-serializing
var serializeHost = function (host) {
  var result, index, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      unshift(result, host % 256);
      host = floor(host / 256);
    } return join(result, '.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += numberToString(host[index], 16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (chr, set) {
  var code = codeAt(chr, 0);
  return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
};

// https://url.spec.whatwg.org/#special-scheme
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

// https://url.spec.whatwg.org/#windows-drive-letter
var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && exec(ALPHA, charAt(string, 0))
    && ((second = charAt(string, 1)) == ':' || (!normalized && second == '|'));
};

// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (
    string.length == 2 ||
    ((third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

// https://url.spec.whatwg.org/#single-dot-path-segment
var isSingleDot = function (segment) {
  return segment === '.' || toLowerCase(segment) === '%2e';
};

// https://url.spec.whatwg.org/#double-dot-path-segment
var isDoubleDot = function (segment) {
  segment = toLowerCase(segment);
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

var URLState = function (url, isBase, base) {
  var urlString = $toString(url);
  var baseState, failure, searchParams;
  if (isBase) {
    failure = this.parse(urlString);
    if (failure) throw TypeError(failure);
    this.searchParams = null;
  } else {
    if (base !== undefined) baseState = new URLState(base, true);
    failure = this.parse(urlString, null, baseState);
    if (failure) throw TypeError(failure);
    searchParams = getInternalSearchParamsState(new URLSearchParams());
    searchParams.bindURL(this);
    this.searchParams = searchParams;
  }
};

URLState.prototype = {
  type: 'URL',
  // https://url.spec.whatwg.org/#url-parsing
  // eslint-disable-next-line max-statements -- TODO
  parse: function (input, stateOverride, base) {
    var url = this;
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = '';
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints, chr, bufferCodePoints, failure;

    input = $toString(input);

    if (!stateOverride) {
      url.scheme = '';
      url.username = '';
      url.password = '';
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = replace(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
    }

    input = replace(input, TAB_AND_NEW_LINE, '');

    codePoints = arrayFrom(input);

    while (pointer <= codePoints.length) {
      chr = codePoints[pointer];
      switch (state) {
        case SCHEME_START:
          if (chr && exec(ALPHA, chr)) {
            buffer += toLowerCase(chr);
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;

        case SCHEME:
          if (chr && (exec(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) {
            buffer += toLowerCase(chr);
          } else if (chr == ':') {
            if (stateOverride && (
              (url.isSpecial() != hasOwn(specialSchemes, buffer)) ||
              (buffer == 'file' && (url.includesCredentials() || url.port !== null)) ||
              (url.scheme == 'file' && !url.host)
            )) return;
            url.scheme = buffer;
            if (stateOverride) {
              if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;
              return;
            }
            buffer = '';
            if (url.scheme == 'file') {
              state = FILE;
            } else if (url.isSpecial() && base && base.scheme == url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (url.isSpecial()) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints[pointer + 1] == '/') {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              push(url.path, '');
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer = '';
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;

        case NO_SCHEME:
          if (!base || (base.cannotBeABaseURL && chr != '#')) return INVALID_SCHEME;
          if (base.cannotBeABaseURL && chr == '#') {
            url.scheme = base.scheme;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base.scheme == 'file' ? FILE : RELATIVE;
          continue;

        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (chr == '/' && codePoints[pointer + 1] == '/') {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          } break;

        case PATH_OR_AUTHORITY:
          if (chr == '/') {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }

        case RELATIVE:
          url.scheme = base.scheme;
          if (chr == EOF) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
          } else if (chr == '/' || (chr == '\\' && url.isSpecial())) {
            state = RELATIVE_SLASH;
          } else if (chr == '?') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = '';
            state = QUERY;
          } else if (chr == '#') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.path.length--;
            state = PATH;
            continue;
          } break;

        case RELATIVE_SLASH:
          if (url.isSpecial() && (chr == '/' || chr == '\\')) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (chr == '/') {
            state = AUTHORITY;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            state = PATH;
            continue;
          } break;

        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (chr != '/' || charAt(buffer, pointer + 1) != '/') continue;
          pointer++;
          break;

        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (chr != '/' && chr != '\\') {
            state = AUTHORITY;
            continue;
          } break;

        case AUTHORITY:
          if (chr == '@') {
            if (seenAt) buffer = '%40' + buffer;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer);
            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint == ':' && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer = '';
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial())
          ) {
            if (seenAt && buffer == '') return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer).length + 1;
            buffer = '';
            state = HOST;
          } else buffer += chr;
          break;

        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme == 'file') {
            state = FILE_HOST;
            continue;
          } else if (chr == ':' && !seenBracket) {
            if (buffer == '') return INVALID_HOST;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PORT;
            if (stateOverride == HOSTNAME) return;
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial())
          ) {
            if (url.isSpecial() && buffer == '') return INVALID_HOST;
            if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (chr == '[') seenBracket = true;
            else if (chr == ']') seenBracket = false;
            buffer += chr;
          } break;

        case PORT:
          if (exec(DIGIT, chr)) {
            buffer += chr;
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial()) ||
            stateOverride
          ) {
            if (buffer != '') {
              var port = parseInt(buffer, 10);
              if (port > 0xFFFF) return INVALID_PORT;
              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;
              buffer = '';
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;

        case FILE:
          url.scheme = 'file';
          if (chr == '/' || chr == '\\') state = FILE_SLASH;
          else if (base && base.scheme == 'file') {
            if (chr == EOF) {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = base.query;
            } else if (chr == '?') {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = '';
              state = QUERY;
            } else if (chr == '#') {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = base.query;
              url.fragment = '';
              state = FRAGMENT;
            } else {
              if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.shortenPath();
              }
              state = PATH;
              continue;
            }
          } else {
            state = PATH;
            continue;
          } break;

        case FILE_SLASH:
          if (chr == '/' || chr == '\\') {
            state = FILE_HOST;
            break;
          }
          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
            if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
            else url.host = base.host;
          }
          state = PATH;
          continue;

        case FILE_HOST:
          if (chr == EOF || chr == '/' || chr == '\\' || chr == '?' || chr == '#') {
            if (!stateOverride && isWindowsDriveLetter(buffer)) {
              state = PATH;
            } else if (buffer == '') {
              url.host = '';
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = url.parseHost(buffer);
              if (failure) return failure;
              if (url.host == 'localhost') url.host = '';
              if (stateOverride) return;
              buffer = '';
              state = PATH_START;
            } continue;
          } else buffer += chr;
          break;

        case PATH_START:
          if (url.isSpecial()) {
            state = PATH;
            if (chr != '/' && chr != '\\') continue;
          } else if (!stateOverride && chr == '?') {
            url.query = '';
            state = QUERY;
          } else if (!stateOverride && chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            state = PATH;
            if (chr != '/') continue;
          } break;

        case PATH:
          if (
            chr == EOF || chr == '/' ||
            (chr == '\\' && url.isSpecial()) ||
            (!stateOverride && (chr == '?' || chr == '#'))
          ) {
            if (isDoubleDot(buffer)) {
              url.shortenPath();
              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else if (isSingleDot(buffer)) {
              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else {
              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                if (url.host) url.host = '';
                buffer = charAt(buffer, 0) + ':'; // normalize windows drive letter
              }
              push(url.path, buffer);
            }
            buffer = '';
            if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) {
              while (url.path.length > 1 && url.path[0] === '') {
                shift(url.path);
              }
            }
            if (chr == '?') {
              url.query = '';
              state = QUERY;
            } else if (chr == '#') {
              url.fragment = '';
              state = FRAGMENT;
            }
          } else {
            buffer += percentEncode(chr, pathPercentEncodeSet);
          } break;

        case CANNOT_BE_A_BASE_URL_PATH:
          if (chr == '?') {
            url.query = '';
            state = QUERY;
          } else if (chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case QUERY:
          if (!stateOverride && chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            if (chr == "'" && url.isSpecial()) url.query += '%27';
            else if (chr == '#') url.query += '%23';
            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case FRAGMENT:
          if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
          break;
      }

      pointer++;
    }
  },
  // https://url.spec.whatwg.org/#host-parsing
  parseHost: function (input) {
    var result, codePoints, index;
    if (charAt(input, 0) == '[') {
      if (charAt(input, input.length - 1) != ']') return INVALID_HOST;
      result = parseIPv6(stringSlice(input, 1, -1));
      if (!result) return INVALID_HOST;
      this.host = result;
    // opaque host
    } else if (!this.isSpecial()) {
      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
      result = '';
      codePoints = arrayFrom(input);
      for (index = 0; index < codePoints.length; index++) {
        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
      }
      this.host = result;
    } else {
      input = toASCII(input);
      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      this.host = result;
    }
  },
  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
  cannotHaveUsernamePasswordPort: function () {
    return !this.host || this.cannotBeABaseURL || this.scheme == 'file';
  },
  // https://url.spec.whatwg.org/#include-credentials
  includesCredentials: function () {
    return this.username != '' || this.password != '';
  },
  // https://url.spec.whatwg.org/#is-special
  isSpecial: function () {
    return hasOwn(specialSchemes, this.scheme);
  },
  // https://url.spec.whatwg.org/#shorten-a-urls-path
  shortenPath: function () {
    var path = this.path;
    var pathSize = path.length;
    if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
      path.length--;
    }
  },
  // https://url.spec.whatwg.org/#concept-url-serializer
  serialize: function () {
    var url = this;
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port = url.port;
    var path = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ':';
    if (host !== null) {
      output += '//';
      if (url.includesCredentials()) {
        output += username + (password ? ':' + password : '') + '@';
      }
      output += serializeHost(host);
      if (port !== null) output += ':' + port;
    } else if (scheme == 'file') output += '//';
    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
    if (query !== null) output += '?' + query;
    if (fragment !== null) output += '#' + fragment;
    return output;
  },
  // https://url.spec.whatwg.org/#dom-url-href
  setHref: function (href) {
    var failure = this.parse(href);
    if (failure) throw TypeError(failure);
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-origin
  getOrigin: function () {
    var scheme = this.scheme;
    var port = this.port;
    if (scheme == 'blob') try {
      return new URLConstructor(scheme.path[0]).origin;
    } catch (error) {
      return 'null';
    }
    if (scheme == 'file' || !this.isSpecial()) return 'null';
    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
  },
  // https://url.spec.whatwg.org/#dom-url-protocol
  getProtocol: function () {
    return this.scheme + ':';
  },
  setProtocol: function (protocol) {
    this.parse($toString(protocol) + ':', SCHEME_START);
  },
  // https://url.spec.whatwg.org/#dom-url-username
  getUsername: function () {
    return this.username;
  },
  setUsername: function (username) {
    var codePoints = arrayFrom($toString(username));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.username = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-password
  getPassword: function () {
    return this.password;
  },
  setPassword: function (password) {
    var codePoints = arrayFrom($toString(password));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.password = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-host
  getHost: function () {
    var host = this.host;
    var port = this.port;
    return host === null ? ''
      : port === null ? serializeHost(host)
      : serializeHost(host) + ':' + port;
  },
  setHost: function (host) {
    if (this.cannotBeABaseURL) return;
    this.parse(host, HOST);
  },
  // https://url.spec.whatwg.org/#dom-url-hostname
  getHostname: function () {
    var host = this.host;
    return host === null ? '' : serializeHost(host);
  },
  setHostname: function (hostname) {
    if (this.cannotBeABaseURL) return;
    this.parse(hostname, HOSTNAME);
  },
  // https://url.spec.whatwg.org/#dom-url-port
  getPort: function () {
    var port = this.port;
    return port === null ? '' : $toString(port);
  },
  setPort: function (port) {
    if (this.cannotHaveUsernamePasswordPort()) return;
    port = $toString(port);
    if (port == '') this.port = null;
    else this.parse(port, PORT);
  },
  // https://url.spec.whatwg.org/#dom-url-pathname
  getPathname: function () {
    var path = this.path;
    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
  },
  setPathname: function (pathname) {
    if (this.cannotBeABaseURL) return;
    this.path = [];
    this.parse(pathname, PATH_START);
  },
  // https://url.spec.whatwg.org/#dom-url-search
  getSearch: function () {
    var query = this.query;
    return query ? '?' + query : '';
  },
  setSearch: function (search) {
    search = $toString(search);
    if (search == '') {
      this.query = null;
    } else {
      if ('?' == charAt(search, 0)) search = stringSlice(search, 1);
      this.query = '';
      this.parse(search, QUERY);
    }
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-searchparams
  getSearchParams: function () {
    return this.searchParams.facade;
  },
  // https://url.spec.whatwg.org/#dom-url-hash
  getHash: function () {
    var fragment = this.fragment;
    return fragment ? '#' + fragment : '';
  },
  setHash: function (hash) {
    hash = $toString(hash);
    if (hash == '') {
      this.fragment = null;
      return;
    }
    if ('#' == charAt(hash, 0)) hash = stringSlice(hash, 1);
    this.fragment = '';
    this.parse(hash, FRAGMENT);
  },
  update: function () {
    this.query = this.searchParams.serialize() || null;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLPrototype);
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var state = setInternalState(that, new URLState(url, false, base));
  if (!DESCRIPTORS) {
    that.href = state.serialize();
    that.origin = state.getOrigin();
    that.protocol = state.getProtocol();
    that.username = state.getUsername();
    that.password = state.getPassword();
    that.host = state.getHost();
    that.hostname = state.getHostname();
    that.port = state.getPort();
    that.pathname = state.getPathname();
    that.search = state.getSearch();
    that.searchParams = state.getSearchParams();
    that.hash = state.getHash();
  }
};

var URLPrototype = URLConstructor.prototype;

var accessorDescriptor = function (getter, setter) {
  return {
    get: function () {
      return getInternalURLState(this)[getter]();
    },
    set: setter && function (value) {
      return getInternalURLState(this)[setter](value);
    },
    configurable: true,
    enumerable: true
  };
};

if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor('serialize', 'setHref'),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor('getOrigin'),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor('getProtocol', 'setProtocol'),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor('getUsername', 'setUsername'),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor('getPassword', 'setPassword'),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor('getHost', 'setHost'),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor('getHostname', 'setHostname'),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor('getPort', 'setPort'),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor('getPathname', 'setPathname'),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor('getSearch', 'setSearch'),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor('getSearchParams'),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor('getHash', 'setHash')
  });
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));
}

setToStringTag(URLConstructor, 'URL');

$({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});


/***/ }),

/***/ "./node_modules/just-extend/index.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/just-extend/index.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ objectExtend)
/* harmony export */ });
var objectExtend = extend;

/*
  var obj = {a: 3, b: 5};
  extend(obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 4, b: 5, c: 8}

  var obj = {a: 3, b: 5};
  extend({}, obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 3, b: 5}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push(4);
  obj; // {a: 3, b: 5, c: [1, 2, 3, 4]}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(true, obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push(4);
  obj; // {a: 3, b: 5, c: [1, 2, 3]}

  extend({a: 4, b: 5}); // {a: 4, b: 5}
  extend({a: 4, b: 5}, 3); {a: 4, b: 5}
  extend({a: 4, b: 5}, true); {a: 4, b: 5}
  extend('hello', {a: 4, b: 5}); // throws
  extend(3, {a: 4, b: 5}); // throws
*/

function extend(/* [deep], obj1, obj2, [objn] */) {
  var args = [].slice.call(arguments);
  var deep = false;
  if (typeof args[0] == 'boolean') {
    deep = args.shift();
  }
  var result = args[0];
  if (isUnextendable(result)) {
    throw new Error('extendee must be an object');
  }
  var extenders = args.slice(1);
  var len = extenders.length;
  for (var i = 0; i < len; i++) {
    var extender = extenders[i];
    for (var key in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, key)) {
        var value = extender[key];
        if (deep && isCloneable(value)) {
          var base = Array.isArray(value) ? [] : {};
          result[key] = extend(
            true,
            Object.prototype.hasOwnProperty.call(result, key) && !isUnextendable(result[key])
              ? result[key]
              : base,
            value
          );
        } else {
          result[key] = value;
        }
      }
    }
  }
  return result;
}

function isCloneable(obj) {
  return Array.isArray(obj) || {}.toString.call(obj) == '[object Object]';
}

function isUnextendable(val) {
  return !val || (typeof val != 'object' && typeof val != 'function');
}




/***/ }),

/***/ "./node_modules/dropzone/dist/dropzone.mjs":
/*!*************************************************!*\
  !*** ./node_modules/dropzone/dist/dropzone.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ $3ed269f2f0fb224b$export$2e2bcd8739ae039),
/* harmony export */   "Dropzone": () => (/* binding */ $3ed269f2f0fb224b$export$2e2bcd8739ae039)
/* harmony export */ });
/* harmony import */ var just_extend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! just-extend */ "./node_modules/just-extend/index.esm.js");
/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");


function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

class $4040acfd8584338d$export$2e2bcd8739ae039 {
    // Add an event listener for given event
    on(event, fn) {
        this._callbacks = this._callbacks || {
        };
        // Create namespace for this event
        if (!this._callbacks[event]) this._callbacks[event] = [];
        this._callbacks[event].push(fn);
        return this;
    }
    emit(event, ...args) {
        this._callbacks = this._callbacks || {
        };
        let callbacks = this._callbacks[event];
        if (callbacks) for (let callback of callbacks)callback.apply(this, args);
        // trigger a corresponding DOM event
        if (this.element) this.element.dispatchEvent(this.makeEvent("dropzone:" + event, {
            args: args
        }));
        return this;
    }
    makeEvent(eventName, detail) {
        let params = {
            bubbles: true,
            cancelable: true,
            detail: detail
        };
        if (typeof window.CustomEvent === "function") return new CustomEvent(eventName, params);
        else {
            // IE 11 support
            // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
            var evt = document.createEvent("CustomEvent");
            evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
            return evt;
        }
    }
    // Remove event listener for given event. If fn is not provided, all event
    // listeners for that event will be removed. If neither is provided, all
    // event listeners will be removed.
    off(event, fn) {
        if (!this._callbacks || arguments.length === 0) {
            this._callbacks = {
            };
            return this;
        }
        // specific event
        let callbacks = this._callbacks[event];
        if (!callbacks) return this;
        // remove all handlers
        if (arguments.length === 1) {
            delete this._callbacks[event];
            return this;
        }
        // remove specific handler
        for(let i = 0; i < callbacks.length; i++){
            let callback = callbacks[i];
            if (callback === fn) {
                callbacks.splice(i, 1);
                break;
            }
        }
        return this;
    }
}



var $fd6031f88dce2e32$exports = {};
$fd6031f88dce2e32$exports = "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail=\"\"></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size=\"\"></span></div>\n    <div class=\"dz-filename\"><span data-dz-name=\"\"></span></div>\n  </div>\n  <div class=\"dz-progress\">\n    <span class=\"dz-upload\" data-dz-uploadprogress=\"\"></span>\n  </div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage=\"\"></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54\" height=\"54\" viewBox=\"0 0 54 54\" fill=\"white\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M10.2071 29.7929L14.2929 25.7071C14.6834 25.3166 15.3166 25.3166 15.7071 25.7071L21.2929 31.2929C21.6834 31.6834 22.3166 31.6834 22.7071 31.2929L38.2929 15.7071C38.6834 15.3166 39.3166 15.3166 39.7071 15.7071L43.7929 19.7929C44.1834 20.1834 44.1834 20.8166 43.7929 21.2071L22.7071 42.2929C22.3166 42.6834 21.6834 42.6834 21.2929 42.2929L10.2071 31.2071C9.81658 30.8166 9.81658 30.1834 10.2071 29.7929Z\"></path>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54\" height=\"54\" viewBox=\"0 0 54 54\" fill=\"white\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M26.2929 20.2929L19.2071 13.2071C18.8166 12.8166 18.1834 12.8166 17.7929 13.2071L13.2071 17.7929C12.8166 18.1834 12.8166 18.8166 13.2071 19.2071L20.2929 26.2929C20.6834 26.6834 20.6834 27.3166 20.2929 27.7071L13.2071 34.7929C12.8166 35.1834 12.8166 35.8166 13.2071 36.2071L17.7929 40.7929C18.1834 41.1834 18.8166 41.1834 19.2071 40.7929L26.2929 33.7071C26.6834 33.3166 27.3166 33.3166 27.7071 33.7071L34.7929 40.7929C35.1834 41.1834 35.8166 41.1834 36.2071 40.7929L40.7929 36.2071C41.1834 35.8166 41.1834 35.1834 40.7929 34.7929L33.7071 27.7071C33.3166 27.3166 33.3166 26.6834 33.7071 26.2929L40.7929 19.2071C41.1834 18.8166 41.1834 18.1834 40.7929 17.7929L36.2071 13.2071C35.8166 12.8166 35.1834 12.8166 34.7929 13.2071L27.7071 20.2929C27.3166 20.6834 26.6834 20.6834 26.2929 20.2929Z\"></path>\n    </svg>\n  </div>\n</div>\n";


let $4ca367182776f80b$var$defaultOptions = {
    /**
   * Has to be specified on elements other than form (or when the form doesn't
   * have an `action` attribute).
   *
   * You can also provide a function that will be called with `files` and
   * `dataBlocks`  and must return the url as string.
   */ url: null,
    /**
   * Can be changed to `"put"` if necessary. You can also provide a function
   * that will be called with `files` and must return the method (since `v3.12.0`).
   */ method: "post",
    /**
   * Will be set on the XHRequest.
   */ withCredentials: false,
    /**
   * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
   * If set to null or 0, no timeout is going to be set.
   */ timeout: null,
    /**
   * How many file uploads to process in parallel (See the
   * Enqueuing file uploads documentation section for more info)
   */ parallelUploads: 2,
    /**
   * Whether to send multiple files in one request. If
   * this it set to true, then the fallback file input element will
   * have the `multiple` attribute as well. This option will
   * also trigger additional events (like `processingmultiple`). See the events
   * documentation section for more information.
   */ uploadMultiple: false,
    /**
   * Whether you want files to be uploaded in chunks to your server. This can't be
   * used in combination with `uploadMultiple`.
   *
   * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
   */ chunking: false,
    /**
   * If `chunking` is enabled, this defines whether **every** file should be chunked,
   * even if the file size is below chunkSize. This means, that the additional chunk
   * form data will be submitted and the `chunksUploaded` callback will be invoked.
   */ forceChunking: false,
    /**
   * If `chunking` is `true`, then this defines the chunk size in bytes.
   */ chunkSize: 2097152,
    /**
   * If `true`, the individual chunks of a file are being uploaded simultaneously.
   */ parallelChunkUploads: false,
    /**
   * Whether a chunk should be retried if it fails.
   */ retryChunks: false,
    /**
   * If `retryChunks` is true, how many times should it be retried.
   */ retryChunksLimit: 3,
    /**
   * The maximum filesize (in MiB) that is allowed to be uploaded.
   */ maxFilesize: 256,
    /**
   * The name of the file param that gets transferred.
   * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
   * Dropzone will append `[]` to the name.
   */ paramName: "file",
    /**
   * Whether thumbnails for images should be generated
   */ createImageThumbnails: true,
    /**
   * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
   */ maxThumbnailFilesize: 10,
    /**
   * If `null`, the ratio of the image will be used to calculate it.
   */ thumbnailWidth: 120,
    /**
   * The same as `thumbnailWidth`. If both are null, images will not be resized.
   */ thumbnailHeight: 120,
    /**
   * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
   * Can be either `contain` or `crop`.
   */ thumbnailMethod: "crop",
    /**
   * If set, images will be resized to these dimensions before being **uploaded**.
   * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
   * ratio of the file will be preserved.
   *
   * The `options.transformFile` function uses these options, so if the `transformFile` function
   * is overridden, these options don't do anything.
   */ resizeWidth: null,
    /**
   * See `resizeWidth`.
   */ resizeHeight: null,
    /**
   * The mime type of the resized image (before it gets uploaded to the server).
   * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
   * See `resizeWidth` for more information.
   */ resizeMimeType: null,
    /**
   * The quality of the resized images. See `resizeWidth`.
   */ resizeQuality: 0.8,
    /**
   * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
   * Can be either `contain` or `crop`.
   */ resizeMethod: "contain",
    /**
   * The base that is used to calculate the **displayed** filesize. You can
   * change this to 1024 if you would rather display kibibytes, mebibytes,
   * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
   * not `1 kilobyte`. You can change this to `1024` if you don't care about
   * validity.
   */ filesizeBase: 1000,
    /**
   * If not `null` defines how many files this Dropzone handles. If it exceeds,
   * the event `maxfilesexceeded` will be called. The dropzone element gets the
   * class `dz-max-files-reached` accordingly so you can provide visual
   * feedback.
   */ maxFiles: null,
    /**
   * An optional object to send additional headers to the server. Eg:
   * `{ "My-Awesome-Header": "header value" }`
   */ headers: null,
    /**
   * Should the default headers be set or not?
   * Accept: application/json <- for requesting json response
   * Cache-Control: no-cache <- Request shouldnt be cached
   * X-Requested-With: XMLHttpRequest <- We sent the request via XMLHttpRequest
   */ defaultHeaders: true,
    /**
   * If `true`, the dropzone element itself will be clickable, if `false`
   * nothing will be clickable.
   *
   * You can also pass an HTML element, a CSS selector (for multiple elements)
   * or an array of those. In that case, all of those elements will trigger an
   * upload when clicked.
   */ clickable: true,
    /**
   * Whether hidden files in directories should be ignored.
   */ ignoreHiddenFiles: true,
    /**
   * The default implementation of `accept` checks the file's mime type or
   * extension against this list. This is a comma separated list of mime
   * types or file extensions.
   *
   * Eg.: `image/*,application/pdf,.psd`
   *
   * If the Dropzone is `clickable` this option will also be used as
   * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
   * parameter on the hidden file input as well.
   */ acceptedFiles: null,
    /**
   * **Deprecated!**
   * Use acceptedFiles instead.
   */ acceptedMimeTypes: null,
    /**
   * If false, files will be added to the queue but the queue will not be
   * processed automatically.
   * This can be useful if you need some additional user input before sending
   * files (or if you want want all files sent at once).
   * If you're ready to send the file simply call `myDropzone.processQueue()`.
   *
   * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
   * section for more information.
   */ autoProcessQueue: true,
    /**
   * If false, files added to the dropzone will not be queued by default.
   * You'll have to call `enqueueFile(file)` manually.
   */ autoQueue: true,
    /**
   * If `true`, this will add a link to every file preview to remove or cancel (if
   * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
   * and `dictRemoveFile` options are used for the wording.
   */ addRemoveLinks: false,
    /**
   * Defines where to display the file previews – if `null` the
   * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
   * selector. The element should have the `dropzone-previews` class so
   * the previews are displayed properly.
   */ previewsContainer: null,
    /**
   * Set this to `true` if you don't want previews to be shown.
   */ disablePreviews: false,
    /**
   * This is the element the hidden input field (which is used when clicking on the
   * dropzone to trigger file selection) will be appended to. This might
   * be important in case you use frameworks to switch the content of your page.
   *
   * Can be a selector string, or an element directly.
   */ hiddenInputContainer: "body",
    /**
   * If null, no capture type will be specified
   * If camera, mobile devices will skip the file selection and choose camera
   * If microphone, mobile devices will skip the file selection and choose the microphone
   * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
   * On apple devices multiple must be set to false.  AcceptedFiles may need to
   * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
   */ capture: null,
    /**
   * **Deprecated**. Use `renameFile` instead.
   */ renameFilename: null,
    /**
   * A function that is invoked before the file is uploaded to the server and renames the file.
   * This function gets the `File` as argument and can use the `file.name`. The actual name of the
   * file that gets used during the upload can be accessed through `file.upload.filename`.
   */ renameFile: null,
    /**
   * If `true` the fallback will be forced. This is very useful to test your server
   * implementations first and make sure that everything works as
   * expected without dropzone if you experience problems, and to test
   * how your fallbacks will look.
   */ forceFallback: false,
    /**
   * The text used before any files are dropped.
   */ dictDefaultMessage: "Drop files here to upload",
    /**
   * The text that replaces the default message text it the browser is not supported.
   */ dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
    /**
   * The text that will be added before the fallback form.
   * If you provide a  fallback element yourself, or if this option is `null` this will
   * be ignored.
   */ dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
    /**
   * If the filesize is too big.
   * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
   */ dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
    /**
   * If the file doesn't match the file type.
   */ dictInvalidFileType: "You can't upload files of this type.",
    /**
   * If the server response was invalid.
   * `{{statusCode}}` will be replaced with the servers status code.
   */ dictResponseError: "Server responded with {{statusCode}} code.",
    /**
   * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
   */ dictCancelUpload: "Cancel upload",
    /**
   * The text that is displayed if an upload was manually canceled
   */ dictUploadCanceled: "Upload canceled.",
    /**
   * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
   */ dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
    /**
   * If `addRemoveLinks` is true, the text to be used to remove a file.
   */ dictRemoveFile: "Remove file",
    /**
   * If this is not null, then the user will be prompted before removing a file.
   */ dictRemoveFileConfirmation: null,
    /**
   * Displayed if `maxFiles` is st and exceeded.
   * The string `{{maxFiles}}` will be replaced by the configuration value.
   */ dictMaxFilesExceeded: "You can not upload any more files.",
    /**
   * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
   * `b` for bytes.
   */ dictFileSizeUnits: {
        tb: "TB",
        gb: "GB",
        mb: "MB",
        kb: "KB",
        b: "b"
    },
    /**
   * Called when dropzone initialized
   * You can add event listeners here
   */ init () {
    },
    /**
   * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
   * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
   * of a function, this needs to return a map.
   *
   * The default implementation does nothing for normal uploads, but adds relevant information for
   * chunked uploads.
   *
   * This is the same as adding hidden input fields in the form element.
   */ params (files, xhr, chunk) {
        if (chunk) return {
            dzuuid: chunk.file.upload.uuid,
            dzchunkindex: chunk.index,
            dztotalfilesize: chunk.file.size,
            dzchunksize: this.options.chunkSize,
            dztotalchunkcount: chunk.file.upload.totalChunkCount,
            dzchunkbyteoffset: chunk.index * this.options.chunkSize
        };
    },
    /**
   * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
   * and a `done` function as parameters.
   *
   * If the done function is invoked without arguments, the file is "accepted" and will
   * be processed. If you pass an error message, the file is rejected, and the error
   * message will be displayed.
   * This function will not be called if the file is too big or doesn't match the mime types.
   */ accept (file, done) {
        return done();
    },
    /**
   * The callback that will be invoked when all chunks have been uploaded for a file.
   * It gets the file for which the chunks have been uploaded as the first parameter,
   * and the `done` function as second. `done()` needs to be invoked when everything
   * needed to finish the upload process is done.
   */ chunksUploaded: function(file, done) {
        done();
    },
    /**
   * Sends the file as binary blob in body instead of form data.
   * If this is set, the `params` option will be ignored.
   * It's an error to set this to `true` along with `uploadMultiple` since
   * multiple files cannot be in a single binary body.
   */ binaryBody: false,
    /**
   * Gets called when the browser is not supported.
   * The default implementation shows the fallback input field and adds
   * a text.
   */ fallback () {
        // This code should pass in IE7... :(
        let messageElement;
        this.element.className = `${this.element.className} dz-browser-not-supported`;
        for (let child of this.element.getElementsByTagName("div"))if (/(^| )dz-message($| )/.test(child.className)) {
            messageElement = child;
            child.className = "dz-message"; // Removes the 'dz-default' class
            break;
        }
        if (!messageElement) {
            messageElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement('<div class="dz-message"><span></span></div>');
            this.element.appendChild(messageElement);
        }
        let span = messageElement.getElementsByTagName("span")[0];
        if (span) {
            if (span.textContent != null) span.textContent = this.options.dictFallbackMessage;
            else if (span.innerText != null) span.innerText = this.options.dictFallbackMessage;
        }
        return this.element.appendChild(this.getFallbackForm());
    },
    /**
   * Gets called to calculate the thumbnail dimensions.
   *
   * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
   *
   *  - `srcWidth` & `srcHeight` (required)
   *  - `trgWidth` & `trgHeight` (required)
   *  - `srcX` & `srcY` (optional, default `0`)
   *  - `trgX` & `trgY` (optional, default `0`)
   *
   * Those values are going to be used by `ctx.drawImage()`.
   */ resize (file, width, height, resizeMethod) {
        let info = {
            srcX: 0,
            srcY: 0,
            srcWidth: file.width,
            srcHeight: file.height
        };
        let srcRatio = file.width / file.height;
        // Automatically calculate dimensions if not specified
        if (width == null && height == null) {
            width = info.srcWidth;
            height = info.srcHeight;
        } else if (width == null) width = height * srcRatio;
        else if (height == null) height = width / srcRatio;
        // Make sure images aren't upscaled
        width = Math.min(width, info.srcWidth);
        height = Math.min(height, info.srcHeight);
        let trgRatio = width / height;
        if (info.srcWidth > width || info.srcHeight > height) {
            // Image is bigger and needs rescaling
            if (resizeMethod === "crop") {
                if (srcRatio > trgRatio) {
                    info.srcHeight = file.height;
                    info.srcWidth = info.srcHeight * trgRatio;
                } else {
                    info.srcWidth = file.width;
                    info.srcHeight = info.srcWidth / trgRatio;
                }
            } else if (resizeMethod === "contain") {
                // Method 'contain'
                if (srcRatio > trgRatio) height = width / srcRatio;
                else width = height * srcRatio;
            } else throw new Error(`Unknown resizeMethod '${resizeMethod}'`);
        }
        info.srcX = (file.width - info.srcWidth) / 2;
        info.srcY = (file.height - info.srcHeight) / 2;
        info.trgWidth = width;
        info.trgHeight = height;
        return info;
    },
    /**
   * Can be used to transform the file (for example, resize an image if necessary).
   *
   * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
   * images according to those dimensions.
   *
   * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
   * to be invoked with the file when the transformation is done.
   */ transformFile (file, done) {
        if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
        else return done(file);
    },
    /**
   * A string that contains the template used for each dropped
   * file. Change it to fulfill your needs but make sure to properly
   * provide all elements.
   *
   * If you want to use an actual HTML element instead of providing a String
   * as a config option, you could create a div with the id `tpl`,
   * put the template inside it and provide the element like this:
   *
   *     document
   *       .querySelector('#tpl')
   *       .innerHTML
   *
   */ previewTemplate: (/*@__PURE__*/$parcel$interopDefault($fd6031f88dce2e32$exports)),
    /*
   Those functions register themselves to the events on init and handle all
   the user interface specific stuff. Overwriting them won't break the upload
   but can break the way it's displayed.
   You can overwrite them if you don't like the default behavior. If you just
   want to add an additional event handler, register it on the dropzone object
   and don't overwrite those options.
   */ // Those are self explanatory and simply concern the DragnDrop.
    drop (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    dragstart (e) {
    },
    dragend (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    dragenter (e) {
        return this.element.classList.add("dz-drag-hover");
    },
    dragover (e) {
        return this.element.classList.add("dz-drag-hover");
    },
    dragleave (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    paste (e) {
    },
    // Called whenever there are no files left in the dropzone anymore, and the
    // dropzone should be displayed as if in the initial state.
    reset () {
        return this.element.classList.remove("dz-started");
    },
    // Called when a file is added to the queue
    // Receives `file`
    addedfile (file) {
        if (this.element === this.previewsContainer) this.element.classList.add("dz-started");
        if (this.previewsContainer && !this.options.disablePreviews) {
            file.previewElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(this.options.previewTemplate.trim());
            file.previewTemplate = file.previewElement; // Backwards compatibility
            this.previewsContainer.appendChild(file.previewElement);
            for (var node of file.previewElement.querySelectorAll("[data-dz-name]"))node.textContent = file.name;
            for (node of file.previewElement.querySelectorAll("[data-dz-size]"))node.innerHTML = this.filesize(file.size);
            if (this.options.addRemoveLinks) {
                file._removeLink = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<a class="dz-remove" href="javascript:undefined;" data-dz-remove>${this.options.dictRemoveFile}</a>`);
                file.previewElement.appendChild(file._removeLink);
            }
            let removeFileEvent = (e)=>{
                e.preventDefault();
                e.stopPropagation();
                if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(this.options.dictCancelUploadConfirmation, ()=>this.removeFile(file)
                );
                else {
                    if (this.options.dictRemoveFileConfirmation) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(this.options.dictRemoveFileConfirmation, ()=>this.removeFile(file)
                    );
                    else return this.removeFile(file);
                }
            };
            for (let removeLink of file.previewElement.querySelectorAll("[data-dz-remove]"))removeLink.addEventListener("click", removeFileEvent);
        }
    },
    // Called whenever a file is removed.
    removedfile (file) {
        if (file.previewElement != null && file.previewElement.parentNode != null) file.previewElement.parentNode.removeChild(file.previewElement);
        return this._updateMaxFilesReachedClass();
    },
    // Called when a thumbnail has been generated
    // Receives `file` and `dataUrl`
    thumbnail (file, dataUrl) {
        if (file.previewElement) {
            file.previewElement.classList.remove("dz-file-preview");
            for (let thumbnailElement of file.previewElement.querySelectorAll("[data-dz-thumbnail]")){
                thumbnailElement.alt = file.name;
                thumbnailElement.src = dataUrl;
            }
            return setTimeout(()=>file.previewElement.classList.add("dz-image-preview")
            , 1);
        }
    },
    // Called whenever an error occurs
    // Receives `file` and `message`
    error (file, message) {
        if (file.previewElement) {
            file.previewElement.classList.add("dz-error");
            if (typeof message !== "string" && message.error) message = message.error;
            for (let node of file.previewElement.querySelectorAll("[data-dz-errormessage]"))node.textContent = message;
        }
    },
    errormultiple () {
    },
    // Called when a file gets processed. Since there is a cue, not all added
    // files are processed immediately.
    // Receives `file`
    processing (file) {
        if (file.previewElement) {
            file.previewElement.classList.add("dz-processing");
            if (file._removeLink) return file._removeLink.innerHTML = this.options.dictCancelUpload;
        }
    },
    processingmultiple () {
    },
    // Called whenever the upload progress gets updated.
    // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
    // To get the total number of bytes of the file, use `file.size`
    uploadprogress (file, progress, bytesSent) {
        if (file.previewElement) for (let node of file.previewElement.querySelectorAll("[data-dz-uploadprogress]"))node.nodeName === "PROGRESS" ? node.value = progress : node.style.width = `${progress}%`;
    },
    // Called whenever the total upload progress gets updated.
    // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
    totaluploadprogress () {
    },
    // Called just before the file is sent. Gets the `xhr` object as second
    // parameter, so you can modify it (for example to add a CSRF token) and a
    // `formData` object to add additional information.
    sending () {
    },
    sendingmultiple () {
    },
    // When the complete upload is finished and successful
    // Receives `file`
    success (file) {
        if (file.previewElement) return file.previewElement.classList.add("dz-success");
    },
    successmultiple () {
    },
    // When the upload is canceled.
    canceled (file) {
        return this.emit("error", file, this.options.dictUploadCanceled);
    },
    canceledmultiple () {
    },
    // When the upload is finished, either with success or an error.
    // Receives `file`
    complete (file) {
        if (file._removeLink) file._removeLink.innerHTML = this.options.dictRemoveFile;
        if (file.previewElement) return file.previewElement.classList.add("dz-complete");
    },
    completemultiple () {
    },
    maxfilesexceeded () {
    },
    maxfilesreached () {
    },
    queuecomplete () {
    },
    addedfiles () {
    }
};
var $4ca367182776f80b$export$2e2bcd8739ae039 = $4ca367182776f80b$var$defaultOptions;


class $3ed269f2f0fb224b$export$2e2bcd8739ae039 extends $4040acfd8584338d$export$2e2bcd8739ae039 {
    static initClass() {
        // Exposing the emitter class, mainly for tests
        this.prototype.Emitter = $4040acfd8584338d$export$2e2bcd8739ae039;
        /*
     This is a list of all available events you can register on a dropzone object.

     You can register an event handler like this:

     dropzone.on("dragEnter", function() { });

     */ this.prototype.events = [
            "drop",
            "dragstart",
            "dragend",
            "dragenter",
            "dragover",
            "dragleave",
            "addedfile",
            "addedfiles",
            "removedfile",
            "thumbnail",
            "error",
            "errormultiple",
            "processing",
            "processingmultiple",
            "uploadprogress",
            "totaluploadprogress",
            "sending",
            "sendingmultiple",
            "success",
            "successmultiple",
            "canceled",
            "canceledmultiple",
            "complete",
            "completemultiple",
            "reset",
            "maxfilesexceeded",
            "maxfilesreached",
            "queuecomplete", 
        ];
        this.prototype._thumbnailQueue = [];
        this.prototype._processingThumbnail = false;
    }
    // Returns all files that have been accepted
    getAcceptedFiles() {
        return this.files.filter((file)=>file.accepted
        ).map((file)=>file
        );
    }
    // Returns all files that have been rejected
    // Not sure when that's going to be useful, but added for completeness.
    getRejectedFiles() {
        return this.files.filter((file)=>!file.accepted
        ).map((file)=>file
        );
    }
    getFilesWithStatus(status) {
        return this.files.filter((file)=>file.status === status
        ).map((file)=>file
        );
    }
    // Returns all files that are in the queue
    getQueuedFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED);
    }
    getUploadingFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING);
    }
    getAddedFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED);
    }
    // Files that are either queued or uploading
    getActiveFiles() {
        return this.files.filter((file)=>file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED
        ).map((file)=>file
        );
    }
    // The function that gets called when Dropzone is initialized. You
    // can (and should) setup event listeners inside this function.
    init() {
        // In case it isn't set already
        if (this.element.tagName === "form") this.element.setAttribute("enctype", "multipart/form-data");
        if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) this.element.appendChild($3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<div class="dz-default dz-message"><button class="dz-button" type="button">${this.options.dictDefaultMessage}</button></div>`));
        if (this.clickableElements.length) {
            let setupHiddenFileInput = ()=>{
                if (this.hiddenFileInput) this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
                this.hiddenFileInput = document.createElement("input");
                this.hiddenFileInput.setAttribute("type", "file");
                if (this.options.maxFiles === null || this.options.maxFiles > 1) this.hiddenFileInput.setAttribute("multiple", "multiple");
                this.hiddenFileInput.className = "dz-hidden-input";
                if (this.options.acceptedFiles !== null) this.hiddenFileInput.setAttribute("accept", this.options.acceptedFiles);
                if (this.options.capture !== null) this.hiddenFileInput.setAttribute("capture", this.options.capture);
                // Making sure that no one can "tab" into this field.
                this.hiddenFileInput.setAttribute("tabindex", "-1");
                // Not setting `display="none"` because some browsers don't accept clicks
                // on elements that aren't displayed.
                this.hiddenFileInput.style.visibility = "hidden";
                this.hiddenFileInput.style.position = "absolute";
                this.hiddenFileInput.style.top = "0";
                this.hiddenFileInput.style.left = "0";
                this.hiddenFileInput.style.height = "0";
                this.hiddenFileInput.style.width = "0";
                $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.hiddenInputContainer, "hiddenInputContainer").appendChild(this.hiddenFileInput);
                this.hiddenFileInput.addEventListener("change", ()=>{
                    let { files: files  } = this.hiddenFileInput;
                    if (files.length) for (let file of files)this.addFile(file);
                    this.emit("addedfiles", files);
                    setupHiddenFileInput();
                });
            };
            setupHiddenFileInput();
        }
        this.URL = window.URL !== null ? window.URL : window.webkitURL;
        // Setup all event listeners on the Dropzone object itself.
        // They're not in @setupEventListeners() because they shouldn't be removed
        // again when the dropzone gets disabled.
        for (let eventName of this.events)this.on(eventName, this.options[eventName]);
        this.on("uploadprogress", ()=>this.updateTotalUploadProgress()
        );
        this.on("removedfile", ()=>this.updateTotalUploadProgress()
        );
        this.on("canceled", (file)=>this.emit("complete", file)
        );
        // Emit a `queuecomplete` event if all files finished uploading.
        this.on("complete", (file)=>{
            if (this.getAddedFiles().length === 0 && this.getUploadingFiles().length === 0 && this.getQueuedFiles().length === 0) // This needs to be deferred so that `queuecomplete` really triggers after `complete`
            return setTimeout(()=>this.emit("queuecomplete")
            , 0);
        });
        const containsFiles = function(e) {
            if (e.dataTransfer.types) // Because e.dataTransfer.types is an Object in
            // IE, we need to iterate like this instead of
            // using e.dataTransfer.types.some()
            for(var i = 0; i < e.dataTransfer.types.length; i++){
                if (e.dataTransfer.types[i] === "Files") return true;
            }
            return false;
        };
        let noPropagation = function(e) {
            // If there are no files, we don't want to stop
            // propagation so we don't interfere with other
            // drag and drop behaviour.
            if (!containsFiles(e)) return;
            e.stopPropagation();
            if (e.preventDefault) return e.preventDefault();
            else return e.returnValue = false;
        };
        // Create the listeners
        this.listeners = [
            {
                element: this.element,
                events: {
                    dragstart: (e)=>{
                        return this.emit("dragstart", e);
                    },
                    dragenter: (e)=>{
                        noPropagation(e);
                        return this.emit("dragenter", e);
                    },
                    dragover: (e)=>{
                        // Makes it possible to drag files from chrome's download bar
                        // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                        // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                        let efct;
                        try {
                            efct = e.dataTransfer.effectAllowed;
                        } catch (error) {
                        }
                        e.dataTransfer.dropEffect = "move" === efct || "linkMove" === efct ? "move" : "copy";
                        noPropagation(e);
                        return this.emit("dragover", e);
                    },
                    dragleave: (e)=>{
                        return this.emit("dragleave", e);
                    },
                    drop: (e)=>{
                        noPropagation(e);
                        return this.drop(e);
                    },
                    dragend: (e)=>{
                        return this.emit("dragend", e);
                    }
                }
            }, 
        ];
        this.clickableElements.forEach((clickableElement)=>{
            return this.listeners.push({
                element: clickableElement,
                events: {
                    click: (evt)=>{
                        // Only the actual dropzone or the message element should trigger file selection
                        if (clickableElement !== this.element || evt.target === this.element || $3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside(evt.target, this.element.querySelector(".dz-message"))) this.hiddenFileInput.click(); // Forward the click
                        return true;
                    }
                }
            });
        });
        this.enable();
        return this.options.init.call(this);
    }
    // Not fully tested yet
    destroy() {
        this.disable();
        this.removeAllFiles(true);
        if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
            this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
            this.hiddenFileInput = null;
        }
        delete this.element.dropzone;
        return $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.splice($3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.indexOf(this), 1);
    }
    updateTotalUploadProgress() {
        let totalUploadProgress;
        let totalBytesSent = 0;
        let totalBytes = 0;
        let activeFiles = this.getActiveFiles();
        if (activeFiles.length) {
            for (let file of this.getActiveFiles()){
                totalBytesSent += file.upload.bytesSent;
                totalBytes += file.upload.total;
            }
            totalUploadProgress = 100 * totalBytesSent / totalBytes;
        } else totalUploadProgress = 100;
        return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
    }
    // @options.paramName can be a function taking one parameter rather than a string.
    // A parameter name for a file is obtained simply by calling this with an index number.
    _getParamName(n) {
        if (typeof this.options.paramName === "function") return this.options.paramName(n);
        else return `${this.options.paramName}${this.options.uploadMultiple ? `[${n}]` : ""}`;
    }
    // If @options.renameFile is a function,
    // the function will be used to rename the file.name before appending it to the formData
    _renameFile(file) {
        if (typeof this.options.renameFile !== "function") return file.name;
        return this.options.renameFile(file);
    }
    // Returns a form that can be used as fallback if the browser does not support DragnDrop
    //
    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
    // This code has to pass in IE7 :(
    getFallbackForm() {
        let existingFallback, form;
        if (existingFallback = this.getExistingFallback()) return existingFallback;
        let fieldsString = '<div class="dz-fallback">';
        if (this.options.dictFallbackText) fieldsString += `<p>${this.options.dictFallbackText}</p>`;
        fieldsString += `<input type="file" name="${this._getParamName(0)}" ${this.options.uploadMultiple ? 'multiple="multiple"' : undefined} /><input type="submit" value="Upload!"></div>`;
        let fields = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(fieldsString);
        if (this.element.tagName !== "FORM") {
            form = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<form action="${this.options.url}" enctype="multipart/form-data" method="${this.options.method}"></form>`);
            form.appendChild(fields);
        } else {
            // Make sure that the enctype and method attributes are set properly
            this.element.setAttribute("enctype", "multipart/form-data");
            this.element.setAttribute("method", this.options.method);
        }
        return form != null ? form : fields;
    }
    // Returns the fallback elements if they exist already
    //
    // This code has to pass in IE7 :(
    getExistingFallback() {
        let getFallback = function(elements) {
            for (let el of elements){
                if (/(^| )fallback($| )/.test(el.className)) return el;
            }
        };
        for (let tagName of [
            "div",
            "form"
        ]){
            var fallback;
            if (fallback = getFallback(this.element.getElementsByTagName(tagName))) return fallback;
        }
    }
    // Activates all listeners stored in @listeners
    setupEventListeners() {
        return this.listeners.map((elementListeners)=>(()=>{
                let result = [];
                for(let event in elementListeners.events){
                    let listener = elementListeners.events[event];
                    result.push(elementListeners.element.addEventListener(event, listener, false));
                }
                return result;
            })()
        );
    }
    // Deactivates all listeners stored in @listeners
    removeEventListeners() {
        return this.listeners.map((elementListeners)=>(()=>{
                let result = [];
                for(let event in elementListeners.events){
                    let listener = elementListeners.events[event];
                    result.push(elementListeners.element.removeEventListener(event, listener, false));
                }
                return result;
            })()
        );
    }
    // Removes all event listeners and cancels all files in the queue or being processed.
    disable() {
        this.clickableElements.forEach((element)=>element.classList.remove("dz-clickable")
        );
        this.removeEventListeners();
        this.disabled = true;
        return this.files.map((file)=>this.cancelUpload(file)
        );
    }
    enable() {
        delete this.disabled;
        this.clickableElements.forEach((element)=>element.classList.add("dz-clickable")
        );
        return this.setupEventListeners();
    }
    // Returns a nicely formatted filesize
    filesize(size) {
        let selectedSize = 0;
        let selectedUnit = "b";
        if (size > 0) {
            let units = [
                "tb",
                "gb",
                "mb",
                "kb",
                "b"
            ];
            for(let i = 0; i < units.length; i++){
                let unit = units[i];
                let cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
                if (size >= cutoff) {
                    selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
                    selectedUnit = unit;
                    break;
                }
            }
            selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
        }
        return `<strong>${selectedSize}</strong> ${this.options.dictFileSizeUnits[selectedUnit]}`;
    }
    // Adds or removes the `dz-max-files-reached` class from the form.
    _updateMaxFilesReachedClass() {
        if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
            if (this.getAcceptedFiles().length === this.options.maxFiles) this.emit("maxfilesreached", this.files);
            return this.element.classList.add("dz-max-files-reached");
        } else return this.element.classList.remove("dz-max-files-reached");
    }
    drop(e) {
        if (!e.dataTransfer) return;
        this.emit("drop", e);
        // Convert the FileList to an Array
        // This is necessary for IE11
        let files = [];
        for(let i = 0; i < e.dataTransfer.files.length; i++)files[i] = e.dataTransfer.files[i];
        // Even if it's a folder, files.length will contain the folders.
        if (files.length) {
            let { items: items  } = e.dataTransfer;
            if (items && items.length && items[0].webkitGetAsEntry != null) // The browser supports dropping of folders, so handle items instead of files
            this._addFilesFromItems(items);
            else this.handleFiles(files);
        }
        this.emit("addedfiles", files);
    }
    paste(e) {
        if ($3ed269f2f0fb224b$var$__guard__(e != null ? e.clipboardData : undefined, (x)=>x.items
        ) == null) return;
        this.emit("paste", e);
        let { items: items  } = e.clipboardData;
        if (items.length) return this._addFilesFromItems(items);
    }
    handleFiles(files) {
        for (let file of files)this.addFile(file);
    }
    // When a folder is dropped (or files are pasted), items must be handled
    // instead of files.
    _addFilesFromItems(items) {
        return (()=>{
            let result = [];
            for (let item of items){
                var entry;
                if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
                    if (entry.isFile) result.push(this.addFile(item.getAsFile()));
                    else if (entry.isDirectory) // Append all files from that directory to files
                    result.push(this._addFilesFromDirectory(entry, entry.name));
                    else result.push(undefined);
                } else if (item.getAsFile != null) {
                    if (item.kind == null || item.kind === "file") result.push(this.addFile(item.getAsFile()));
                    else result.push(undefined);
                } else result.push(undefined);
            }
            return result;
        })();
    }
    // Goes through the directory, and adds each file it finds recursively
    _addFilesFromDirectory(directory, path) {
        let dirReader = directory.createReader();
        let errorHandler = (error)=>$3ed269f2f0fb224b$var$__guardMethod__(console, "log", (o)=>o.log(error)
            )
        ;
        var readEntries = ()=>{
            return dirReader.readEntries((entries)=>{
                if (entries.length > 0) {
                    for (let entry of entries){
                        if (entry.isFile) entry.file((file)=>{
                            if (this.options.ignoreHiddenFiles && file.name.substring(0, 1) === ".") return;
                            file.fullPath = `${path}/${file.name}`;
                            return this.addFile(file);
                        });
                        else if (entry.isDirectory) this._addFilesFromDirectory(entry, `${path}/${entry.name}`);
                    }
                    // Recursively call readEntries() again, since browser only handle
                    // the first 100 entries.
                    // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                    readEntries();
                }
                return null;
            }, errorHandler);
        };
        return readEntries();
    }
    // If `done()` is called without argument the file is accepted
    // If you call it with an error message, the file is rejected
    // (This allows for asynchronous validation)
    //
    // This function checks the filesize, and if the file.type passes the
    // `acceptedFiles` check.
    accept(file, done) {
        if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1048576) done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
        else if (!$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile(file, this.options.acceptedFiles)) done(this.options.dictInvalidFileType);
        else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
            done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
            this.emit("maxfilesexceeded", file);
        } else this.options.accept.call(this, file, done);
    }
    addFile(file) {
        file.upload = {
            uuid: $3ed269f2f0fb224b$export$2e2bcd8739ae039.uuidv4(),
            progress: 0,
            // Setting the total upload size to file.size for the beginning
            // It's actual different than the size to be transmitted.
            total: file.size,
            bytesSent: 0,
            filename: this._renameFile(file)
        };
        this.files.push(file);
        file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED;
        this.emit("addedfile", file);
        this._enqueueThumbnail(file);
        this.accept(file, (error)=>{
            if (error) {
                file.accepted = false;
                this._errorProcessing([
                    file
                ], error); // Will set the file.status
            } else {
                file.accepted = true;
                if (this.options.autoQueue) this.enqueueFile(file);
                 // Will set .accepted = true
            }
            this._updateMaxFilesReachedClass();
        });
    }
    // Wrapper for enqueueFile
    enqueueFiles(files) {
        for (let file of files)this.enqueueFile(file);
        return null;
    }
    enqueueFile(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED && file.accepted === true) {
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
            if (this.options.autoProcessQueue) return setTimeout(()=>this.processQueue()
            , 0); // Deferring the call
        } else throw new Error("This file can't be queued because it has already been processed or was rejected.");
    }
    _enqueueThumbnail(file) {
        if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1048576) {
            this._thumbnailQueue.push(file);
            return setTimeout(()=>this._processThumbnailQueue()
            , 0); // Deferring the call
        }
    }
    _processThumbnailQueue() {
        if (this._processingThumbnail || this._thumbnailQueue.length === 0) return;
        this._processingThumbnail = true;
        let file = this._thumbnailQueue.shift();
        return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, (dataUrl)=>{
            this.emit("thumbnail", file, dataUrl);
            this._processingThumbnail = false;
            return this._processThumbnailQueue();
        });
    }
    // Can be called by the user to remove a file
    removeFile(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) this.cancelUpload(file);
        this.files = $3ed269f2f0fb224b$var$without(this.files, file);
        this.emit("removedfile", file);
        if (this.files.length === 0) return this.emit("reset");
    }
    // Removes all files that aren't currently processed from the list
    removeAllFiles(cancelIfNecessary) {
        // Create a copy of files since removeFile() changes the @files array.
        if (cancelIfNecessary == null) cancelIfNecessary = false;
        for (let file of this.files.slice())if (file.status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || cancelIfNecessary) this.removeFile(file);
        return null;
    }
    // Resizes an image before it gets sent to the server. This function is the default behavior of
    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
    // the resized blob.
    resizeImage(file, width, height, resizeMethod, callback) {
        return this.createThumbnail(file, width, height, resizeMethod, true, (dataUrl, canvas)=>{
            if (canvas == null) // The image has not been resized
            return callback(file);
            else {
                let { resizeMimeType: resizeMimeType  } = this.options;
                if (resizeMimeType == null) resizeMimeType = file.type;
                let resizedDataURL = canvas.toDataURL(resizeMimeType, this.options.resizeQuality);
                if (resizeMimeType === "image/jpeg" || resizeMimeType === "image/jpg") // Now add the original EXIF information
                resizedDataURL = $3ed269f2f0fb224b$var$ExifRestore.restore(file.dataURL, resizedDataURL);
                return callback($3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob(resizedDataURL));
            }
        });
    }
    createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
        let fileReader = new FileReader();
        fileReader.onload = ()=>{
            file.dataURL = fileReader.result;
            // Don't bother creating a thumbnail for SVG images since they're vector
            if (file.type === "image/svg+xml") {
                if (callback != null) callback(fileReader.result);
                return;
            }
            this.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
        };
        fileReader.readAsDataURL(file);
    }
    // `mockFile` needs to have these attributes:
    //
    //     { name: 'name', size: 12345, imageUrl: '' }
    //
    // `callback` will be invoked when the image has been downloaded and displayed.
    // `crossOrigin` will be added to the `img` tag when accessing the file.
    displayExistingFile(mockFile, imageUrl, callback, crossOrigin, resizeThumbnail = true) {
        this.emit("addedfile", mockFile);
        this.emit("complete", mockFile);
        if (!resizeThumbnail) {
            this.emit("thumbnail", mockFile, imageUrl);
            if (callback) callback();
        } else {
            let onDone = (thumbnail)=>{
                this.emit("thumbnail", mockFile, thumbnail);
                if (callback) callback();
            };
            mockFile.dataURL = imageUrl;
            this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, this.options.fixOrientation, onDone, crossOrigin);
        }
    }
    createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
        // Not using `new Image` here because of a bug in latest Chrome versions.
        // See https://github.com/enyo/dropzone/pull/226
        let img = document.createElement("img");
        if (crossOrigin) img.crossOrigin = crossOrigin;
        // fixOrientation is not needed anymore with browsers handling imageOrientation
        fixOrientation = getComputedStyle(document.body)["imageOrientation"] == "from-image" ? false : fixOrientation;
        img.onload = ()=>{
            let loadExif = (callback)=>callback(1)
            ;
            if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation) loadExif = (callback)=>EXIF.getData(img, function() {
                    return callback(EXIF.getTag(this, "Orientation"));
                })
            ;
            return loadExif((orientation)=>{
                file.width = img.width;
                file.height = img.height;
                let resizeInfo = this.options.resize.call(this, file, width, height, resizeMethod);
                let canvas = document.createElement("canvas");
                let ctx = canvas.getContext("2d");
                canvas.width = resizeInfo.trgWidth;
                canvas.height = resizeInfo.trgHeight;
                if (orientation > 4) {
                    canvas.width = resizeInfo.trgHeight;
                    canvas.height = resizeInfo.trgWidth;
                }
                switch(orientation){
                    case 2:
                        // horizontal flip
                        ctx.translate(canvas.width, 0);
                        ctx.scale(-1, 1);
                        break;
                    case 3:
                        // 180° rotate left
                        ctx.translate(canvas.width, canvas.height);
                        ctx.rotate(Math.PI);
                        break;
                    case 4:
                        // vertical flip
                        ctx.translate(0, canvas.height);
                        ctx.scale(1, -1);
                        break;
                    case 5:
                        // vertical flip + 90 rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.scale(1, -1);
                        break;
                    case 6:
                        // 90° rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.translate(0, -canvas.width);
                        break;
                    case 7:
                        // horizontal flip + 90 rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.translate(canvas.height, -canvas.width);
                        ctx.scale(-1, 1);
                        break;
                    case 8:
                        // 90° rotate left
                        ctx.rotate(-0.5 * Math.PI);
                        ctx.translate(-canvas.height, 0);
                        break;
                }
                // This is a bugfix for iOS' scaling bug.
                $3ed269f2f0fb224b$var$drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
                let thumbnail = canvas.toDataURL("image/png");
                if (callback != null) return callback(thumbnail, canvas);
            });
        };
        if (callback != null) img.onerror = callback;
        return img.src = file.dataURL;
    }
    // Goes through the queue and processes files if there aren't too many already.
    processQueue() {
        let { parallelUploads: parallelUploads  } = this.options;
        let processingLength = this.getUploadingFiles().length;
        let i = processingLength;
        // There are already at least as many files uploading than should be
        if (processingLength >= parallelUploads) return;
        let queuedFiles = this.getQueuedFiles();
        if (!(queuedFiles.length > 0)) return;
        if (this.options.uploadMultiple) // The files should be uploaded in one request
        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
        else while(i < parallelUploads){
            if (!queuedFiles.length) return;
             // Nothing left to process
            this.processFile(queuedFiles.shift());
            i++;
        }
    }
    // Wrapper for `processFiles`
    processFile(file) {
        return this.processFiles([
            file
        ]);
    }
    // Loads the file, then calls finishedLoading()
    processFiles(files) {
        for (let file of files){
            file.processing = true; // Backwards compatibility
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING;
            this.emit("processing", file);
        }
        if (this.options.uploadMultiple) this.emit("processingmultiple", files);
        return this.uploadFiles(files);
    }
    _getFilesWithXhr(xhr) {
        let files;
        return files = this.files.filter((file)=>file.xhr === xhr
        ).map((file)=>file
        );
    }
    // Cancels the file upload and sets the status to CANCELED
    // **if** the file is actually being uploaded.
    // If it's still in the queue, the file is being removed from it and the status
    // set to CANCELED.
    cancelUpload(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) {
            let groupedFiles = this._getFilesWithXhr(file.xhr);
            for (let groupedFile of groupedFiles)groupedFile.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
            if (typeof file.xhr !== "undefined") file.xhr.abort();
            for (let groupedFile1 of groupedFiles)this.emit("canceled", groupedFile1);
            if (this.options.uploadMultiple) this.emit("canceledmultiple", groupedFiles);
        } else if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED || file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED) {
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
            this.emit("canceled", file);
            if (this.options.uploadMultiple) this.emit("canceledmultiple", [
                file
            ]);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    resolveOption(option, ...args) {
        if (typeof option === "function") return option.apply(this, args);
        return option;
    }
    uploadFile(file) {
        return this.uploadFiles([
            file
        ]);
    }
    uploadFiles(files) {
        this._transformFiles(files, (transformedFiles)=>{
            if (this.options.chunking) {
                // Chunking is not allowed to be used with `uploadMultiple` so we know
                // that there is only __one__file.
                let transformedFile = transformedFiles[0];
                files[0].upload.chunked = this.options.chunking && (this.options.forceChunking || transformedFile.size > this.options.chunkSize);
                files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / this.options.chunkSize);
            }
            if (files[0].upload.chunked) {
                // This file should be sent in chunks!
                // If the chunking option is set, we **know** that there can only be **one** file, since
                // uploadMultiple is not allowed with this option.
                let file = files[0];
                let transformedFile = transformedFiles[0];
                let startedChunkCount = 0;
                file.upload.chunks = [];
                let handleNextChunk = ()=>{
                    let chunkIndex = 0;
                    // Find the next item in file.upload.chunks that is not defined yet.
                    while(file.upload.chunks[chunkIndex] !== undefined)chunkIndex++;
                    // This means, that all chunks have already been started.
                    if (chunkIndex >= file.upload.totalChunkCount) return;
                    startedChunkCount++;
                    let start = chunkIndex * this.options.chunkSize;
                    let end = Math.min(start + this.options.chunkSize, transformedFile.size);
                    let dataBlock = {
                        name: this._getParamName(0),
                        data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),
                        filename: file.upload.filename,
                        chunkIndex: chunkIndex
                    };
                    file.upload.chunks[chunkIndex] = {
                        file: file,
                        index: chunkIndex,
                        dataBlock: dataBlock,
                        status: $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING,
                        progress: 0,
                        retries: 0
                    };
                    this._uploadData(files, [
                        dataBlock
                    ]);
                };
                file.upload.finishedChunkUpload = (chunk, response)=>{
                    let allFinished = true;
                    chunk.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
                    // Clear the data from the chunk
                    chunk.dataBlock = null;
                    chunk.response = chunk.xhr.responseText;
                    chunk.responseHeaders = chunk.xhr.getAllResponseHeaders();
                    // Leaving this reference to xhr will cause memory leaks.
                    chunk.xhr = null;
                    for(let i = 0; i < file.upload.totalChunkCount; i++){
                        if (file.upload.chunks[i] === undefined) return handleNextChunk();
                        if (file.upload.chunks[i].status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS) allFinished = false;
                    }
                    if (allFinished) this.options.chunksUploaded(file, ()=>{
                        this._finished(files, response, null);
                    });
                };
                if (this.options.parallelChunkUploads) for(let i = 0; i < file.upload.totalChunkCount; i++)handleNextChunk();
                else handleNextChunk();
            } else {
                let dataBlocks = [];
                for(let i = 0; i < files.length; i++)dataBlocks[i] = {
                    name: this._getParamName(i),
                    data: transformedFiles[i],
                    filename: files[i].upload.filename
                };
                this._uploadData(files, dataBlocks);
            }
        });
    }
    /// Returns the right chunk for given file and xhr
    _getChunk(file, xhr) {
        for(let i = 0; i < file.upload.totalChunkCount; i++){
            if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) return file.upload.chunks[i];
        }
    }
    // This function actually uploads the file(s) to the server.
    //
    //  If dataBlocks contains the actual data to upload (meaning, that this could
    // either be transformed files, or individual chunks for chunked upload) then
    // they will be used for the actual data to upload.
    _uploadData(files, dataBlocks) {
        let xhr = new XMLHttpRequest();
        // Put the xhr object in the file objects to be able to reference it later.
        for (let file of files)file.xhr = xhr;
        if (files[0].upload.chunked) // Put the xhr object in the right chunk object, so it can be associated
        // later, and found with _getChunk.
        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
        let method = this.resolveOption(this.options.method, files, dataBlocks);
        let url = this.resolveOption(this.options.url, files, dataBlocks);
        xhr.open(method, url, true);
        // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8
        let timeout = this.resolveOption(this.options.timeout, files);
        if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files);
        // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179
        xhr.withCredentials = !!this.options.withCredentials;
        xhr.onload = (e)=>{
            this._finishedUploading(files, xhr, e);
        };
        xhr.ontimeout = ()=>{
            this._handleUploadError(files, xhr, `Request timedout after ${this.options.timeout / 1000} seconds`);
        };
        xhr.onerror = ()=>{
            this._handleUploadError(files, xhr);
        };
        // Some browsers do not have the .upload property
        let progressObj = xhr.upload != null ? xhr.upload : xhr;
        progressObj.onprogress = (e)=>this._updateFilesUploadProgress(files, xhr, e)
        ;
        let headers = this.options.defaultHeaders ? {
            Accept: "application/json",
            "Cache-Control": "no-cache",
            "X-Requested-With": "XMLHttpRequest"
        } : {
        };
        if (this.options.binaryBody) headers["Content-Type"] = files[0].type;
        if (this.options.headers) (0,just_extend__WEBPACK_IMPORTED_MODULE_0__["default"])(headers, this.options.headers);
        for(let headerName in headers){
            let headerValue = headers[headerName];
            if (headerValue) xhr.setRequestHeader(headerName, headerValue);
        }
        if (this.options.binaryBody) {
            // Since the file is going to be sent as binary body, it doesn't make
            // any sense to generate `FormData` for it.
            for (let file of files)this.emit("sending", file, xhr);
            if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr);
            this.submitRequest(xhr, null, files);
        } else {
            let formData = new FormData();
            // Adding all @options parameters
            if (this.options.params) {
                let additionalParams = this.options.params;
                if (typeof additionalParams === "function") additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
                for(let key in additionalParams){
                    let value = additionalParams[key];
                    if (Array.isArray(value)) // The additional parameter contains an array,
                    // so lets iterate over it to attach each value
                    // individually.
                    for(let i = 0; i < value.length; i++)formData.append(key, value[i]);
                    else formData.append(key, value);
                }
            }
            // Let the user add additional data if necessary
            for (let file of files)this.emit("sending", file, xhr, formData);
            if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr, formData);
            this._addFormElementData(formData);
            // Finally add the files
            // Has to be last because some servers (eg: S3) expect the file to be the last parameter
            for(let i = 0; i < dataBlocks.length; i++){
                let dataBlock = dataBlocks[i];
                formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
            }
            this.submitRequest(xhr, formData, files);
        }
    }
    // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
    _transformFiles(files, done) {
        let transformedFiles = [];
        // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.
        let doneCounter = 0;
        for(let i = 0; i < files.length; i++)this.options.transformFile.call(this, files[i], (transformedFile)=>{
            transformedFiles[i] = transformedFile;
            if (++doneCounter === files.length) done(transformedFiles);
        });
    }
    // Takes care of adding other input elements of the form to the AJAX request
    _addFormElementData(formData) {
        // Take care of other input elements
        if (this.element.tagName === "FORM") for (let input of this.element.querySelectorAll("input, textarea, select, button")){
            let inputName = input.getAttribute("name");
            let inputType = input.getAttribute("type");
            if (inputType) inputType = inputType.toLowerCase();
            // If the input doesn't have a name, we can't use it.
            if (typeof inputName === "undefined" || inputName === null) continue;
            if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
                // Possibly multiple values
                for (let option of input.options)if (option.selected) formData.append(inputName, option.value);
            } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) formData.append(inputName, input.value);
        }
    }
    // Invoked when there is new progress information about given files.
    // If e is not provided, it is assumed that the upload is finished.
    _updateFilesUploadProgress(files, xhr, e) {
        if (!files[0].upload.chunked) // Handle file uploads without chunking
        for (let file of files){
            if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) continue;
            if (e) {
                file.upload.progress = 100 * e.loaded / e.total;
                file.upload.total = e.total;
                file.upload.bytesSent = e.loaded;
            } else {
                // No event, so we're at 100%
                file.upload.progress = 100;
                file.upload.bytesSent = file.upload.total;
            }
            this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
        }
        else {
            // Handle chunked file uploads
            // Chunked upload is not compatible with uploading multiple files in one
            // request, so we know there's only one file.
            let file = files[0];
            // Since this is a chunked upload, we need to update the appropriate chunk
            // progress.
            let chunk = this._getChunk(file, xhr);
            if (e) {
                chunk.progress = 100 * e.loaded / e.total;
                chunk.total = e.total;
                chunk.bytesSent = e.loaded;
            } else {
                // No event, so we're at 100%
                chunk.progress = 100;
                chunk.bytesSent = chunk.total;
            }
            // Now tally the *file* upload progress from its individual chunks
            file.upload.progress = 0;
            file.upload.total = 0;
            file.upload.bytesSent = 0;
            for(let i = 0; i < file.upload.totalChunkCount; i++)if (file.upload.chunks[i] && typeof file.upload.chunks[i].progress !== "undefined") {
                file.upload.progress += file.upload.chunks[i].progress;
                file.upload.total += file.upload.chunks[i].total;
                file.upload.bytesSent += file.upload.chunks[i].bytesSent;
            }
            // Since the process is a percentage, we need to divide by the amount of
            // chunks we've used.
            file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
            this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
        }
    }
    _finishedUploading(files, xhr, e) {
        let response;
        if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
        if (xhr.readyState !== 4) return;
        if (xhr.responseType !== "arraybuffer" && xhr.responseType !== "blob") {
            response = xhr.responseText;
            if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) try {
                response = JSON.parse(response);
            } catch (error) {
                e = error;
                response = "Invalid JSON response from server.";
            }
        }
        this._updateFilesUploadProgress(files, xhr);
        if (!(200 <= xhr.status && xhr.status < 300)) this._handleUploadError(files, xhr, response);
        else if (files[0].upload.chunked) files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);
        else this._finished(files, response, e);
    }
    _handleUploadError(files, xhr, response) {
        if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
        if (files[0].upload.chunked && this.options.retryChunks) {
            let chunk = this._getChunk(files[0], xhr);
            if ((chunk.retries++) < this.options.retryChunksLimit) {
                this._uploadData(files, [
                    chunk.dataBlock
                ]);
                return;
            } else console.warn("Retried this chunk too often. Giving up.");
        }
        this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
    }
    submitRequest(xhr, formData, files) {
        if (xhr.readyState != 1) {
            console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED.");
            return;
        }
        if (this.options.binaryBody) {
            if (files[0].upload.chunked) {
                const chunk = this._getChunk(files[0], xhr);
                xhr.send(chunk.dataBlock.data);
            } else xhr.send(files[0]);
        } else xhr.send(formData);
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _finished(files, responseText, e) {
        for (let file of files){
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
            this.emit("success", file, responseText, e);
            this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
            this.emit("successmultiple", files, responseText, e);
            this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _errorProcessing(files, message, xhr) {
        for (let file of files){
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR;
            this.emit("error", file, message, xhr);
            this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
            this.emit("errormultiple", files, message, xhr);
            this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    static uuidv4() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            let r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
            return v.toString(16);
        });
    }
    constructor(el, options){
        super();
        let fallback, left;
        this.element = el;
        this.clickableElements = [];
        this.listeners = [];
        this.files = []; // All files
        if (typeof this.element === "string") this.element = document.querySelector(this.element);
        // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.
        if (!this.element || this.element.nodeType == null) throw new Error("Invalid dropzone element.");
        if (this.element.dropzone) throw new Error("Dropzone already attached.");
        // Now add this dropzone to the instances.
        $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.push(this);
        // Put the dropzone inside the element itself.
        this.element.dropzone = this;
        let elementOptions = (left = $3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(this.element)) != null ? left : {
        };
        this.options = (0,just_extend__WEBPACK_IMPORTED_MODULE_0__["default"])(true, {
        }, $4ca367182776f80b$export$2e2bcd8739ae039, elementOptions, options != null ? options : {
        });
        this.options.previewTemplate = this.options.previewTemplate.replace(/\n*/g, "");
        // If the browser failed, just call the fallback and leave
        if (this.options.forceFallback || !$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported()) return this.options.fallback.call(this);
        // @options.url = @element.getAttribute "action" unless @options.url?
        if (this.options.url == null) this.options.url = this.element.getAttribute("action");
        if (!this.options.url) throw new Error("No URL provided.");
        if (this.options.acceptedFiles && this.options.acceptedMimeTypes) throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
        if (this.options.uploadMultiple && this.options.chunking) throw new Error("You cannot set both: uploadMultiple and chunking.");
        if (this.options.binaryBody && this.options.uploadMultiple) throw new Error("You cannot set both: binaryBody and uploadMultiple.");
        // Backwards compatibility
        if (this.options.acceptedMimeTypes) {
            this.options.acceptedFiles = this.options.acceptedMimeTypes;
            delete this.options.acceptedMimeTypes;
        }
        // Backwards compatibility
        if (this.options.renameFilename != null) this.options.renameFile = (file)=>this.options.renameFilename.call(this, file.name, file)
        ;
        if (typeof this.options.method === "string") this.options.method = this.options.method.toUpperCase();
        if ((fallback = this.getExistingFallback()) && fallback.parentNode) // Remove the fallback
        fallback.parentNode.removeChild(fallback);
        // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false
        if (this.options.previewsContainer !== false) {
            if (this.options.previewsContainer) this.previewsContainer = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.previewsContainer, "previewsContainer");
            else this.previewsContainer = this.element;
        }
        if (this.options.clickable) {
            if (this.options.clickable === true) this.clickableElements = [
                this.element
            ];
            else this.clickableElements = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements(this.options.clickable, "clickable");
        }
        this.init();
    }
}
$3ed269f2f0fb224b$export$2e2bcd8739ae039.initClass();
// This is a map of options for your different dropzones. Add configurations
// to this object for your different dropzone elemens.
//
// Example:
//
//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
//
// And in html:
//
//     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>
$3ed269f2f0fb224b$export$2e2bcd8739ae039.options = {
};
// Returns the options for an element or undefined if none available.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement = function(element) {
    // Get the `Dropzone.options.elementId` for this element if it exists
    if (element.getAttribute("id")) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.options[$3ed269f2f0fb224b$var$camelize(element.getAttribute("id"))];
    else return undefined;
};
// Holds a list of all dropzone instances
$3ed269f2f0fb224b$export$2e2bcd8739ae039.instances = [];
// Returns the dropzone for given element if any
$3ed269f2f0fb224b$export$2e2bcd8739ae039.forElement = function(element) {
    if (typeof element === "string") element = document.querySelector(element);
    if ((element != null ? element.dropzone : undefined) == null) throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
    return element.dropzone;
};
// Looks for all .dropzone elements and creates a dropzone for them
$3ed269f2f0fb224b$export$2e2bcd8739ae039.discover = function() {
    let dropzones;
    if (document.querySelectorAll) dropzones = document.querySelectorAll(".dropzone");
    else {
        dropzones = [];
        // IE :(
        let checkElements = (elements)=>(()=>{
                let result = [];
                for (let el of elements)if (/(^| )dropzone($| )/.test(el.className)) result.push(dropzones.push(el));
                else result.push(undefined);
                return result;
            })()
        ;
        checkElements(document.getElementsByTagName("div"));
        checkElements(document.getElementsByTagName("form"));
    }
    return (()=>{
        let result = [];
        for (let dropzone of dropzones)// Create a dropzone unless auto discover has been disabled for specific element
        if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(dropzone) !== false) result.push(new $3ed269f2f0fb224b$export$2e2bcd8739ae039(dropzone));
        else result.push(undefined);
        return result;
    })();
};
// Some browsers support drag and drog functionality, but not correctly.
//
// So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.
// But what to do when browsers *theoretically* support an API, but crash
// when using it.
//
// This is a list of regular expressions tested against navigator.userAgent
//
// ** It should only be used on browser that *do* support the API, but
// incorrectly **
$3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = [
    // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
    /opera.*(Macintosh|Windows Phone).*version\/12/i, 
];
// Checks if the browser is supported
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported = function() {
    let capableBrowser = true;
    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
        if (!("classList" in document.createElement("a"))) capableBrowser = false;
        else {
            if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers !== undefined) // Since this has been renamed, this makes sure we don't break older
            // configuration.
            $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = $3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers;
            // The browser supports the API, but may be blocked.
            for (let regex of $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers)if (regex.test(navigator.userAgent)) {
                capableBrowser = false;
                continue;
            }
        }
    } else capableBrowser = false;
    return capableBrowser;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob = function(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    let byteString = atob(dataURI.split(",")[1]);
    // separate out the mime component
    let mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
    // write the bytes of the string to an ArrayBuffer
    let ab = new ArrayBuffer(byteString.length);
    let ia = new Uint8Array(ab);
    for(let i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--)ia[i] = byteString.charCodeAt(i);
    // write the ArrayBuffer to a blob
    return new Blob([
        ab
    ], {
        type: mimeString
    });
};
// Returns an array without the rejected item
const $3ed269f2f0fb224b$var$without = (list, rejectedItem)=>list.filter((item)=>item !== rejectedItem
    ).map((item)=>item
    )
;
// abc-def_ghi -> abcDefGhi
const $3ed269f2f0fb224b$var$camelize = (str)=>str.replace(/[\-_](\w)/g, (match)=>match.charAt(1).toUpperCase()
    )
;
// Creates an element from string
$3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement = function(string) {
    let div = document.createElement("div");
    div.innerHTML = string;
    return div.childNodes[0];
};
// Tests if given element is inside (or simply is) the container
$3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside = function(element, container) {
    if (element === container) return true;
     // Coffeescript doesn't support do/while loops
    while(element = element.parentNode){
        if (element === container) return true;
    }
    return false;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement = function(el, name) {
    let element;
    if (typeof el === "string") element = document.querySelector(el);
    else if (el.nodeType != null) element = el;
    if (element == null) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector or a plain HTML element.`);
    return element;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements = function(els, name) {
    let el, elements;
    if (els instanceof Array) {
        elements = [];
        try {
            for (el of els)elements.push(this.getElement(el, name));
        } catch (e) {
            elements = null;
        }
    } else if (typeof els === "string") {
        elements = [];
        for (el of document.querySelectorAll(els))elements.push(el);
    } else if (els.nodeType != null) elements = [
        els
    ];
    if (elements == null || !elements.length) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector, a plain HTML element or a list of those.`);
    return elements;
};
// Asks the user the question and calls accepted or rejected accordingly
//
// The default implementation just uses `window.confirm` and then calls the
// appropriate callback.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm = function(question, accepted, rejected) {
    if (window.confirm(question)) return accepted();
    else if (rejected != null) return rejected();
};
// Validates the mime type like this:
//
// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile = function(file, acceptedFiles) {
    if (!acceptedFiles) return true;
     // If there are no accepted mime types, it's OK
    acceptedFiles = acceptedFiles.split(",");
    let mimeType = file.type;
    let baseMimeType = mimeType.replace(/\/.*$/, "");
    for (let validType of acceptedFiles){
        validType = validType.trim();
        if (validType.charAt(0) === ".") {
            if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) return true;
        } else if (/\/\*$/.test(validType)) {
            // This is something like a image/* mime type
            if (baseMimeType === validType.replace(/\/.*$/, "")) return true;
        } else {
            if (mimeType === validType) return true;
        }
    }
    return false;
};
// Augment jQuery
if (typeof jQuery !== "undefined" && jQuery !== null) jQuery.fn.dropzone = function(options) {
    return this.each(function() {
        return new $3ed269f2f0fb224b$export$2e2bcd8739ae039(this, options);
    });
};
// Dropzone file status codes
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED = "added";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED = "queued";
// For backwards compatibility. Now, if a file is accepted, it's either queued
// or uploading.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ACCEPTED = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING = "uploading";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.PROCESSING = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING; // alias
$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED = "canceled";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR = "error";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS = "success";
/*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */ // Detecting vertical squash in loaded image.
// Fixes a bug which squash image vertically while drawing into canvas for some images.
// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
let $3ed269f2f0fb224b$var$detectVerticalSquash = function(img) {
    let iw = img.naturalWidth;
    let ih = img.naturalHeight;
    let canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = ih;
    let ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);
    let { data: data  } = ctx.getImageData(1, 0, 1, ih);
    // search image edge pixel position in case it is squashed vertically.
    let sy = 0;
    let ey = ih;
    let py = ih;
    while(py > sy){
        let alpha = data[(py - 1) * 4 + 3];
        if (alpha === 0) ey = py;
        else sy = py;
        py = ey + sy >> 1;
    }
    let ratio = py / ih;
    if (ratio === 0) return 1;
    else return ratio;
};
// A replacement for context.drawImage
// (args are for source and destination).
var $3ed269f2f0fb224b$var$drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
    let vertSquashRatio = $3ed269f2f0fb224b$var$detectVerticalSquash(img);
    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
};
// Based on MinifyJpeg
// Source: http://www.perry.cz/files/ExifRestorer.js
// http://elicon.blog57.fc2.com/blog-entry-206.html
class $3ed269f2f0fb224b$var$ExifRestore {
    static initClass() {
        this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    }
    static encode64(input) {
        let output = "";
        let chr1 = undefined;
        let chr2 = undefined;
        let chr3 = "";
        let enc1 = undefined;
        let enc2 = undefined;
        let enc3 = undefined;
        let enc4 = "";
        let i = 0;
        while(true){
            chr1 = input[i++];
            chr2 = input[i++];
            chr3 = input[i++];
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) enc3 = enc4 = 64;
            else if (isNaN(chr3)) enc4 = 64;
            output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";
            if (!(i < input.length)) break;
        }
        return output;
    }
    static restore(origFileBase64, resizedFileBase64) {
        if (!origFileBase64.match("data:image/jpeg;base64,")) return resizedFileBase64;
        let rawImage = this.decode64(origFileBase64.replace("data:image/jpeg;base64,", ""));
        let segments = this.slice2Segments(rawImage);
        let image = this.exifManipulation(resizedFileBase64, segments);
        return `data:image/jpeg;base64,${this.encode64(image)}`;
    }
    static exifManipulation(resizedFileBase64, segments) {
        let exifArray = this.getExifArray(segments);
        let newImageArray = this.insertExif(resizedFileBase64, exifArray);
        let aBuffer = new Uint8Array(newImageArray);
        return aBuffer;
    }
    static getExifArray(segments) {
        let seg = undefined;
        let x = 0;
        while(x < segments.length){
            seg = segments[x];
            if (seg[0] === 255 & seg[1] === 225) return seg;
            x++;
        }
        return [];
    }
    static insertExif(resizedFileBase64, exifArray) {
        let imageData = resizedFileBase64.replace("data:image/jpeg;base64,", "");
        let buf = this.decode64(imageData);
        let separatePoint = buf.indexOf(255, 3);
        let mae = buf.slice(0, separatePoint);
        let ato = buf.slice(separatePoint);
        let array = mae;
        array = array.concat(exifArray);
        array = array.concat(ato);
        return array;
    }
    static slice2Segments(rawImageArray) {
        let head = 0;
        let segments = [];
        while(true){
            var length;
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) break;
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) head += 2;
            else {
                length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
                let endPoint = head + length + 2;
                let seg = rawImageArray.slice(head, endPoint);
                segments.push(seg);
                head = endPoint;
            }
            if (head > rawImageArray.length) break;
        }
        return segments;
    }
    static decode64(input) {
        let output = "";
        let chr1 = undefined;
        let chr2 = undefined;
        let chr3 = "";
        let enc1 = undefined;
        let enc2 = undefined;
        let enc3 = undefined;
        let enc4 = "";
        let i = 0;
        let buf = [];
        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
        let base64test = /[^A-Za-z0-9\+\/\=]/g;
        if (base64test.exec(input)) console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while(true){
            enc1 = this.KEY_STR.indexOf(input.charAt(i++));
            enc2 = this.KEY_STR.indexOf(input.charAt(i++));
            enc3 = this.KEY_STR.indexOf(input.charAt(i++));
            enc4 = this.KEY_STR.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            buf.push(chr1);
            if (enc3 !== 64) buf.push(chr2);
            if (enc4 !== 64) buf.push(chr3);
            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";
            if (!(i < input.length)) break;
        }
        return buf;
    }
}
$3ed269f2f0fb224b$var$ExifRestore.initClass();
/*
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 */ // @win window reference
// @fn function reference
let $3ed269f2f0fb224b$var$contentLoaded = function(win, fn) {
    let done = false;
    let top = true;
    let doc = win.document;
    let root = doc.documentElement;
    let add = doc.addEventListener ? "addEventListener" : "attachEvent";
    let rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
    let pre = doc.addEventListener ? "" : "on";
    var init = function(e) {
        if (e.type === "readystatechange" && doc.readyState !== "complete") return;
        (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
        if (!done && (done = true)) return fn.call(win, e.type || e);
    };
    var poll = function() {
        try {
            root.doScroll("left");
        } catch (e) {
            setTimeout(poll, 50);
            return;
        }
        return init("poll");
    };
    if (doc.readyState !== "complete") {
        if (doc.createEventObject && root.doScroll) {
            try {
                top = !win.frameElement;
            } catch (error) {
            }
            if (top) poll();
        }
        doc[add](pre + "DOMContentLoaded", init, false);
        doc[add](pre + "readystatechange", init, false);
        return win[add](pre + "load", init, false);
    }
};
function $3ed269f2f0fb224b$var$__guard__(value, transform) {
    return typeof value !== "undefined" && value !== null ? transform(value) : undefined;
}
function $3ed269f2f0fb224b$var$__guardMethod__(obj, methodName, transform) {
    if (typeof obj !== "undefined" && obj !== null && typeof obj[methodName] === "function") return transform(obj, methodName);
    else return undefined;
}



//# sourceMappingURL=dropzone.mjs.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfeWFpcmVvX3RhZ2lmeV9kaXN0X3RhZ2lmeV9lc21fanMtbm9kZV9tb2R1bGVzX2NvcmUtanNfbW9kdWxlc19lc19hcnJheV9lLTIwNTc2Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Qsc0JBQXNCLHNCQUFzQix3QkFB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Q0Qsd0NBQXdDO0FBQ3hDLG9CQUFvQjtBQUNwQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUNBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxVQUFVLFNBQVMsYUFBYTtBQUN4QywwQ0FBMEMsVUFBVSxzQkFBc0IsYUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEMsYUFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySUFBMkksbUJBQW1CLDRCQUE0QjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdNQUFnTSxTQUFTO0FBQ3pNLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFRQUFxUSxnQ0FBZ0M7QUFD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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJFQUEyRSxLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sb0JBQW9CLE1BQU0sV0FBVyxNQUFNO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLGdDQUFnQyxTQUFTLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR21IO0FBQ25IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B5YWlyZW8vdGFnaWZ5L2Rpc3QvdGFnaWZ5LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLW5vbi1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kYXRlLXRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC1sb2cxMC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbm90LWEtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXB1bnljb2RlLXRvLWFzY2lpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZ2xvYmFsLXRoaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5qc29uLnRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC50by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmZpeGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLnRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuZ2xvYmFsLXRoaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qdXN0LWV4dGVuZC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Ryb3B6b25lL2Rpc3QvZHJvcHpvbmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGFnaWZ5ICh2IDQuOS40KSAtIHRhZ3MgaW5wdXQgY29tcG9uZW50XG4gKiBCeSBZYWlyIEV2ZW4tT3JcbiAqIERvbid0IHNlbGwgdGhpcyBjb2RlLiAoYylcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS95YWlyRU8vdGFnaWZ5XG4gKi9cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8vIGNvbnNvbGUuanNvbiA9IGNvbnNvbGUuanNvbiB8fCBmdW5jdGlvbihhcmd1bWVudCl7XG4vLyAgICAgZm9yKHZhciBhcmc9MDsgYXJnIDwgYXJndW1lbnRzLmxlbmd0aDsgKythcmcpXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKCAgSlNPTi5zdHJpbmdpZnkoYXJndW1lbnRzW2FyZ10sIG51bGwsIDQpICApXG4vLyB9XG4vLyBjb25zdCBpc0VkZ2UgPSAvRWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuY29uc3Qgc2FtZVN0ciA9IChzMSwgczIsIGNhc2VTZW5zaXRpdmUsIHRyaW0pID0+IHtcbiAgLy8gY2FzdCB0byBTdHJpbmdcbiAgczEgPSBcIlwiICsgczE7XG4gIHMyID0gXCJcIiArIHMyO1xuXG4gIGlmICh0cmltKSB7XG4gICAgczEgPSBzMS50cmltKCk7XG4gICAgczIgPSBzMi50cmltKCk7XG4gIH1cblxuICByZXR1cm4gY2FzZVNlbnNpdGl2ZSA/IHMxID09IHMyIDogczEudG9Mb3dlckNhc2UoKSA9PSBzMi50b0xvd2VyQ2FzZSgpO1xufTsgLy8gY29uc3QgZ2V0VUlEID0gKCkgPT4gKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSoxMDAwMCkrMSkpLnRvU3RyaW5nKDE2KVxuXG5jb25zdCByZW1vdmVDb2xsZWN0aW9uUHJvcCA9IChjb2xsZWN0aW9uLCB1bndhbnRlZFByb3BzKSA9PiBjb2xsZWN0aW9uICYmIEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikgJiYgY29sbGVjdGlvbi5tYXAodiA9PiBvbWl0KHYsIHVud2FudGVkUHJvcHMpKTtcbmZ1bmN0aW9uIG9taXQob2JqLCBwcm9wcykge1xuICB2YXIgbmV3T2JqID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBvYmopIGlmIChwcm9wcy5pbmRleE9mKHApIDwgMCkgbmV3T2JqW3BdID0gb2JqW3BdO1xuXG4gIHJldHVybiBuZXdPYmo7XG59XG5mdW5jdGlvbiBkZWNvZGUocykge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFwmIz9bMC05YS16XSs7L2dpLCBmdW5jdGlvbiAoZW5jKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gZW5jO1xuICAgIHJldHVybiBlbC5pbm5lclRleHQ7XG4gIH0pO1xufVxuLyoqXHJcbiAqIHV0aWxpdHkgbWV0aG9kXHJcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNTM4NTUxOC8xMDQzODBcclxuICogQHBhcmFtICB7U3RyaW5nfSBzIFtIVE1MIHN0cmluZ11cclxuICogQHJldHVybiB7T2JqZWN0fSAgIFtET00gbm9kZV1cclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSFRNTChzKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCksXG4gICAgICBub2RlID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzLnRyaW0oKSwgXCJ0ZXh0L2h0bWxcIik7XG4gIHJldHVybiBub2RlLmJvZHkuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG4vKipcclxuICogUmVtb3ZlZCBuZXcgbGluZXMgYW5kIGlycmVsZXZhbnQgc3BhY2VzIHdoaWNoIG1pZ2h0IGFmZmVjdCBsYXlvdXQsIGFuZCBhcmUgYmV0dGVyIGdvbmVcclxuICogQHBhcmFtIHtzdHJpbmd9IHMgW0hUTUwgc3RyaW5nXVxyXG4gKi9cblxuZnVuY3Rpb24gbWluaWZ5KHMpIHtcbiAgcmV0dXJuIHMgPyBzLnJlcGxhY2UoL1xcPltcXHJcXG4gXStcXDwvZywgXCI+PFwiKS5yZXBsYWNlKC8oPC4qPz4pfFxccysvZywgKG0sICQxKSA9PiAkMSA/ICQxIDogJyAnKSAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ4NDE0ODQvMTA0MzgwXG4gIDogXCJcIjtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRleHRDaGlsZE5vZGVzKGVsbSkge1xuICB2YXIgaXRlciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihlbG0sIE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSksXG4gICAgICB0ZXh0bm9kZTsgLy8gcHJpbnQgYWxsIHRleHQgbm9kZXNcblxuICB3aGlsZSAodGV4dG5vZGUgPSBpdGVyLm5leHROb2RlKCkpIHtcbiAgICBpZiAoIXRleHRub2RlLnRleHRDb250ZW50LnRyaW0oKSkgdGV4dG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXh0bm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldGZpcnN0VGV4dE5vZGUoZWxtLCBhY3Rpb24pIHtcbiAgYWN0aW9uID0gYWN0aW9uIHx8ICdwcmV2aW91cyc7XG5cbiAgd2hpbGUgKGVsbSA9IGVsbVthY3Rpb24gKyAnU2libGluZyddKSBpZiAoZWxtLm5vZGVUeXBlID09IDMpIHJldHVybiBlbG07XG59XG4vKipcclxuICogdXRpbGl0eSBtZXRob2RcclxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYyMzQ4MDQvMTA0MzgwXHJcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09ICdzdHJpbmcnID8gcy5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvYHwnL2csIFwiJiMwMzk7XCIpIDogcztcbn1cbi8qKlxyXG4gKiBDaGVja3MgaWYgYW4gYXJndW1lbnQgaXMgYSBqYXZhc2NyaXB0IE9iamVjdFxyXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc3BsaXQoJyAnKVsxXS5zbGljZSgwLCAtMSk7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopICYmIHR5cGUgIT0gJ0FycmF5JyAmJiB0eXBlICE9ICdGdW5jdGlvbicgJiYgdHlwZSAhPSAnUmVnRXhwJyAmJiB0eXBlICE9ICdIVE1MVW5rbm93bkVsZW1lbnQnO1xufVxuLyoqXHJcbiAqIG1lcmdlIG9iamVjdHMgaW50byBhIHNpbmdsZSBuZXcgb25lXHJcbiAqIFRFU1Q6IGV4dGVuZCh7fSwge2E6e2ZvbzoxfSwgYjpbXX0sIHthOntiYXI6Mn0sIGI6WzFdLCBjOigpPT57fX0pXHJcbiAqL1xuXG5mdW5jdGlvbiBleHRlbmQobywgbzEsIG8yKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBPYmplY3QpKSBvID0ge307XG4gIGNvcHkobywgbzEpO1xuICBpZiAobzIpIGNvcHkobywgbzIpO1xuXG4gIGZ1bmN0aW9uIGNvcHkoYSwgYikge1xuICAgIC8vIGNvcHkgbzIgdG8gb1xuICAgIGZvciAodmFyIGtleSBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBpZiAoaXNPYmplY3QoYltrZXldKSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGFba2V5XSkpIGFba2V5XSA9IE9iamVjdC5hc3NpZ24oe30sIGJba2V5XSk7ZWxzZSBjb3B5KGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJba2V5XSkpIHtcbiAgICAgICAgYVtrZXldID0gT2JqZWN0LmFzc2lnbihbXSwgYltrZXldKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbztcbn1cbi8qKlxyXG4gKiBjb25jYXRlbmF0ZXMgTiBhcnJheXMgd2l0aG91dCBkdXBzLlxyXG4gKiBJZiBhbiBhcnJheSdzIGl0ZW0gaXMgYW4gT2JqZWN0LCBjb21wYXJlIGJ5IGB2YWx1ZWBcclxuICovXG5cbmZ1bmN0aW9uIGNvbmNhdFdpdGhvdXREdXBzKCkge1xuICBjb25zdCBuZXdBcnIgPSBbXSxcbiAgICAgICAgZXhpc3RpbmdPYmogPSB7fTtcblxuICBmb3IgKGxldCBhcnIgb2YgYXJndW1lbnRzKSB7XG4gICAgZm9yIChsZXQgaXRlbSBvZiBhcnIpIHtcbiAgICAgIC8vIGlmIGN1cnJlbnQgaXRlbSBpcyBhbiBvYmplY3Qgd2hpY2ggaGFzIHlldCB0byBiZSBhZGRlZCB0byB0aGUgbmV3IGFycmF5XG4gICAgICBpZiAoaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaWYgKCFleGlzdGluZ09ialtpdGVtLnZhbHVlXSkge1xuICAgICAgICAgIG5ld0Fyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgIGV4aXN0aW5nT2JqW2l0ZW0udmFsdWVdID0gMTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiBjdXJyZW50IGl0ZW0gaXMgbm90IGFuIG9iamVjdCBhbmQgaXMgbm90IGluIHRoZSBuZXcgYXJyYXlcbiAgICAgIGVsc2UgaWYgKCFuZXdBcnIuaW5jbHVkZXMoaXRlbSkpIG5ld0Fyci5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdBcnI7XG59XG4vKipcclxuICogIEV4dHJhY3RlZCBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc1MTE0NjMvMTA0MzgwXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXHJcbiAqL1xuXG5mdW5jdGlvbiB1bmFjY2VudChzKSB7XG4gIC8vIGlmIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdCBjb250aW51ZS5cbiAgLy8gZGV2ZWxvcGVycyBzaG91bGQgdXNlIGEgcG9seWZpbGw6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93YWxsaW5nL3Vub3JtXG4gIGlmICghU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUpIHJldHVybiBzO1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSByZXR1cm4gcy5ub3JtYWxpemUoXCJORkRcIikucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIik7XG59XG4vKipcclxuICogTWVhc3N1cmVzIGFuIGVsZW1lbnQncyBoZWlnaHQsIHdoaWNoIG1pZ2h0IHlldCBoYXZlIGJlZW4gYWRkZWQgRE9NXHJcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81OTQ0MDM4LzEwNDM4MFxyXG4gKiBAcGFyYW0ge0RPTX0gbm9kZVxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Tm9kZUhlaWdodChub2RlKSB7XG4gIHZhciBoZWlnaHQsXG4gICAgICBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICBjbG9uZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjpmaXhlZDsgdG9wOi05OTk5cHg7IG9wYWNpdHk6MFwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgaGVpZ2h0ID0gY2xvbmUuY2xpZW50SGVpZ2h0O1xuICBjbG9uZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgcmV0dXJuIGhlaWdodDtcbn1cbnZhciBpc0Nocm9tZUFuZHJvaWRCcm93c2VyID0gKCkgPT4gLyg/PS4qY2hyb21lKSg/PS4qYW5kcm9pZCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZnVuY3Rpb24gZ2V0VUlEKCkge1xuICByZXR1cm4gKFsxZTddICsgLTFlMyArIC00ZTMgKyAtOGUzICsgLTFlMTEpLnJlcGxhY2UoL1swMThdL2csIGMgPT4gKGMgXiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEpKVswXSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gaXNOb2RlVGFnKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jbGFzc0xpc3QgJiYgbm9kZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZyk7XG59XG5cbnZhciBERUZBVUxUUyA9IHtcbiAgZGVsaW1pdGVyczogXCIsXCIsXG4gIC8vIFtSZWdFeF0gc3BsaXQgdGFncyBieSBhbnkgb2YgdGhlc2UgZGVsaW1pdGVycyAoXCJudWxsXCIgdG8gY2FuY2VsKSBFeGFtcGxlOiBcIix8IHwuXCJcbiAgcGF0dGVybjogbnVsbCxcbiAgLy8gUmVnRXggcGF0dGVybiB0byB2YWxpZGF0ZSBpbnB1dCBieS4gRXg6IC9bMS05XS9cbiAgdGFnVGV4dFByb3A6ICd2YWx1ZScsXG4gIC8vIHRhZyBkYXRhIE9iamVjdCBwcm9wZXJ0eSB3aGljaCB3aWxsIGJlIGRpc3BsYXllZCBhcyB0aGUgdGFnJ3MgdGV4dFxuICBtYXhUYWdzOiBJbmZpbml0eSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgdGFnc1xuICBjYWxsYmFja3M6IHt9LFxuICAvLyBFeHBvc2VkIGNhbGxiYWNrcyBvYmplY3QgdG8gYmUgdHJpZ2dlcmVkIG9uIGNlcnRhaW4gZXZlbnRzXG4gIGFkZFRhZ09uQmx1cjogdHJ1ZSxcbiAgLy8gRmxhZyAtIGF1dG9tYXRpY2FsbHkgYWRkcyB0aGUgdGV4dCB3aGljaCB3YXMgaW5wdXRlZCBhcyBhIHRhZyB3aGVuIGJsdXIgZXZlbnQgaGFwcGVuc1xuICBkdXBsaWNhdGVzOiBmYWxzZSxcbiAgLy8gRmxhZyAtIGFsbG93IHR1cGxpY2F0ZSB0YWdzXG4gIHdoaXRlbGlzdDogW10sXG4gIC8vIEFycmF5IG9mIHRhZ3MgdG8gc3VnZ2VzdCBhcyB0aGUgdXNlciB0eXBlcyAoY2FuIGJlIHVzZWQgYWxvbmcgd2l0aCBcImVuZm9yY2VXaGl0ZWxpc3RcIiBzZXR0aW5nKVxuICBibGFja2xpc3Q6IFtdLFxuICAvLyBBIGxpc3Qgb2Ygbm9uLWFsbG93ZWQgdGFnc1xuICBlbmZvcmNlV2hpdGVsaXN0OiBmYWxzZSxcbiAgLy8gRmxhZyAtIE9ubHkgYWxsb3cgdGFncyBmcm9tIHRoZSB3aGl0ZWxpc3RcbiAgdXNlcklucHV0OiB0cnVlLFxuICAvLyBGbGFnIC0gZGlzYWJsZSBtYW51YWxseSB0eXBpbmcvcGFzdGluZy9lZGl0aW5nIHRhZ3MgKHRhZ3MgbWF5IG9ubHkgYmUgYWRkZWQgZnJvbSB0aGUgd2hpdGVsaXN0KVxuICBrZWVwSW52YWxpZFRhZ3M6IGZhbHNlLFxuICAvLyBGbGFnIC0gaWYgdHJ1ZSwgZG8gbm90IHJlbW92ZSB0YWdzIHdoaWNoIGRpZCBub3QgcGFzcyB2YWxpZGF0aW9uXG4gIG1peFRhZ3NBbGxvd2VkQWZ0ZXI6IC8sfFxcLnxcXDp8XFxzLyxcbiAgLy8gUmVnRXggLSBEZWZpbmUgY29uZGl0aW9ucyBpbiB3aGljaCBtaXgtdGFncyBjb250ZW50IGFsbG93cyBhIHRhZyB0byBiZSBhZGRlZCBhZnRlclxuICBtaXhUYWdzSW50ZXJwb2xhdG9yOiBbJ1tbJywgJ11dJ10sXG4gIC8vIEludGVycG9sYXRpb24gZm9yIG1peCBtb2RlLiBFdmVyeXRoaW5nIGJldHdlZW4gdGhpcyB3aWxsIGJlY21vZSBhIHRhZ1xuICBiYWNrc3BhY2U6IHRydWUsXG4gIC8vIGZhbHNlIC8gdHJ1ZSAvIFwiZWRpdFwiXG4gIHNraXBJbnZhbGlkOiBmYWxzZSxcbiAgLy8gSWYgYHRydWVgLCBkbyBub3QgYWRkIGludmFsaWQsIHRlbXBvcmFyeSwgdGFncyBiZWZvcmUgYXV0b21hdGljYWxseSByZW1vdmluZyB0aGVtXG4gIHBhc3RlQXNUYWdzOiB0cnVlLFxuICAvLyBhdXRvbWF0aWNhbGx5IGNvbnZlcnRzIHBhc3RlZCB0ZXh0IGludG8gdGFncy4gaWYgXCJmYWxzZVwiLCBhbGxvd3MgZm9yIGZ1cnRoZXIgdGV4dCBlZGl0aW5nXG4gIGVkaXRUYWdzOiB7XG4gICAgY2xpY2tzOiAyLFxuICAgIC8vIGNsaWNrcyB0byBlbnRlciBcImVkaXQtbW9kZVwiOiAxIGZvciBzaW5nbGUgY2xpY2suIGFueSBvdGhlciB2YWx1ZSBpcyBjb25zaWRlcmVkIGFzIGRvdWJsZS1jbGlja1xuICAgIGtlZXBJbnZhbGlkOiB0cnVlIC8vIGtlZXBzIGludmFsaWQgZWRpdHMgYXMtaXMgdW50aWwgYGVzY2AgaXMgcHJlc3NlZCB3aGlsZSBpbiBmb2N1c1xuXG4gIH0sXG4gIC8vIDEgb3IgMiBjbGlja3MgdG8gZWRpdCBhIHRhZy4gZmFsc2UvbnVsbCBmb3Igbm90IGFsbG93aW5nIGVkaXRpbmdcbiAgdHJhbnNmb3JtVGFnOiAoKSA9PiB7fSxcbiAgLy8gVGFrZXMgYSB0YWcgaW5wdXQgc3RyaW5nIGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zIGEgdHJhbnNmb3JtZWQgdmFsdWVcbiAgdHJpbTogdHJ1ZSxcbiAgLy8gd2hldGhlciBvciBub3QgdGhlIHZhbHVlIHByb3ZpZGVkIHNob3VsZCBiZSB0cmltbWVkLCBiZWZvcmUgYmVpbmcgYWRkZWQgYXMgYSB0YWdcbiAgYTExeToge1xuICAgIGZvY3VzYWJsZVRhZ3M6IGZhbHNlXG4gIH0sXG4gIG1peE1vZGU6IHtcbiAgICBpbnNlcnRBZnRlclRhZzogJ1xcdTAwQTAnIC8vIFN0cmluZy9Ob2RlIHRvIGluamVjdCBhZnRlciBhIHRhZyBoYXMgYmVlbiBhZGRlZCAoc2VlICM1ODgpXG5cbiAgfSxcbiAgYXV0b0NvbXBsZXRlOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBUcmllcyB0byBzdWdnZXN0IHRoZSBpbnB1dCdzIHZhbHVlIHdoaWxlIHR5cGluZyAobWF0Y2ggZnJvbSB3aGl0ZWxpc3QpIGJ5IGFkZGluZyB0aGUgcmVzdCBvZiB0ZXJtIGFzIGdyYXllZC1vdXQgdGV4dFxuICAgIHJpZ2h0S2V5OiBmYWxzZSAvLyBJZiBgdHJ1ZWAsIHdoZW4gUmlnaHQga2V5IGlzIHByZXNzZWQsIHVzZSB0aGUgc3VnZ2VzdGVkIHZhbHVlIHRvIGNyZWF0ZSBhIHRhZywgZWxzZSBqdXN0IGF1dG8tY29tcGxldGVzIHRoZSBpbnB1dC4gaW4gbWl4ZWQtbW9kZSB0aGlzIGlzIHNldCB0byBcInRydWVcIlxuXG4gIH0sXG4gIGNsYXNzTmFtZXM6IHtcbiAgICBuYW1lc3BhY2U6ICd0YWdpZnknLFxuICAgIG1peE1vZGU6ICd0YWdpZnktLW1peCcsXG4gICAgc2VsZWN0TW9kZTogJ3RhZ2lmeS0tc2VsZWN0JyxcbiAgICBpbnB1dDogJ3RhZ2lmeV9faW5wdXQnLFxuICAgIGZvY3VzOiAndGFnaWZ5LS1mb2N1cycsXG4gICAgdGFnOiAndGFnaWZ5X190YWcnLFxuICAgIHRhZ05vQW5pbWF0aW9uOiAndGFnaWZ5LS1ub0FuaW0nLFxuICAgIHRhZ0ludmFsaWQ6ICd0YWdpZnktLWludmFsaWQnLFxuICAgIHRhZ05vdEFsbG93ZWQ6ICd0YWdpZnktLW5vdEFsbG93ZWQnLFxuICAgIGlucHV0SW52YWxpZDogJ3RhZ2lmeV9faW5wdXQtLWludmFsaWQnLFxuICAgIHRhZ1g6ICd0YWdpZnlfX3RhZ19fcmVtb3ZlQnRuJyxcbiAgICB0YWdUZXh0OiAndGFnaWZ5X190YWctdGV4dCcsXG4gICAgZHJvcGRvd246ICd0YWdpZnlfX2Ryb3Bkb3duJyxcbiAgICBkcm9wZG93bldyYXBwZXI6ICd0YWdpZnlfX2Ryb3Bkb3duX193cmFwcGVyJyxcbiAgICBkcm9wZG93bkl0ZW06ICd0YWdpZnlfX2Ryb3Bkb3duX19pdGVtJyxcbiAgICBkcm9wZG93bkl0ZW1BY3RpdmU6ICd0YWdpZnlfX2Ryb3Bkb3duX19pdGVtLS1hY3RpdmUnLFxuICAgIGRyb3Bkb3duSW5pdGFsOiAndGFnaWZ5X19kcm9wZG93bi0taW5pdGlhbCcsXG4gICAgc2NvcGVMb2FkaW5nOiAndGFnaWZ5LS1sb2FkaW5nJyxcbiAgICB0YWdMb2FkaW5nOiAndGFnaWZ5X190YWctLWxvYWRpbmcnLFxuICAgIHRhZ0VkaXRpbmc6ICd0YWdpZnlfX3RhZy0tZWRpdGFibGUnLFxuICAgIHRhZ0ZsYXNoOiAndGFnaWZ5X190YWctLWZsYXNoJyxcbiAgICB0YWdIaWRlOiAndGFnaWZ5X190YWctLWhpZGUnLFxuICAgIGhhc01heFRhZ3M6ICd0YWdpZnktLWhhc01heFRhZ3MnLFxuICAgIGhhc05vVGFnczogJ3RhZ2lmeS0tbm9UYWdzJyxcbiAgICBlbXB0eTogJ3RhZ2lmeS0tZW1wdHknXG4gIH0sXG4gIGRyb3Bkb3duOiB7XG4gICAgY2xhc3NuYW1lOiAnJyxcbiAgICBlbmFibGVkOiAyLFxuICAgIC8vIG1pbmltdW0gaW5wdXQgY2hhcmFjdGVycyB0byBiZSB0eXBlZCBmb3IgdGhlIHN1Z2dlc3Rpb25zIGRyb3Bkb3duIHRvIHNob3dcbiAgICBtYXhJdGVtczogMTAsXG4gICAgc2VhcmNoS2V5czogW1widmFsdWVcIiwgXCJzZWFyY2hCeVwiXSxcbiAgICBmdXp6eVNlYXJjaDogdHJ1ZSxcbiAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICBhY2NlbnRlZFNlYXJjaDogdHJ1ZSxcbiAgICBoaWdobGlnaHRGaXJzdDogZmFsc2UsXG4gICAgLy8gaGlnaGxpZ2h0cyBmaXJzdC1tYXRjaGVkIGl0ZW0gaW4gdGhlIGxpc3RcbiAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgIC8vIGNsb3NlcyB0aGUgZHJvcGRvd24gYWZ0ZXIgc2VsZWN0aW5nIGFuIGl0ZW0sIGlmIGBlbmFibGVkOjBgICh3aGljaCBtZWFucyBhbHdheXMgc2hvdyBkcm9wZG93bilcbiAgICBjbGVhck9uU2VsZWN0OiB0cnVlLFxuICAgIC8vIGFmdGVyIHNlbGVjdGluZyBhIHN1Z2dldGlvbiwgc2hvdWxkIHRoZSB0eXBlZCB0ZXh0IGlucHV0IHJlbWFpbiBvciBiZSBjbGVhcmVkXG4gICAgcG9zaXRpb246ICdhbGwnLFxuICAgIC8vICdtYW51YWwnIC8gJ3RleHQnIC8gJ2FsbCdcbiAgICBhcHBlbmRUYXJnZXQ6IG51bGwgLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnQuYm9keSBvbmUgRE9NIGhhcyBiZWVuIGxvYWRlZFxuXG4gIH0sXG4gIGhvb2tzOiB7XG4gICAgYmVmb3JlUmVtb3ZlVGFnOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICBiZWZvcmVQYXN0ZTogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgc3VnZ2VzdGlvbkNsaWNrOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbml0RHJvcGRvd24oKSB7XG4gIHRoaXMuZHJvcGRvd24gPSB7fTtcblxuICBmb3IgKGxldCBwIGluIHRoaXMuX2Ryb3Bkb3duKSB0aGlzLmRyb3Bkb3duW3BdID0gdHlwZW9mIHRoaXMuX2Ryb3Bkb3duW3BdID09PSAnZnVuY3Rpb24nID8gdGhpcy5fZHJvcGRvd25bcF0uYmluZCh0aGlzKSA6IHRoaXMuX2Ryb3Bkb3duW3BdO1xuXG4gIGlmICh0aGlzLnNldHRpbmdzLmRyb3Bkb3duLmVuYWJsZWQgPj0gMCkgdGhpcy5kcm9wZG93bi5pbml0KCk7XG59XG52YXIgX2Ryb3Bkb3duID0ge1xuICBpbml0KCkge1xuICAgIHRoaXMuRE9NLmRyb3Bkb3duID0gdGhpcy5wYXJzZVRlbXBsYXRlKCdkcm9wZG93bicsIFt0aGlzLnNldHRpbmdzXSk7XG4gICAgdGhpcy5ET00uZHJvcGRvd24uY29udGVudCA9IHRoaXMuRE9NLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IodGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLmRyb3Bkb3duV3JhcHBlclNlbGVjdG9yKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBzaG93cyB0aGUgc3VnZ2VzdGlvbnMgc2VsZWN0IGJveFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBbb3B0aW9uYWwsIGZpbHRlciB0aGUgd2hpdGVsaXN0IGJ5IHRoaXMgdmFsdWVdXHJcbiAgICovXG4gIHNob3codmFsdWUpIHtcbiAgICB2YXIgX3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICBmaXJzdExpc3RJdGVtLFxuICAgICAgICBmaXJzdExpc3RJdGVtVmFsdWUsXG4gICAgICAgIGFsbG93TmV3VGFncyA9IF9zLm1vZGUgPT0gJ21peCcgJiYgIV9zLmVuZm9yY2VXaGl0ZWxpc3QsXG4gICAgICAgIG5vV2hpdGVsaXN0ID0gIV9zLndoaXRlbGlzdCB8fCAhX3Mud2hpdGVsaXN0Lmxlbmd0aCxcbiAgICAgICAgbm9NYXRjaExpc3RJdGVtLFxuICAgICAgICBpc01hbnVhbCA9IF9zLmRyb3Bkb3duLnBvc2l0aW9uID09ICdtYW51YWwnOyAvLyBpZiB0ZXh0IHN0aWxsIGV4aXN0cyBpbiB0aGUgaW5wdXQsIGFuZCBgc2hvd2AgbWV0aG9kIGhhcyBubyBhcmd1bWVudCwgdGhlbiB0aGUgaW5wdXQncyB0ZXh0IHNob3VsZCBiZSB1c2VkXG5cbiAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLnN0YXRlLmlucHV0VGV4dCA6IHZhbHVlOyAvLyDimqDvuI8gRG8gbm90IHJlbmRlciBzdWdnZXN0aW9ucyBsaXN0ICBpZjpcbiAgICAvLyAxLiB0aGVyZSdzIG5vIHdoaXRlbGlzdCAoY2FuIGhhcHBlbiB3aGlsZSBhc3luYyBsb2FkaW5nKSBBTkQgbmV3IHRhZ3MgYXJuJ3QgYWxsb3dlZFxuICAgIC8vIDIuIGRyb3Bkb3duIGlzIGRpc2FibGVkXG4gICAgLy8gMy4gbG9hZGVyIGlzIHNob3dpbmcgKGNvbnRyb2xsZWQgb3V0c2lkZSBvZiB0aGlzIGNvZGUpXG5cbiAgICBpZiAobm9XaGl0ZWxpc3QgJiYgIWFsbG93TmV3VGFncyAmJiAhX3MudGVtcGxhdGVzLmRyb3Bkb3duSXRlbU5vTWF0Y2ggfHwgX3MuZHJvcGRvd24uZW5hYmxlID09PSBmYWxzZSB8fCB0aGlzLnN0YXRlLmlzTG9hZGluZykgcmV0dXJuO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmRyb3Bkb3duSGlkZV9fYmluZEV2ZW50c1RpbWVvdXQpOyAvLyBpZiBubyB2YWx1ZSB3YXMgc3VwcGxpZWQsIHNob3cgYWxsIHRoZSBcIndoaXRlbGlzdFwiIGl0ZW1zIGluIHRoZSBkcm9wZG93blxuICAgIC8vIEB0eXBlIFtBcnJheV0gbGlzdEl0ZW1zXG4gICAgLy8gVE9ETzogYWRkIGEgU2V0dGluZyB0byBjb250cm9sIGl0ZW1zJyBzb3J0IG9yZGVyIGZvciBcImxpc3RJdGVtc1wiXG5cbiAgICB0aGlzLnN1Z2dlc3RlZExpc3RJdGVtcyA9IHRoaXMuZHJvcGRvd24uZmlsdGVyTGlzdEl0ZW1zKHZhbHVlKTsgLy8gdHJpZ2dlciBhdCB0aGlzIGV4YWN0IHBvaW50IHRvIGxldCB0aGUgZGV2ZWxvcGVyIHRoZSBjaGFuY2UgdG8gbWFudWFsbHkgc2V0IFwidGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXNcIlxuXG4gICAgaWYgKHZhbHVlICYmICF0aGlzLnN1Z2dlc3RlZExpc3RJdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZHJvcGRvd246bm9NYXRjaCcsIHZhbHVlKTtcbiAgICAgIGlmIChfcy50ZW1wbGF0ZXMuZHJvcGRvd25JdGVtTm9NYXRjaCkgbm9NYXRjaExpc3RJdGVtID0gX3MudGVtcGxhdGVzLmRyb3Bkb3duSXRlbU5vTWF0Y2guY2FsbCh0aGlzLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9IC8vIGlmIFwiZHJvcGRvd25JdGVtTm9NYXRjaFwiIHdhcyBubyBkZWZpbmVkLCBwcm9jY2VlZCByZWd1bGFyIGZsb3cuXG4gICAgLy9cblxuXG4gICAgaWYgKCFub01hdGNoTGlzdEl0ZW0pIHtcbiAgICAgIC8vIGluIG1peC1tb2RlLCBpZiB0aGUgdmFsdWUgaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHdoaWxlbGlzdCAmIFwiZW5mb3JjZVdoaXRlbGlzdFwiIHNldHRpbmcgaXMgXCJmYWxzZVwiLFxuICAgICAgLy8gdGhlbiBhZGQgYSBjdXN0b20gc3VnZ2VzdGlvbiBpdGVtIHRvIHRoZSBkcm9wZG93blxuICAgICAgaWYgKHRoaXMuc3VnZ2VzdGVkTGlzdEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBpZiAodmFsdWUgJiYgYWxsb3dOZXdUYWdzICYmICF0aGlzLnN0YXRlLmVkaXRpbmcuc2NvcGUgJiYgIXNhbWVTdHIodGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXNbMF0udmFsdWUsIHZhbHVlKSkgdGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXMudW5zaGlmdCh7XG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgJiYgYWxsb3dOZXdUYWdzICYmICF0aGlzLnN0YXRlLmVkaXRpbmcuc2NvcGUpIHtcbiAgICAgICAgICB0aGlzLnN1Z2dlc3RlZExpc3RJdGVtcyA9IFt7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH1dO1xuICAgICAgICB9IC8vIGhpZGUgc3VnZ2VzdGlvbnMgbGlzdCBpZiBubyBzdWdnZXN0aW9uIG1hdGNoZWRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbnB1dC5hdXRvY29tcGxldGUuc3VnZ2VzdC5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaXJzdExpc3RJdGVtID0gdGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXNbMF07XG4gICAgICBmaXJzdExpc3RJdGVtVmFsdWUgPSBcIlwiICsgKGlzT2JqZWN0KGZpcnN0TGlzdEl0ZW0pID8gZmlyc3RMaXN0SXRlbS52YWx1ZSA6IGZpcnN0TGlzdEl0ZW0pO1xuXG4gICAgICBpZiAoX3MuYXV0b0NvbXBsZXRlICYmIGZpcnN0TGlzdEl0ZW1WYWx1ZSkge1xuICAgICAgICAvLyBvbmx5IGZpbGwgdGhlIHN1Z2Vnc3Rpb24gaWYgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0gU1RBUlRTIHdpdGggdGhlIGlucHV0IHZhbHVlIChyZWdhcmRsZXNzIG9mIFwiZnV6enlzZWFyY2hcIiBzZXR0aW5nKVxuICAgICAgICBpZiAoZmlyc3RMaXN0SXRlbVZhbHVlLmluZGV4T2YodmFsdWUpID09IDApIHRoaXMuaW5wdXQuYXV0b2NvbXBsZXRlLnN1Z2dlc3QuY2FsbCh0aGlzLCBmaXJzdExpc3RJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRyb3Bkb3duLmZpbGwobm9NYXRjaExpc3RJdGVtKTtcbiAgICBpZiAoX3MuZHJvcGRvd24uaGlnaGxpZ2h0Rmlyc3QpIHRoaXMuZHJvcGRvd24uaGlnaGxpZ2h0T3B0aW9uKHRoaXMuRE9NLmRyb3Bkb3duLmNvbnRlbnQuY2hpbGRyZW5bMF0pOyAvLyBiaW5kIGV2ZW50cywgZXhhY3RseSBhdCB0aGlzIHN0YWdlIG9mIHRoZSBjb2RlLiBcImRyb3Bkb3duLnNob3dcIiBtZXRob2QgaXMgYWxsb3dlZCB0byBiZVxuICAgIC8vIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgcmVnYXJkbGVzcyBpZiB0aGUgZHJvcGRvd24gaXMgY3VycmVudGx5IHZpc2libGUsIGJ1dCB0aGUgZXZlbnRzLWJpbmRpbmdcbiAgICAvLyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIGRyb3Bkb3duIHdhc24ndCBwcmV2aW91c2x5IHZpc2libGUuXG5cbiAgICBpZiAoIXRoaXMuc3RhdGUuZHJvcGRvd24udmlzaWJsZSkgLy8gdGltZW91dCBpcyBuZWVkZWQgZm9yIHdoZW4gcHJlc3NpbmcgYXJyb3cgZG93biB0byBzaG93IHRoZSBkcm9wZG93bixcbiAgICAgIC8vIHNvIHRoZSBrZXkgZXZlbnQgd29uJ3QgZ2V0IHJlZ2lzdGVyZWQgaW4gdGhlIGRyb3Bkb3duIGV2ZW50cyBsaXN0ZW5lcnNcbiAgICAgIHNldFRpbWVvdXQodGhpcy5kcm9wZG93bi5ldmVudHMuYmluZGluZy5iaW5kKHRoaXMpKTsgLy8gc2V0IHRoZSBkcm9wZG93biB2aXNpYmxlIHN0YXRlIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBzZWFyY2hlZCB2YWx1ZS5cbiAgICAvLyBNVVNUIGJlIHNldCAqYmVmb3JlKiBwb3NpdGlvbigpIGlzIGNhbGxlZFxuXG4gICAgdGhpcy5zdGF0ZS5kcm9wZG93bi52aXNpYmxlID0gdmFsdWUgfHwgdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmRyb3Bkb3duLnF1ZXJ5ID0gdmFsdWU7XG4gICAgdGhpcy5zZXRTdGF0ZVNlbGVjdGlvbigpOyAvLyB0cnkgdG8gcG9zaXRpb25pbmcgdGhlIGRyb3Bkb3duIChpdCBtaWdodCBub3QgeWV0IGJlIG9uIHRoZSBwYWdlLCBkb2Vzbid0IG1hdHRlciwgbmV4dCBjb2RlIGhhbmRsZXMgdGhpcylcblxuICAgIGlmICghaXNNYW51YWwpIHtcbiAgICAgIC8vIGEgc2xpZ2h0IGRlbGF5IGlzIG5lZWRlZCBpZiB0aGUgZHJvcGRvd24gXCJwb3NpdGlvblwiIHNldHRpbmcgaXMgXCJ0ZXh0XCIsIGFuZCBub3RoaW5nIHdhcyB0eXBlZCBpbiB0aGUgaW5wdXQsXG4gICAgICAvLyBzbyBzYWRseSB0aGUgXCJnZXRDYXJldEdsb2JhbFBvc2l0aW9uXCIgbWV0aG9kIGRvZXNuJ3QgcmVjb2duaXplIHRoZSBjYXJldCBwb3NpdGlvbiB3aXRob3V0IHRoaXMgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmRyb3Bkb3duLnBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24ucmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICB9IC8vIGEgZGVsYXkgaXMgbmVlZGVkIGJlY2F1c2Ugb2YgdGhlIHByZXZpb3VzIGRlbGF5IHJlYXNvbi5cbiAgICAvLyB0aGlzIGV2ZW50IG11c3QgYmUgZmlyZWQgYWZ0ZXIgdGhlIGRyb3Bkb3duIHdhcyByZW5kZXJlZCAmIHBvc2l0aW9uZWRcblxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJkcm9wZG93bjpzaG93XCIsIHRoaXMuRE9NLmRyb3Bkb3duKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBIaWRlcyB0aGUgZHJvcGRvd24gKGlmIGl0J3Mgbm90IG1hbmFnZWQgbWFudWFsbHkgYnkgdGhlIGRldmVsb3BlcilcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG92ZXJyaWRlTWFudWFsXHJcbiAgICovXG4gIGhpZGUob3ZlcnJpZGVNYW51YWwpIHtcbiAgICB2YXIgX3RoaXMkRE9NID0gdGhpcy5ET00sXG4gICAgICAgIHNjb3BlID0gX3RoaXMkRE9NLnNjb3BlLFxuICAgICAgICBkcm9wZG93biA9IF90aGlzJERPTS5kcm9wZG93bixcbiAgICAgICAgaXNNYW51YWwgPSB0aGlzLnNldHRpbmdzLmRyb3Bkb3duLnBvc2l0aW9uID09ICdtYW51YWwnICYmICFvdmVycmlkZU1hbnVhbDsgLy8gaWYgdGhlcmUncyBubyBkcm9wZG93biwgdGhpcyBtZWFucyB0aGUgZHJvcGRvd24gZXZlbnRzIGFyZW4ndCBiaW5kZWRcblxuICAgIGlmICghZHJvcGRvd24gfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZHJvcGRvd24pIHx8IGlzTWFudWFsKSByZXR1cm47XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuZHJvcGRvd24ucG9zaXRpb24pO1xuICAgIHRoaXMuZHJvcGRvd24uZXZlbnRzLmJpbmRpbmcuY2FsbCh0aGlzLCBmYWxzZSk7IC8vIHVuYmluZCBhbGwgZXZlbnRzXG4gICAgLy8gaWYgdGhlIGRyb3Bkb3duIGlzIG9wZW4sIGFuZCB0aGUgaW5wdXQgKHNjb3BlKSBpcyBjbGlja2VkLFxuICAgIC8vIHRoZSBkcm9wZG93biBzaG91bGQgYmUgbm93IFwiY2xvc2VcIiwgYW5kIHRoZSBuZXh0IGNsaWNrIChvbiB0aGUgc2NvcGUpXG4gICAgLy8gc2hvdWxkIHJlLW9wZW4gaXQsIGFuZCB3aXRob3V0IGEgdGltZW91dCwgY2xpY2tpbmcgdG8gY2xvc2Ugd2lsbCByZS1vcGVuIGltbWVkaWF0ZWx5XG4gICAgLy8gIGNsZWFyVGltZW91dCh0aGlzLmRyb3Bkb3duSGlkZV9fYmluZEV2ZW50c1RpbWVvdXQpXG4gICAgLy8gIHRoaXMuZHJvcGRvd25IaWRlX19iaW5kRXZlbnRzVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5ldmVudHMuYmluZGluZy5iaW5kKHRoaXMpLCAyNTApICAvLyByZS1iaW5kIG1haW4gZXZlbnRzXG5cbiAgICBzY29wZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIGZhbHNlKTtcbiAgICBkcm9wZG93bi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyb3Bkb3duKTsgLy8gc2NlbmFyaW86IGNsaWNraW5nIHRoZSBzY29wZSB0byBzaG93IHRoZSBkcm9wZG93biwgY2xpY2tpbmcgYWdhaW4gdG8gaGlkZSAtPiBjYWxscyBkcm9wZG93bi5oaWRlKCkgYW5kIHRoZW4gcmUtZm9jdXNlcyB0aGUgaW5wdXRcbiAgICAvLyB3aGljaCBjYXN1ZXMgYW5vdGhlciBvbkZvY3VzIGV2ZW50LCB3aGljaCBjaGVja2VkIFwidGhpcy5zdGF0ZS5kcm9wZG93bi52aXNpYmxlXCIgYW5kIHNlZSBpdCBhcyBcImZhbHNlXCIgYW5kIHJlLW9wZW4gdGhlIGRyb3Bkb3duXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUuZHJvcGRvd24udmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sIDEwMCk7XG4gICAgdGhpcy5zdGF0ZS5kcm9wZG93bi5xdWVyeSA9IHRoaXMuc3RhdGUuZGRJdGVtRGF0YSA9IHRoaXMuc3RhdGUuZGRJdGVtRWxtID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBudWxsOyAvLyBpZiB0aGUgdXNlciBjbG9zZWQgdGhlIGRyb3Bkb3duIChpbiBtaXgtbW9kZSkgd2hpbGUgYSBwb3RlbnRpYWwgdGFnIHdhcyBkZXRlY3RlZCwgZmxhZyB0aGUgY3VycmVudCB0YWdcbiAgICAvLyBzbyB0aGUgZHJvcGRvd24gd29uJ3QgYmUgc2hvd24gb24gZm9sbG93aW5nIHVzZXIgaW5wdXQgZm9yIHRoYXQgXCJ0YWdcIlxuXG4gICAgaWYgKHRoaXMuc3RhdGUudGFnICYmIHRoaXMuc3RhdGUudGFnLnZhbHVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5zdGF0ZS5mbGFnZ2VkVGFnc1t0aGlzLnN0YXRlLnRhZy5iYXNlT2Zmc2V0XSA9IHRoaXMuc3RhdGUudGFnO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcihcImRyb3Bkb3duOmhpZGVcIiwgZHJvcGRvd24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRvZ2dsZXMgZHJvcGRvd24gc2hvdy9oaWRlXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93IGZvcmNlcyB0aGUgZHJvcGRvd24gdG8gc2hvd1xyXG4gICAqL1xuICB0b2dnbGUoc2hvdykge1xuICAgIHRoaXMuZHJvcGRvd25bdGhpcy5zdGF0ZS5kcm9wZG93bi52aXNpYmxlICYmICFzaG93ID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuICB9LFxuXG4gIHJlbmRlcigpIHtcbiAgICAvLyBsZXQgdGhlIGVsZW1lbnQgcmVuZGVyIGluIHRoZSBET00gZmlyc3QsIHRvIGFjY3VyYXRlbHkgbWVhc3VyZSBpdC5cbiAgICAvLyB0aGlzLkRPTS5kcm9wZG93bi5zdHlsZS5jc3NUZXh0ID0gXCJsZWZ0Oi05OTk5cHg7IHRvcDotOTk5OXB4O1wiO1xuICAgIHZhciBkZEhlaWdodCA9IGdldE5vZGVIZWlnaHQodGhpcy5ET00uZHJvcGRvd24pLFxuICAgICAgICBfcyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgdGhpcy5ET00uc2NvcGUuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCB0cnVlKTsgLy8gaWYgdGhlIGRyb3Bkb3duIGhhcyB5ZXQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIERPTSxcbiAgICAvLyBhcHBlbmQgdGhlIGRyb3Bkb3duIHRvIHRoZSBib2R5IGVsZW1lbnQgJiBoYW5kbGUgZXZlbnRzXG5cbiAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5ET00uZHJvcGRvd24pKSB7XG4gICAgICB0aGlzLkRPTS5kcm9wZG93bi5jbGFzc0xpc3QuYWRkKF9zLmNsYXNzTmFtZXMuZHJvcGRvd25Jbml0YWwpO1xuICAgICAgdGhpcy5kcm9wZG93bi5wb3NpdGlvbihkZEhlaWdodCk7XG5cbiAgICAgIF9zLmRyb3Bkb3duLmFwcGVuZFRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLkRPTS5kcm9wZG93bik7XG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ET00uZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZShfcy5jbGFzc05hbWVzLmRyb3Bkb3duSW5pdGFsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZy9BcnJheX0gSFRNTENvbnRlbnQgLSBvcHRpb25hbFxyXG4gICAqL1xuICBmaWxsKEhUTUxDb250ZW50KSB7XG4gICAgSFRNTENvbnRlbnQgPSB0eXBlb2YgSFRNTENvbnRlbnQgPT0gJ3N0cmluZycgPyBIVE1MQ29udGVudCA6IHRoaXMuZHJvcGRvd24uY3JlYXRlTGlzdEhUTUwoSFRNTENvbnRlbnQgfHwgdGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXMpO1xuICAgIHRoaXMuRE9NLmRyb3Bkb3duLmNvbnRlbnQuaW5uZXJIVE1MID0gbWluaWZ5KEhUTUxDb250ZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBmaWxsIGRhdGEgaW50byB0aGUgc3VnZ2VzdGlvbnMgbGlzdFxyXG4gICAqIChtYWlubHkgdXNlZCB0byB1cGRhdGUgdGhlIGxpc3Qgd2hlbiByZW1vdmluZyB0YWdzLCBzbyB0aGV5IHdpbGwgYmUgcmUtYWRkZWQgdG8gdGhlIGxpc3QuIG5vdCBlZmZpY2llbnQpXHJcbiAgICovXG4gIHJlZmlsdGVyKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSB8fCB0aGlzLnN0YXRlLmRyb3Bkb3duLnF1ZXJ5IHx8ICcnO1xuICAgIHRoaXMuc3VnZ2VzdGVkTGlzdEl0ZW1zID0gdGhpcy5kcm9wZG93bi5maWx0ZXJMaXN0SXRlbXModmFsdWUpO1xuICAgIHRoaXMuZHJvcGRvd24uZmlsbCgpO1xuICAgIGlmICghdGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXMubGVuZ3RoKSB0aGlzLmRyb3Bkb3duLmhpZGUoKTtcbiAgICB0aGlzLnRyaWdnZXIoXCJkcm9wZG93bjp1cGRhdGVkXCIsIHRoaXMuRE9NLmRyb3Bkb3duKTtcbiAgfSxcblxuICBwb3NpdGlvbihkZEhlaWdodCkge1xuICAgIHZhciBfc2QgPSB0aGlzLnNldHRpbmdzLmRyb3Bkb3duO1xuICAgIGlmIChfc2QucG9zaXRpb24gPT0gJ21hbnVhbCcpIHJldHVybjtcbiAgICB2YXIgcmVjdCxcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b20sXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBwYXJlbnRzUG9zaXRpb25zLFxuICAgICAgICBkZEVsbSA9IHRoaXMuRE9NLmRyb3Bkb3duLFxuICAgICAgICBwbGFjZUFib3ZlID0gX3NkLnBsYWNlQWJvdmUsXG4gICAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgdmlld3BvcnRXaWR0aCA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKSxcbiAgICAgICAgcG9zaXRpb25UbyA9IHZpZXdwb3J0V2lkdGggPiA0ODAgPyBfc2QucG9zaXRpb24gOiAnYWxsJyxcbiAgICAgICAgZGRUYXJnZXQgPSB0aGlzLkRPTVtwb3NpdGlvblRvID09ICdpbnB1dCcgPyAnaW5wdXQnIDogJ3Njb3BlJ107XG4gICAgZGRIZWlnaHQgPSBkZEhlaWdodCB8fCBkZEVsbS5jbGllbnRIZWlnaHQ7XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJlbnRzUG9zaXRpb25zKHApIHtcbiAgICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgICB0b3AgPSAwO1xuXG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBsZWZ0ICs9IHAub2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICB0b3AgKz0gcC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgcCA9IHAucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGF0ZS5kcm9wZG93bi52aXNpYmxlKSByZXR1cm47XG5cbiAgICBpZiAocG9zaXRpb25UbyA9PSAndGV4dCcpIHtcbiAgICAgIHJlY3QgPSB0aGlzLmdldENhcmV0R2xvYmFsUG9zaXRpb24oKTtcbiAgICAgIGJvdHRvbSA9IHJlY3QuYm90dG9tO1xuICAgICAgdG9wID0gcmVjdC50b3A7XG4gICAgICBsZWZ0ID0gcmVjdC5sZWZ0O1xuICAgICAgd2lkdGggPSAnYXV0byc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudHNQb3NpdGlvbnMgPSBnZXRQYXJlbnRzUG9zaXRpb25zKHRoaXMuc2V0dGluZ3MuZHJvcGRvd24uYXBwZW5kVGFyZ2V0KTtcbiAgICAgIHJlY3QgPSBkZFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRvcCA9IHJlY3QudG9wIC0gcGFyZW50c1Bvc2l0aW9ucy50b3A7XG4gICAgICBib3R0b20gPSByZWN0LmJvdHRvbSAtIDEgLSBwYXJlbnRzUG9zaXRpb25zLnRvcDtcbiAgICAgIGxlZnQgPSByZWN0LmxlZnQgLSBwYXJlbnRzUG9zaXRpb25zLmxlZnQ7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggKyAncHgnO1xuICAgIH1cblxuICAgIHRvcCA9IE1hdGguZmxvb3IodG9wKTtcbiAgICBib3R0b20gPSBNYXRoLmNlaWwoYm90dG9tKTtcbiAgICBwbGFjZUFib3ZlID0gcGxhY2VBYm92ZSA9PT0gdW5kZWZpbmVkID8gdmlld3BvcnRIZWlnaHQgLSByZWN0LmJvdHRvbSA8IGRkSGVpZ2h0IDogcGxhY2VBYm92ZTsgLy8gZmxpcCB2ZXJ0aWNhbGx5IGlmIHRoZXJlIGlzIG5vIHNwYWNlIGZvciB0aGUgZHJvcGRvd24gYmVsb3cgdGhlIGlucHV0XG5cbiAgICBkZEVsbS5zdHlsZS5jc3NUZXh0ID0gXCJsZWZ0OlwiICsgKGxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQpICsgXCJweDsgd2lkdGg6XCIgKyB3aWR0aCArIFwiO1wiICsgKHBsYWNlQWJvdmUgPyBcInRvcDogXCIgKyAodG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0KSArIFwicHhcIiA6IFwidG9wOiBcIiArIChib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQpICsgXCJweFwiKTtcbiAgICBkZEVsbS5zZXRBdHRyaWJ1dGUoJ3BsYWNlbWVudCcsIHBsYWNlQWJvdmUgPyBcInRvcFwiIDogXCJib3R0b21cIik7XG4gICAgZGRFbG0uc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHBvc2l0aW9uVG8pO1xuICB9LFxuXG4gIGV2ZW50czoge1xuICAgIC8qKlxyXG4gICAgICogRXZlbnRzIHNob3VsZCBvbmx5IGJlIGJpbmRlZCB3aGVuIHRoZSBkcm9wZG93biBpcyByZW5kZXJlZCBhbmQgcmVtb3ZlZCB3aGVuIGlzbid0XHJcbiAgICAgKiBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIFRhZ2lmeSBpbnN0YW5jZXMgb24gYSBjZXJ0YWluIHBhZ2VcclxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGJpbmRVbmJpbmQgW29wdGlvbmFsLiB0cnVlIHdoZW4gd2FudGluZyB0byB1bmJpbmQgYWxsIHRoZSBldmVudHNdXHJcbiAgICAgKi9cbiAgICBiaW5kaW5nKGJpbmRVbmJpbmQgPSB0cnVlKSB7XG4gICAgICAvLyByZWZlcmVuY2VzIHRvIHRoZSBcIi5iaW5kKClcIiBtZXRob2RzIG11c3QgYmUgc2F2ZWQgc28gdGhleSBjb3VsZCBiZSB1bmJpbmRlZCBsYXRlclxuICAgICAgdmFyIF9DQiA9IHRoaXMuZHJvcGRvd24uZXZlbnRzLmNhbGxiYWNrcyxcbiAgICAgICAgICAvLyBjYWxsYmFjay1yZWZzXG4gICAgICBfQ0JSID0gdGhpcy5saXN0ZW5lcnMuZHJvcGRvd24gPSB0aGlzLmxpc3RlbmVycy5kcm9wZG93biB8fCB7XG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLmRyb3Bkb3duLnBvc2l0aW9uLmJpbmQodGhpcyksXG4gICAgICAgIG9uS2V5RG93bjogX0NCLm9uS2V5RG93bi5iaW5kKHRoaXMpLFxuICAgICAgICBvbk1vdXNlT3ZlcjogX0NCLm9uTW91c2VPdmVyLmJpbmQodGhpcyksXG4gICAgICAgIG9uTW91c2VMZWF2ZTogX0NCLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpLFxuICAgICAgICBvbkNsaWNrOiBfQ0Iub25DbGljay5iaW5kKHRoaXMpLFxuICAgICAgICBvblNjcm9sbDogX0NCLm9uU2Nyb2xsLmJpbmQodGhpcylcbiAgICAgIH0sXG4gICAgICAgICAgYWN0aW9uID0gYmluZFVuYmluZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHJvcGRvd24ucG9zaXRpb24gIT0gJ21hbnVhbCcpIHtcbiAgICAgICAgd2luZG93W2FjdGlvbl0oJ3Jlc2l6ZScsIF9DQlIucG9zaXRpb24pO1xuICAgICAgICB3aW5kb3dbYWN0aW9uXSgna2V5ZG93bicsIF9DQlIub25LZXlEb3duKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ET00uZHJvcGRvd25bYWN0aW9uXSgnbW91c2VvdmVyJywgX0NCUi5vbk1vdXNlT3Zlcik7XG4gICAgICB0aGlzLkRPTS5kcm9wZG93blthY3Rpb25dKCdtb3VzZWxlYXZlJywgX0NCUi5vbk1vdXNlTGVhdmUpO1xuICAgICAgdGhpcy5ET00uZHJvcGRvd25bYWN0aW9uXSgnbW91c2Vkb3duJywgX0NCUi5vbkNsaWNrKTtcbiAgICAgIHRoaXMuRE9NLmRyb3Bkb3duLmNvbnRlbnRbYWN0aW9uXSgnc2Nyb2xsJywgX0NCUi5vblNjcm9sbCk7XG4gICAgfSxcblxuICAgIGNhbGxiYWNrczoge1xuICAgICAgb25LZXlEb3duKGUpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBcImFjdGl2ZVwiIGVsZW1lbnQsIGFuZCBpZiB0aGVyZSB3YXMgbm9uZSAoeWV0KSBhY3RpdmUsIHVzZSBmaXJzdCBjaGlsZFxuICAgICAgICB2YXIgc2VsZWN0ZWRFbG0gPSB0aGlzLkRPTS5kcm9wZG93bi5xdWVyeVNlbGVjdG9yKHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy5kcm9wZG93bkl0ZW1BY3RpdmVTZWxlY3RvciksXG4gICAgICAgICAgICBzZWxlY3RlZEVsbURhdGEgPSB0aGlzLmRyb3Bkb3duLmdldFN1Z2dlc3Rpb25EYXRhQnlOb2RlKHNlbGVjdGVkRWxtKTtcblxuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICBjYXNlICdEb3duJzogLy8gPklFMTFcblxuICAgICAgICAgIGNhc2UgJ1VwJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gPklFMTFcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB2YXIgZHJvcGRvd25JdGVtcztcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxtKSBzZWxlY3RlZEVsbSA9IHNlbGVjdGVkRWxtWyhlLmtleSA9PSAnQXJyb3dVcCcgfHwgZS5rZXkgPT0gJ1VwJyA/IFwicHJldmlvdXNcIiA6IFwibmV4dFwiKSArIFwiRWxlbWVudFNpYmxpbmdcIl07IC8vIGlmIG5vIGVsZW1lbnQgd2FzIGZvdW5kLCBsb29wXG5cbiAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEVsbSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duSXRlbXMgPSB0aGlzLkRPTS5kcm9wZG93bi5jb250ZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRWxtID0gZHJvcGRvd25JdGVtc1tlLmtleSA9PSAnQXJyb3dVcCcgfHwgZS5rZXkgPT0gJ1VwJyA/IGRyb3Bkb3duSXRlbXMubGVuZ3RoIC0gMSA6IDBdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VsZWN0ZWRFbG1EYXRhID0gdGhpcy5kcm9wZG93bi5nZXRTdWdnZXN0aW9uRGF0YUJ5Tm9kZShzZWxlY3RlZEVsbSk7XG4gICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlnaGxpZ2h0T3B0aW9uKHNlbGVjdGVkRWxtLCB0cnVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgIGNhc2UgJ0VzYyc6XG4gICAgICAgICAgICAvLyBJRTExXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmhpZGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5hY3Rpb25zLkFycm93TGVmdCkgcmV0dXJuO1xuXG4gICAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gaW4gbWl4LW1vZGUsIHRyZWF0IGFycm93UmlnaHQgbGlrZSBFbnRlciBrZXksIHNvIGEgdGFnIHdpbGwgYmUgY3JlYXRlZFxuICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2RlICE9ICdtaXgnICYmIHNlbGVjdGVkRWxtICYmICF0aGlzLnNldHRpbmdzLmF1dG9Db21wbGV0ZS5yaWdodEtleSAmJiAhdGhpcy5zdGF0ZS5lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50cyBibHVyIHNvIHRoZSBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbiB3aWxsIG5vdCBiZWNvbWUgYSB0YWdcblxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZHJvcGRvd24uZ2V0TWFwcGVkVmFsdWUoc2VsZWN0ZWRFbG1EYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmF1dG9jb21wbGV0ZS5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob29rcy5zdWdnZXN0aW9uQ2xpY2soZSwge1xuICAgICAgICAgICAgICAgIHRhZ2lmeTogdGhpcyxcbiAgICAgICAgICAgICAgICB0YWdEYXRhOiBzZWxlY3RlZEVsbURhdGEsXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbkVsbTogc2VsZWN0ZWRFbG1cbiAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxtKSByZXR1cm4gdGhpcy5kcm9wZG93bi5zZWxlY3RPcHRpb24oc2VsZWN0ZWRFbG0pO2Vsc2UgdGhpcy5kcm9wZG93bi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubW9kZSAhPSAnbWl4JykgdGhpcy5hZGRUYWdzKHRoaXMuc3RhdGUuaW5wdXRUZXh0LnRyaW0oKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiBlcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1vZGUgPT0gJ21peCcgfHwgdGhpcy5zdGF0ZS5lZGl0aW5nLnNjb3BlKSByZXR1cm47XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnB1dC5yYXcuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJcIiB8fCB2YWx1ZS5jaGFyQ29kZUF0KDApID09IDgyMDMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5iYWNrc3BhY2UgPT09IHRydWUpIHRoaXMucmVtb3ZlVGFncygpO2Vsc2UgaWYgKHRoaXMuc2V0dGluZ3MuYmFja3NwYWNlID09ICdlZGl0Jykgc2V0VGltZW91dCh0aGlzLmVkaXRUYWcuYmluZCh0aGlzKSwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25Nb3VzZU92ZXIoZSkge1xuICAgICAgICB2YXIgZGRJdGVtID0gZS50YXJnZXQuY2xvc2VzdCh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMuZHJvcGRvd25JdGVtU2VsZWN0b3IpOyAvLyBldmVudCBkZWxlZ2F0aW9uIGNoZWNrXG5cbiAgICAgICAgZGRJdGVtICYmIHRoaXMuZHJvcGRvd24uaGlnaGxpZ2h0T3B0aW9uKGRkSXRlbSk7XG4gICAgICB9LFxuXG4gICAgICBvbk1vdXNlTGVhdmUoZSkge1xuICAgICAgICAvLyBkZS1oaWdobGlnaHQgYW55IHByZXZpb3VzbHkgaGlnaGxpZ2h0ZWQgb3B0aW9uXG4gICAgICAgIHRoaXMuZHJvcGRvd24uaGlnaGxpZ2h0T3B0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9IDAgfHwgZS50YXJnZXQgPT0gdGhpcy5ET00uZHJvcGRvd24gfHwgZS50YXJnZXQgPT0gdGhpcy5ET00uZHJvcGRvd24uY29udGVudCkgcmV0dXJuOyAvLyBhbGxvdyBvbmx5IG1vdXNlIGxlZnQtY2xpY2tzXG5cbiAgICAgICAgdmFyIHNlbGVjdGVkRWxtID0gZS50YXJnZXQuY2xvc2VzdCh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMuZHJvcGRvd25JdGVtU2VsZWN0b3IpLFxuICAgICAgICAgICAgc2VsZWN0ZWRFbG1EYXRhID0gdGhpcy5kcm9wZG93bi5nZXRTdWdnZXN0aW9uRGF0YUJ5Tm9kZShzZWxlY3RlZEVsbSk7IC8vIHRlbXBvcmFyeSBzZXQgdGhlIFwiYWN0aW9uc1wiIHN0YXRlIHRvIGluZGljYXRlIHRvIHRoZSBtYWluIFwiYmx1clwiIGV2ZW50IGl0IHNob3VsZG4ndCBydW5cblxuICAgICAgICB0aGlzLnN0YXRlLmFjdGlvbnMuc2VsZWN0T3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXRlLmFjdGlvbnMuc2VsZWN0T3B0aW9uID0gZmFsc2UsIDUwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5ob29rcy5zdWdnZXN0aW9uQ2xpY2soZSwge1xuICAgICAgICAgIHRhZ2lmeTogdGhpcyxcbiAgICAgICAgICB0YWdEYXRhOiBzZWxlY3RlZEVsbURhdGEsXG4gICAgICAgICAgc3VnZ2VzdGlvbkVsbTogc2VsZWN0ZWRFbG1cbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkRWxtKSB0aGlzLmRyb3Bkb3duLnNlbGVjdE9wdGlvbihzZWxlY3RlZEVsbSk7ZWxzZSB0aGlzLmRyb3Bkb3duLmhpZGUoKTtcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IGNvbnNvbGUud2FybihlcnIpKTtcbiAgICAgIH0sXG5cbiAgICAgIG9uU2Nyb2xsKGUpIHtcbiAgICAgICAgdmFyIGVsbSA9IGUudGFyZ2V0LFxuICAgICAgICAgICAgcG9zID0gZWxtLnNjcm9sbFRvcCAvIChlbG0uc2Nyb2xsSGVpZ2h0IC0gZWxtLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0KSAqIDEwMDtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiZHJvcGRvd246c2Nyb2xsXCIsIHtcbiAgICAgICAgICBwZXJjZW50YWdlOiBNYXRoLnJvdW5kKHBvcylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3VnZ2VzdGlvbkRhdGFCeU5vZGUodGFnRWxtKSB7XG4gICAgdmFyIGlkeCA9IHRhZ0VsbSA/ICt0YWdFbG0uZ2V0QXR0cmlidXRlKCd0YWdpZnlTdWdnZXN0aW9uSWR4JykgOiAtMTtcbiAgICByZXR1cm4gdGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXNbaWR4XSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIG1hcmsgdGhlIGN1cnJlbnRseSBhY3RpdmUgc3VnZ2VzdGlvbiBvcHRpb25cclxuICAgKiBAcGFyYW0ge09iamVjdH0gIGVsbSAgICAgICAgICAgIG9wdGlvbiBET00gbm9kZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRqdXN0U2Nyb2xsICAgd2hlbiBuYXZpZ2F0aW9uIHdpdGgga2V5Ym9hcmQgYXJyb3dzICh1cC9kb3duKSwgYXV0LXNjcm9sbCB0byBhbHdheXMgc2hvdyB0aGUgaGlnaGxpZ2h0ZWQgZWxlbWVudFxyXG4gICAqL1xuICBoaWdobGlnaHRPcHRpb24oZWxtLCBhZGp1c3RTY3JvbGwpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLmRyb3Bkb3duSXRlbUFjdGl2ZSxcbiAgICAgICAgaXRlbURhdGE7IC8vIGZvY3VzIGNhc3VlcyBhIGJ1ZyBpbiBGaXJlZm94IHdpdGggdGhlIHBsYWNlaG9sZGVyIGJlZW4gc2hvd24gb24gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAvLyBpZiggdGhpcy5zZXR0aW5ncy5kcm9wZG93bi5wb3NpdGlvbiAhPSAnbWFudWFsJyApXG4gICAgLy8gICAgIGVsbS5mb2N1cygpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUuZGRJdGVtRWxtKSB7XG4gICAgICB0aGlzLnN0YXRlLmRkSXRlbUVsbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB0aGlzLnN0YXRlLmRkSXRlbUVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgIH1cblxuICAgIGlmICghZWxtKSB7XG4gICAgICB0aGlzLnN0YXRlLmRkSXRlbURhdGEgPSBudWxsO1xuICAgICAgdGhpcy5zdGF0ZS5kZEl0ZW1FbG0gPSBudWxsO1xuICAgICAgdGhpcy5pbnB1dC5hdXRvY29tcGxldGUuc3VnZ2VzdC5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGl0ZW1EYXRhID0gdGhpcy5zdWdnZXN0ZWRMaXN0SXRlbXNbdGhpcy5nZXROb2RlSW5kZXgoZWxtKV07XG4gICAgdGhpcy5zdGF0ZS5kZEl0ZW1EYXRhID0gaXRlbURhdGE7XG4gICAgdGhpcy5zdGF0ZS5kZEl0ZW1FbG0gPSBlbG07IC8vIHRoaXMuRE9NLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIgKyB0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMuZHJvcGRvd25JdGVtQWN0aXZlKS5mb3JFYWNoKGFjdGl2ZUVsbSA9PiBhY3RpdmVFbG0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpKTtcblxuICAgIGVsbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgZWxtLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgaWYgKGFkanVzdFNjcm9sbCkgZWxtLnBhcmVudE5vZGUuc2Nyb2xsVG9wID0gZWxtLmNsaWVudEhlaWdodCArIGVsbS5vZmZzZXRUb3AgLSBlbG0ucGFyZW50Tm9kZS5jbGllbnRIZWlnaHQ7IC8vIFRyeSB0byBhdXRvY29tcGxldGUgdGhlIHR5cGVkIHZhbHVlIHdpdGggdGhlIGN1cnJlbnRseSBoaWdobGlnaHRlZCBkcm9wZG93biBpdGVtXG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuaW5wdXQuYXV0b2NvbXBsZXRlLnN1Z2dlc3QuY2FsbCh0aGlzLCBpdGVtRGF0YSk7XG4gICAgICB0aGlzLmRyb3Bkb3duLnBvc2l0aW9uKCk7IC8vIHN1Z2dlc3Rpb25zIG1pZ2h0IGFsdGVyIHRoZSBoZWlnaHQgb2YgdGhlIHRhZ2lmeSB3cmFwcGVyIGJlY2F1c2Ugb2YgdW5rb3duIHN1Z2dlc3RlZCB0ZXJtIGxlbmd0aCB0aGF0IGNvdWxkIGRyb3AgdG8gdGhlIG5leHQgbGluZVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSB0YWcgZnJvbSB0aGUgY3VycmVudGx5IGFjdGl2ZSBzdWdnZXN0aW9uIG9wdGlvblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbG0gIERPTSBub2RlIHRvIHNlbGVjdFxyXG4gICAqL1xuICBzZWxlY3RPcHRpb24oZWxtKSB7XG4gICAgdmFyIF90aGlzJHNldHRpbmdzJGRyb3BkbyA9IHRoaXMuc2V0dGluZ3MuZHJvcGRvd24sXG4gICAgICAgIGNsZWFyT25TZWxlY3QgPSBfdGhpcyRzZXR0aW5ncyRkcm9wZG8uY2xlYXJPblNlbGVjdCxcbiAgICAgICAgY2xvc2VPblNlbGVjdCA9IF90aGlzJHNldHRpbmdzJGRyb3Bkby5jbG9zZU9uU2VsZWN0LFxuICAgICAgICBhZGRlZFRhZztcblxuICAgIGlmICghZWxtKSB7XG4gICAgICBhZGRlZFRhZyA9IHRoaXMuYWRkVGFncyh0aGlzLnN0YXRlLmlucHV0VGV4dCwgdHJ1ZSk7XG4gICAgICBjbG9zZU9uU2VsZWN0ICYmIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgaW4gZWRpdC1tb2RlLCBkbyBub3QgY29udGludWUgYnV0IGluc3RlYWQgcmVwbGFjZSB0aGUgdGFnJ3MgdGV4dC5cbiAgICAvLyB0aGUgc2NlbmFyaW8gaXMgdGhhdCBcImFkZFRhZ3NcIiB3YXMgY2FsbGVkIGZyb20gYSBkcm9wZG93biBzdWdnZXN0ZWQgb3B0aW9uIHNlbGVjdGVkIHdoaWxlIGVkaXRpbmdcblxuXG4gICAgdmFyIHRhZ2lmeVN1Z2dlc3Rpb25JZHggPSBlbG0uZ2V0QXR0cmlidXRlKCd0YWdpZnlTdWdnZXN0aW9uSWR4JyksXG4gICAgICAgIHRhZ0RhdGEgPSB0aGlzLnN1Z2dlc3RlZExpc3RJdGVtc1srdGFnaWZ5U3VnZ2VzdGlvbklkeF07XG4gICAgdGhpcy50cmlnZ2VyKFwiZHJvcGRvd246c2VsZWN0XCIsIHtcbiAgICAgIGRhdGE6IHRhZ0RhdGEsXG4gICAgICBlbG1cbiAgICB9KTsgLy8gVGhlIGFib3ZlIGV2ZW50IG11c3QgYmUgdHJpZ2dlcmVkLCByZWdhcmRsZXNzIG9mIGFueXRoaW5nIGVsc2Ugd2hpY2ggbWlnaHQgZ28gd3JvbmdcblxuICAgIGlmICghdGFnaWZ5U3VnZ2VzdGlvbklkeCB8fCAhdGFnRGF0YSkge1xuICAgICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUuZWRpdGluZykgLy8gbm9ybWFsaXppbmcgdmFsdWUsIGJlY2F1c2UgXCJ0YWdEYXRhXCIgbWlnaHQgYmUgYSBzdHJpbmcsIGFuZCB0aGVyZWZvcmUgd2lsbCBub3QgYmUgYWJsZSB0byBleHRlbmQgdGhlIG9iamVjdFxuICAgICAgdGhpcy5vbkVkaXRUYWdEb25lKG51bGwsIGV4dGVuZCh7XG4gICAgICAgIF9faXNWYWxpZDogdHJ1ZVxuICAgICAgfSwgdGhpcy5ub3JtYWxpemVUYWdzKHRhZ0RhdGEpWzBdKSk7IC8vIFRhZ2lmeSBpbnN0YW5jZXMgc2hvdWxkIHJlLWZvY3VzIHRvIHRoZSBpbnB1dCBlbGVtZW50IG9uY2UgYW4gb3B0aW9uIHdhcyBzZWxlY3RlZCwgdG8gYWxsb3cgY29udGludW91cyB0eXBpbmdcbiAgICBlbHNlIHtcbiAgICAgIGFkZGVkVGFnID0gdGhpc1t0aGlzLnNldHRpbmdzLm1vZGUgPT0gJ21peCcgPyBcImFkZE1peFRhZ3NcIiA6IFwiYWRkVGFnc1wiXShbdGFnRGF0YV0sIGNsZWFyT25TZWxlY3QpO1xuICAgIH0gLy8gdG9kbzogY29uc2lkZXIgbm90IGRvaW5nIHRoaXMgb24gbWl4LW1vZGVcblxuICAgIGlmICghdGhpcy5ET00uaW5wdXQucGFyZW50Tm9kZSkgcmV0dXJuO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5ET00uaW5wdXQuZm9jdXMoKTtcbiAgICAgIHRoaXMudG9nZ2xlRm9jdXNDbGFzcyh0cnVlKTtcbiAgICAgIHRoaXMucGxhY2VDYXJldEFmdGVyTm9kZShhZGRlZFRhZyk7XG4gICAgfSk7XG5cbiAgICBpZiAoY2xvc2VPblNlbGVjdCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLmRyb3Bkb3duLmhpZGUuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHRoaXMuZHJvcGRvd24ucmVmaWx0ZXIoKTtcbiAgfSxcblxuICBzZWxlY3RBbGwoKSB7XG4gICAgLy8gaGF2aW5nIHN1Z2dlc3RlZExpc3RJdGVtcyB3aXRoIGl0ZW1zIG1lc3NlcyB3aXRoIFwibm9ybWFsaXplVGFnc1wiIHdoZW4gd2FudGluZ1xuICAgIC8vIHRvIGFkZCBhbGwgdGFnc1xuICAgIHRoaXMuc3VnZ2VzdGVkTGlzdEl0ZW1zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7IC8vIHNvbWUgd2hpdGVsaXN0IGl0ZW1zIG1pZ2h0IGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkIGFzIHRhZ3Mgc28gd2hlbiBhZGRpbmdzIGFsbCBvZiB0aGVtLFxuICAgIC8vIHNraXAgYWRkaW5nIGFscmVhZHktYWRkZWQgb25lcywgc28gYmVzdCB0byB1c2UgXCJmaWx0ZXJMaXN0SXRlbXNcIiBtZXRob2Qgb3ZlciBcInNldHRpbmdzLndoaXRlbGlzdFwiXG5cbiAgICB0aGlzLmFkZFRhZ3ModGhpcy5kcm9wZG93bi5maWx0ZXJMaXN0SXRlbXMoJycpLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcclxuICAgKiByZXR1cm5zIGFuIEhUTUwgc3RyaW5nIG9mIHRoZSBzdWdnZXN0aW9ucycgbGlzdCBpdGVtc1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBzdHJpbmcgdG8gZmlsdGVyIHRoZSB3aGl0ZWxpc3QgYnlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBcImV4YWN0XCIgLSBmb3IgZXhhY3QgY29tcGxldGUgbWF0Y2hcclxuICAgKiBAcmV0dXJuIHtBcnJheX0gbGlzdCBvZiBmaWx0ZXJlZCB3aGl0ZWxpc3QgaXRlbXMgYWNjb3JkaW5nIHRvIHRoZSBzZXR0aW5ncyBwcm92aWRlZCBhbmQgY3VycmVudCB2YWx1ZVxyXG4gICAqL1xuICBmaWx0ZXJMaXN0SXRlbXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICBfc2QgPSBfcy5kcm9wZG93bixcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZhbHVlID0gX3MubW9kZSA9PSAnc2VsZWN0JyAmJiB0aGlzLnZhbHVlLmxlbmd0aCAmJiB0aGlzLnZhbHVlWzBdW19zLnRhZ1RleHRQcm9wXSA9PSB2YWx1ZSA/ICcnIC8vIGRvIG5vdCBmaWx0ZXIgaWYgdGhlIHRhZywgd2hpY2ggaXMgYWxyZWFkeSBzZWxlY2V0ZCBpbiBcInNlbGVjdFwiIG1vZGUsIGlzIHRoZSBzYW1lIGFzIHRoZSB0eXBlZCB0ZXh0XG4gICAgOiB2YWx1ZSxcbiAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICBleGFjdE1hdGNoZXNMaXN0ID0gW10sXG4gICAgICAgIHdoaXRlbGlzdCA9IF9zLndoaXRlbGlzdCxcbiAgICAgICAgc3VnZ2VzdGlvbnNDb3VudCA9IF9zZC5tYXhJdGVtcyB8fCBJbmZpbml0eSxcbiAgICAgICAgc2VhcmNoS2V5cyA9IF9zZC5zZWFyY2hLZXlzLFxuICAgICAgICB3aGl0ZWxpc3RJdGVtLFxuICAgICAgICB2YWx1ZUlzSW5XaGl0ZWxpc3QsXG4gICAgICAgIHNlYXJjaEJ5LFxuICAgICAgICBpc0R1cGxpY2F0ZSxcbiAgICAgICAgbmlkZGxlLFxuICAgICAgICBpID0gMDtcblxuICAgIGlmICghdmFsdWUgfHwgIXNlYXJjaEtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKF9zLmR1cGxpY2F0ZXMgPyB3aGl0ZWxpc3QgOiB3aGl0ZWxpc3QuZmlsdGVyKGl0ZW0gPT4gIXRoaXMuaXNUYWdEdXBsaWNhdGUoaXNPYmplY3QoaXRlbSkgPyBpdGVtLnZhbHVlIDogaXRlbSkpIC8vIGRvbid0IGluY2x1ZGUgdGFncyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBhZGRlZC5cbiAgICAgICkuc2xpY2UoMCwgc3VnZ2VzdGlvbnNDb3VudCk7IC8vIHJlc3BlY3QgXCJtYXhJdGVtc1wiIGRyb3Bkb3duIHNldHRpbmdcbiAgICB9XG5cbiAgICBuaWRkbGUgPSBfc2QuY2FzZVNlbnNpdGl2ZSA/IFwiXCIgKyB2YWx1ZSA6IChcIlwiICsgdmFsdWUpLnRvTG93ZXJDYXNlKCk7IC8vIGNoZWNrcyBpZiBBTEwgb2YgdGhlIHdvcmRzIGluIHRoZSBzZWFyY2ggcXVlcnkgZXhpc3RzIGluIHRoZSBjdXJyZW50IHdoaXRlbGlzdCBpdGVtLCByZWdhcmRsZXNzIG9mIHRoZWlyIG9yZGVyXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdIYXNBbGwocywgcXVlcnkpIHtcbiAgICAgIHJldHVybiBxdWVyeS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykuZXZlcnkocSA9PiBzLmluY2x1ZGVzKHEudG9Mb3dlckNhc2UoKSkpO1xuICAgIH1cblxuICAgIGZvciAoOyBpIDwgd2hpdGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3RhcnRzV2l0aE1hdGNoLCBleGFjdE1hdGNoO1xuICAgICAgd2hpdGVsaXN0SXRlbSA9IHdoaXRlbGlzdFtpXSBpbnN0YW5jZW9mIE9iamVjdCA/IHdoaXRlbGlzdFtpXSA6IHtcbiAgICAgICAgdmFsdWU6IHdoaXRlbGlzdFtpXVxuICAgICAgfTsgLy9ub3JtYWxpemUgdmFsdWUgYXMgYW4gT2JqZWN0XG5cbiAgICAgIGxldCBpdGVtV2l0aG91dFNlYXJjaEtleXMgPSAhT2JqZWN0LmtleXMod2hpdGVsaXN0SXRlbSkuc29tZShrID0+IHNlYXJjaEtleXMuaW5jbHVkZXMoaykpLFxuICAgICAgICAgIF9zZWFyY2hLZXlzID0gaXRlbVdpdGhvdXRTZWFyY2hLZXlzID8gW1widmFsdWVcIl0gOiBzZWFyY2hLZXlzO1xuXG4gICAgICBpZiAoX3NkLmZ1enp5U2VhcmNoICYmICFvcHRpb25zLmV4YWN0KSB7XG4gICAgICAgIHNlYXJjaEJ5ID0gX3NlYXJjaEtleXMucmVkdWNlKCh2YWx1ZXMsIGspID0+IHZhbHVlcyArIFwiIFwiICsgKHdoaXRlbGlzdEl0ZW1ba10gfHwgXCJcIiksIFwiXCIpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuXG4gICAgICAgIGlmIChfc2QuYWNjZW50ZWRTZWFyY2gpIHtcbiAgICAgICAgICBzZWFyY2hCeSA9IHVuYWNjZW50KHNlYXJjaEJ5KTtcbiAgICAgICAgICBuaWRkbGUgPSB1bmFjY2VudChuaWRkbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRzV2l0aE1hdGNoID0gc2VhcmNoQnkuaW5kZXhPZihuaWRkbGUpID09IDA7XG4gICAgICAgIGV4YWN0TWF0Y2ggPSBzZWFyY2hCeSA9PT0gbmlkZGxlO1xuICAgICAgICB2YWx1ZUlzSW5XaGl0ZWxpc3QgPSBzdHJpbmdIYXNBbGwoc2VhcmNoQnksIG5pZGRsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydHNXaXRoTWF0Y2ggPSB0cnVlO1xuICAgICAgICB2YWx1ZUlzSW5XaGl0ZWxpc3QgPSBfc2VhcmNoS2V5cy5zb21lKGsgPT4ge1xuICAgICAgICAgIHZhciB2ID0gJycgKyAod2hpdGVsaXN0SXRlbVtrXSB8fCAnJyk7IC8vIGlmIGtleSBleGlzdHMsIGNhc3QgdG8gdHlwZSBTdHJpbmdcblxuICAgICAgICAgIGlmIChfc2QuYWNjZW50ZWRTZWFyY2gpIHtcbiAgICAgICAgICAgIHYgPSB1bmFjY2VudCh2KTtcbiAgICAgICAgICAgIG5pZGRsZSA9IHVuYWNjZW50KG5pZGRsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfc2QuY2FzZVNlbnNpdGl2ZSkgdiA9IHYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBleGFjdE1hdGNoID0gdiA9PT0gbmlkZGxlO1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmV4YWN0ID8gdiA9PT0gbmlkZGxlIDogdi5pbmRleE9mKG5pZGRsZSkgPT0gMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlzRHVwbGljYXRlID0gIV9zLmR1cGxpY2F0ZXMgJiYgdGhpcy5pc1RhZ0R1cGxpY2F0ZShpc09iamVjdCh3aGl0ZWxpc3RJdGVtKSA/IHdoaXRlbGlzdEl0ZW0udmFsdWUgOiB3aGl0ZWxpc3RJdGVtKTsgLy8gbWF0Y2ggZm9yIHRoZSB2YWx1ZSB3aXRoaW4gZWFjaCBcIndoaXRlbGlzdFwiIGl0ZW1cblxuICAgICAgaWYgKHZhbHVlSXNJbldoaXRlbGlzdCAmJiAhaXNEdXBsaWNhdGUpIGlmIChleGFjdE1hdGNoICYmIHN0YXJ0c1dpdGhNYXRjaCkgZXhhY3RNYXRjaGVzTGlzdC5wdXNoKHdoaXRlbGlzdEl0ZW0pO2Vsc2UgaWYgKF9zZC5zb3J0YnkgPT0gJ3N0YXJ0c1dpdGgnICYmIHN0YXJ0c1dpdGhNYXRjaCkgbGlzdC51bnNoaWZ0KHdoaXRlbGlzdEl0ZW0pO2Vsc2UgbGlzdC5wdXNoKHdoaXRlbGlzdEl0ZW0pO1xuICAgIH0gLy8gY3VzdG9tIHNvcnRpbmcgZnVuY3Rpb25cblxuXG4gICAgcmV0dXJuIHR5cGVvZiBfc2Quc29ydGJ5ID09ICdmdW5jdGlvbicgPyBfc2Quc29ydGJ5KGV4YWN0TWF0Y2hlc0xpc3QuY29uY2F0KGxpc3QpLCBuaWRkbGUpIDogZXhhY3RNYXRjaGVzTGlzdC5jb25jYXQobGlzdCkuc2xpY2UoMCwgc3VnZ2VzdGlvbnNDb3VudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZmluYWwgdmFsdWUgb2YgYSB0YWcgZGF0YSAob2JqZWN0KSB3aXRoIHJlZ2FyZHMgdG8gdGhlIFwibWFwVmFsdWVUb1wiIGRyb3Bkb3duIHNldHRpbmdcclxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFnRGF0YVxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXG4gIGdldE1hcHBlZFZhbHVlKHRhZ0RhdGEpIHtcbiAgICB2YXIgbWFwVmFsdWVUbyA9IHRoaXMuc2V0dGluZ3MuZHJvcGRvd24ubWFwVmFsdWVUbyxcbiAgICAgICAgdmFsdWUgPSBtYXBWYWx1ZVRvID8gdHlwZW9mIG1hcFZhbHVlVG8gPT0gJ2Z1bmN0aW9uJyA/IG1hcFZhbHVlVG8odGFnRGF0YSkgOiB0YWdEYXRhW21hcFZhbHVlVG9dIHx8IHRhZ0RhdGEudmFsdWUgOiB0YWdEYXRhLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGVzIHRoZSBkcm9wZG93biBpdGVtcycgSFRNTFxyXG4gICAqIEBwYXJhbSAge0FycmF5fSBsaXN0ICBbQXJyYXkgb2YgT2JqZWN0c11cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXG4gIGNyZWF0ZUxpc3RIVE1MKG9wdGlvbnNBcnIpIHtcbiAgICByZXR1cm4gZXh0ZW5kKFtdLCBvcHRpb25zQXJyKS5tYXAoKHN1Z2dlc3Rpb24sIGlkeCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBzdWdnZXN0aW9uID09ICdzdHJpbmcnIHx8IHR5cGVvZiBzdWdnZXN0aW9uID09ICdudW1iZXInKSBzdWdnZXN0aW9uID0ge1xuICAgICAgICB2YWx1ZTogc3VnZ2VzdGlvblxuICAgICAgfTtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZHJvcGRvd24uZ2V0TWFwcGVkVmFsdWUoc3VnZ2VzdGlvbik7XG4gICAgICBzdWdnZXN0aW9uLnZhbHVlID0gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnID8gZXNjYXBlSFRNTCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIHZhciB0YWdIVE1MU3RyaW5nID0gdGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXMuZHJvcGRvd25JdGVtLmFwcGx5KHRoaXMsIFtzdWdnZXN0aW9uLCB0aGlzXSk7IC8vIG1ha2Ugc3VyZSB0aGUgc3VnZXN0aW9uIGluZGV4IGlzIHByZXNlbnQgYXMgYXR0cmlidXRlLCB0byBtYXRjaCB0aGUgZGF0YSB3aGVuIG9uZSBpcyBzZWxlY3RlZFxuXG4gICAgICB0YWdIVE1MU3RyaW5nID0gdGFnSFRNTFN0cmluZy5yZXBsYWNlKC9cXHMqdGFnaWZ5U3VnZ2VzdGlvbklkeD0oW1wiJ10pKC4qPylcXDEvZ21pLCAnJykgLy8gcmVtb3ZlIHRoZSBcInRhZ2lmeVN1Z2dlc3Rpb25JZHhcIiBhdHRyaWJ1dGUgaWYgZm9yIHNvbWUgcmVhc29uIHdhcyB0aGVyZVxuICAgICAgLnJlcGxhY2UoJz4nLCBgIHRhZ2lmeVN1Z2dlc3Rpb25JZHg9XCIke2lkeH1cIj5gKTsgLy8gYWRkIFwidGFnaWZ5U3VnZ2VzdGlvbklkeFwiXG5cbiAgICAgIHJldHVybiB0YWdIVE1MU3RyaW5nO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH1cblxufTtcblxuY29uc3QgVkVSU0lPTiA9IDE7IC8vIGN1cnJlbnQgdmVyc2lvbiBvZiBwZXJzaXN0ZWQgZGF0YS4gaWYgY29kZSBjaGFuZ2UgYnJlYWtzIHBlcnNpc3RlZCBkYXRhLCB2ZXJpc29uIG51bWJlciBzaG91bGQgYmUgYnVtcGVkLlxuXG5jb25zdCBTVE9SRV9LRVkgPSAnQHlhaXJlby90YWdpZnkvJztcbmNvbnN0IGdldFBlcnNpc3RlZERhdGEgPSBpZCA9PiBrZXkgPT4ge1xuICAvLyBpZiBcInBlcnNpc3RcIiBpcyBcImZhbHNlXCIsIGRvIG5vdCBzYXZlIHRvIGxvY2Fsc3RvcmFnZVxuICBsZXQgY3VzdG9tS2V5ID0gJy8nICsga2V5LFxuICAgICAgcGVyc2lzdGVkRGF0YSxcbiAgICAgIHZlcnNpb25NYXRjaCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JFX0tFWSArIGlkICsgJy92JywgVkVSU0lPTikgPT0gVkVSU0lPTjtcblxuICBpZiAodmVyc2lvbk1hdGNoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBlcnNpc3RlZERhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVtTVE9SRV9LRVkgKyBpZCArIGN1c3RvbUtleV0pO1xuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfVxuXG4gIHJldHVybiBwZXJzaXN0ZWREYXRhO1xufTtcbmNvbnN0IHNldFBlcnNpc3RlZERhdGEgPSBpZCA9PiB7XG4gIGlmICghaWQpIHJldHVybiAoKSA9PiB7fTsgLy8gZm9yIHN0b3JhZ2UgaW52YWxpZGF0aW9uXG5cbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkVfS0VZICsgaWQgKyAnL3YnLCBWRVJTSU9OKTtcbiAgcmV0dXJuIChkYXRhLCBrZXkpID0+IHtcbiAgICBsZXQgY3VzdG9tS2V5ID0gJy8nICsga2V5LFxuICAgICAgICBwZXJzaXN0ZWREYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG5cbiAgICBpZiAoZGF0YSAmJiBrZXkpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JFX0tFWSArIGlkICsgY3VzdG9tS2V5LCBwZXJzaXN0ZWREYXRhKTtcbiAgICAgIGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9yYWdlJykpO1xuICAgIH1cbiAgfTtcbn07XG5jb25zdCBjbGVhclBlcnNpc3RlZERhdGEgPSBpZCA9PiBrZXkgPT4ge1xuICBjb25zdCBiYXNlID0gU1RPUkVfS0VZICsgJy8nICsgaWQgKyAnLyc7IC8vIGRlbGV0ZSBzcGVjaWZpYyBrZXkgaW4gdGhlIHN0b3JhZ2VcblxuICBpZiAoa2V5KSBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShiYXNlICsga2V5KTsgLy8gZGVsZXRlIGFsbCBrZXlzIGluIHRoZSBzdG9yYWdlIHdpdGggYSBzcGVjaWZpYyB0YWdpZnkgaWRcbiAgZWxzZSB7XG4gICAgZm9yIChsZXQgayBpbiBsb2NhbFN0b3JhZ2UpIGlmIChrLmluY2x1ZGVzKGJhc2UpKSBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrKTtcbiAgfVxufTtcblxudmFyIFRFWFRTID0ge1xuICBlbXB0eTogXCJlbXB0eVwiLFxuICBleGNlZWQ6IFwibnVtYmVyIG9mIHRhZ3MgZXhjZWVkZWRcIixcbiAgcGF0dGVybjogXCJwYXR0ZXJuIG1pc21hdGNoXCIsXG4gIGR1cGxpY2F0ZTogXCJhbHJlYWR5IGV4aXN0c1wiLFxuICBub3RBbGxvd2VkOiBcIm5vdCBhbGxvd2VkXCJcbn07XG5cbnZhciB0ZW1wbGF0ZXMgPSB7XG4gIC8qKlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET00gT2JqZWN0fSBpbnB1dCAgICAgT3JpZ2luYWwgaW5wdXQgRE9tIGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge09iamVjdH0gICAgIHNldHRpbmdzICBUYWdpZnkgaW5zdGFuY2Ugc2V0dGluZ3MgT2JqZWN0XHJcbiAgICovXG4gIHdyYXBwZXIoaW5wdXQsIF9zKSB7XG4gICAgcmV0dXJuIGA8dGFncyBjbGFzcz1cIiR7X3MuY2xhc3NOYW1lcy5uYW1lc3BhY2V9ICR7X3MubW9kZSA/IGAke19zLmNsYXNzTmFtZXNbX3MubW9kZSArIFwiTW9kZVwiXX1gIDogXCJcIn0gJHtpbnB1dC5jbGFzc05hbWV9XCJcbiAgICAgICAgICAgICAgICAgICAgJHtfcy5yZWFkb25seSA/ICdyZWFkb25seScgOiAnJ31cbiAgICAgICAgICAgICAgICAgICAgJHtfcy5kaXNhYmxlZCA/ICdkaXNhYmxlZCcgOiAnJ31cbiAgICAgICAgICAgICAgICAgICAgJHtfcy5yZXF1aXJlZCA/ICdyZXF1aXJlZCcgOiAnJ31cbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCItMVwiPlxuICAgICAgICAgICAgPHNwYW4gJHshX3MucmVhZG9ubHkgJiYgX3MudXNlcklucHV0ID8gJ2NvbnRlbnRlZGl0YWJsZScgOiAnJ30gdGFiSW5kZXg9XCIwXCIgZGF0YS1wbGFjZWhvbGRlcj1cIiR7X3MucGxhY2Vob2xkZXIgfHwgJyYjODIwMzsnfVwiIGFyaWEtcGxhY2Vob2xkZXI9XCIke19zLnBsYWNlaG9sZGVyIHx8ICcnfVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCIke19zLmNsYXNzTmFtZXMuaW5wdXR9XCJcbiAgICAgICAgICAgICAgICByb2xlPVwidGV4dGJveFwiXG4gICAgICAgICAgICAgICAgYXJpYS1hdXRvY29tcGxldGU9XCJib3RoXCJcbiAgICAgICAgICAgICAgICBhcmlhLW11bHRpbGluZT1cIiR7X3MubW9kZSA9PSAnbWl4JyA/IHRydWUgOiBmYWxzZX1cIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgJiM4MjAzO1xuICAgICAgICA8L3RhZ3M+YDtcbiAgfSxcblxuICB0YWcodGFnRGF0YSwgdGFnaWZ5KSB7XG4gICAgdmFyIF9zID0gdGhpcy5zZXR0aW5ncztcbiAgICByZXR1cm4gYDx0YWcgdGl0bGU9XCIke3RhZ0RhdGEudGl0bGUgfHwgdGFnRGF0YS52YWx1ZX1cIlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ZWRpdGFibGU9J2ZhbHNlJ1xuICAgICAgICAgICAgICAgICAgICBzcGVsbGNoZWNrPSdmYWxzZSdcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9XCIke19zLmExMXkuZm9jdXNhYmxlVGFncyA/IDAgOiAtMX1cIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIiR7X3MuY2xhc3NOYW1lcy50YWd9ICR7dGFnRGF0YS5jbGFzcyB8fCBcIlwifVwiXG4gICAgICAgICAgICAgICAgICAgICR7dGhpcy5nZXRBdHRyaWJ1dGVzKHRhZ0RhdGEpfT5cbiAgICAgICAgICAgIDx4IHRpdGxlPScnIGNsYXNzPVwiJHtfcy5jbGFzc05hbWVzLnRhZ1h9XCIgcm9sZT0nYnV0dG9uJyBhcmlhLWxhYmVsPSdyZW1vdmUgdGFnJz48L3g+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtfcy5jbGFzc05hbWVzLnRhZ1RleHR9XCI+JHt0YWdEYXRhW19zLnRhZ1RleHRQcm9wXSB8fCB0YWdEYXRhLnZhbHVlfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3RhZz5gO1xuICB9LFxuXG4gIGRyb3Bkb3duKHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZCA9IHNldHRpbmdzLmRyb3Bkb3duLFxuICAgICAgICBpc01hbnVhbCA9IF9zZC5wb3NpdGlvbiA9PSAnbWFudWFsJyxcbiAgICAgICAgY2xhc3NOYW1lID0gYCR7c2V0dGluZ3MuY2xhc3NOYW1lcy5kcm9wZG93bn1gO1xuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cIiR7aXNNYW51YWwgPyBcIlwiIDogY2xhc3NOYW1lfSAke19zZC5jbGFzc25hbWV9XCIgcm9sZT1cImxpc3Rib3hcIiBhcmlhLWxhYmVsbGVkYnk9XCJkcm9wZG93blwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtzZXR0aW5ncy5jbGFzc05hbWVzLmRyb3Bkb3duV3JhcHBlcn1cIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5gO1xuICB9LFxuXG4gIGRyb3Bkb3duSXRlbShpdGVtLCB0YWdpZnkpIHtcbiAgICByZXR1cm4gYDxkaXYgJHt0aGlzLmdldEF0dHJpYnV0ZXMoaXRlbSl9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPScke3RoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy5kcm9wZG93bkl0ZW19ICR7aXRlbS5jbGFzcyA/IGl0ZW0uY2xhc3MgOiBcIlwifSdcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cIm9wdGlvblwiPiR7aXRlbS52YWx1ZX08L2Rpdj5gO1xuICB9LFxuXG4gIGRyb3Bkb3duSXRlbU5vTWF0Y2g6IG51bGxcbn07XG5cbmZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcihpbnN0YW5jZSkge1xuICAvLyBDcmVhdGUgYSBET00gRXZlbnRUYXJnZXQgb2JqZWN0XG4gIHZhciB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5cbiAgZnVuY3Rpb24gYWRkUmVtb3ZlKG9wLCBldmVudHMsIGNiKSB7XG4gICAgaWYgKGNiKSBldmVudHMuc3BsaXQoL1xccysvZykuZm9yRWFjaChuYW1lID0+IHRhcmdldFtvcCArICdFdmVudExpc3RlbmVyJ10uY2FsbCh0YXJnZXQsIG5hbWUsIGNiKSk7XG4gIH0gLy8gUGFzcyBFdmVudFRhcmdldCBpbnRlcmZhY2UgY2FsbHMgdG8gRE9NIEV2ZW50VGFyZ2V0IG9iamVjdFxuXG5cbiAgcmV0dXJuIHtcbiAgICBvZmYoZXZlbnRzLCBjYikge1xuICAgICAgYWRkUmVtb3ZlKCdyZW1vdmUnLCBldmVudHMsIGNiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbihldmVudHMsIGNiKSB7XG4gICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09ICdmdW5jdGlvbicpIGFkZFJlbW92ZSgnYWRkJywgZXZlbnRzLCBjYik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdHJpZ2dlcihldmVudE5hbWUsIGRhdGEsIG9wdHMpIHtcbiAgICAgIHZhciBlO1xuICAgICAgb3B0cyA9IG9wdHMgfHwge1xuICAgICAgICBjbG9uZURhdGE6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAoIWV2ZW50TmFtZSkgcmV0dXJuO1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc2V0dGluZ3MuaXNKUXVlcnlQbHVnaW4pIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSAncmVtb3ZlJykgZXZlbnROYW1lID0gJ3JlbW92ZVRhZyc7IC8vIGlzc3VlICMyMjJcblxuICAgICAgICBqUXVlcnkoaW5zdGFuY2UuRE9NLm9yaWdpbmFsSW5wdXQpLnRyaWdnZXJIYW5kbGVyKGV2ZW50TmFtZSwgW2RhdGFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiB7XG4gICAgICAgICAgICB2YWx1ZTogZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgZXZlbnREYXRhID0gb3B0cy5jbG9uZURhdGEgPyBleHRlbmQoe30sIGV2ZW50RGF0YSkgOiBldmVudERhdGE7XG4gICAgICAgICAgZXZlbnREYXRhLnRhZ2lmeSA9IHRoaXM7IC8vIFRPRE86IG1vdmUgdGhlIGJlbG93IHRvIHRoZSBcImV4dGVuZFwiIGZ1bmN0aW9uXG5cbiAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkgZm9yICh2YXIgcHJvcCBpbiBkYXRhKSBpZiAoZGF0YVtwcm9wXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBldmVudERhdGFbcHJvcF0gPSBkYXRhW3Byb3BdO1xuICAgICAgICAgIGUgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7XG4gICAgICAgICAgICBcImRldGFpbFwiOiBldmVudERhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcbn1cblxudmFyIGRlbGV0ZUJhY2tzcGFjZVRpbWVvdXQ7XG5mdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlRXZlbnQoKSB7XG4gIGlmICh0aGlzLnNldHRpbmdzLm1peE1vZGUuaW50ZWdyYXRlZCkgcmV0dXJuO1xuICB2YXIgaW5wdXRFbG0gPSB0aGlzLkRPTS5vcmlnaW5hbElucHV0LFxuICAgICAgY2hhbmdlZCA9IHRoaXMuc3RhdGUubGFzdE9yaWdpbmFsVmFsdWVSZXBvcnRlZCAhPT0gaW5wdXRFbG0udmFsdWUsXG4gICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChcImNoYW5nZVwiLCB7XG4gICAgYnViYmxlczogdHJ1ZVxuICB9KTsgLy8gbXVzdCB1c2UgXCJDdXN0b21FdmVudFwiIGFuZCBub3QgXCJFdmVudFwiIHRvIHN1cHBvcnQgSUVcblxuICBpZiAoIWNoYW5nZWQpIHJldHVybjsgLy8gbXVzdCBhcHBseSB0aGlzIEJFRk9SRSB0cmlnZ2VyaW5nIHRoZSBzaW11bGF0ZWQgZXZlbnRcblxuICB0aGlzLnN0YXRlLmxhc3RPcmlnaW5hbFZhbHVlUmVwb3J0ZWQgPSBpbnB1dEVsbS52YWx1ZTsgLy8gUmVhY3QgaGFjazogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTQ4OFxuXG4gIGV2ZW50LnNpbXVsYXRlZCA9IHRydWU7XG4gIGlmIChpbnB1dEVsbS5fdmFsdWVUcmFja2VyKSBpbnB1dEVsbS5fdmFsdWVUcmFja2VyLnNldFZhbHVlKE1hdGgucmFuZG9tKCkpO1xuICBpbnB1dEVsbS5kaXNwYXRjaEV2ZW50KGV2ZW50KTsgLy8gYWxzbyB0cmlnZ2VyIGEgVGFnaWZ5IGV2ZW50XG5cbiAgdGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsIHRoaXMuc3RhdGUubGFzdE9yaWdpbmFsVmFsdWVSZXBvcnRlZCk7IC8vIFJlYWN0LCBmb3Igc29tZSByZWFzb24sIGNsZWFycyB0aGUgaW5wdXQncyB2YWx1ZSBhZnRlciBcImRpc3BhdGNoRXZlbnRcIiBpcyBmaXJlZFxuXG4gIGlucHV0RWxtLnZhbHVlID0gdGhpcy5zdGF0ZS5sYXN0T3JpZ2luYWxWYWx1ZVJlcG9ydGVkO1xufVxudmFyIGV2ZW50cyA9IHtcbiAgLy8gYmluZCBjdXN0b20gZXZlbnRzIHdoaWNoIHdlcmUgcGFzc2VkIGluIHRoZSBzZXR0aW5nc1xuICBjdXN0b21CaW5kaW5nKCkge1xuICAgIHRoaXMuY3VzdG9tRXZlbnRzTGlzdC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgdGhpcy5vbihuYW1lLCB0aGlzLnNldHRpbmdzLmNhbGxiYWNrc1tuYW1lXSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgYmluZGluZyhiaW5kVW5iaW5kID0gdHJ1ZSkge1xuICAgIHZhciBfQ0IgPSB0aGlzLmV2ZW50cy5jYWxsYmFja3MsXG4gICAgICAgIF9DQlIsXG4gICAgICAgIGFjdGlvbiA9IGJpbmRVbmJpbmQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7IC8vIGRvIG5vdCBhbGxvdyB0aGUgbWFpbiBldmVudHMgdG8gYmUgYm91bmQgbW9yZSB0aGFuIG9uY2VcblxuXG4gICAgaWYgKHRoaXMuc3RhdGUubWFpbkV2ZW50cyAmJiBiaW5kVW5iaW5kKSByZXR1cm47IC8vIHNldCB0aGUgYmluZGluZyBzdGF0ZSBvZiB0aGUgbWFpbiBldmVudHMsIHNvIHRoZXkgd2lsbCBub3QgYmUgYm91bmQgbW9yZSB0aGFuIG9uY2VcblxuICAgIHRoaXMuc3RhdGUubWFpbkV2ZW50cyA9IGJpbmRVbmJpbmQ7IC8vIGV2ZXJ5dGhpbmcgaW5zaWRlIGdldHMgZXhlY3V0ZWQgb25seSBvbmNlLXBlciBpbnN0YW5jZVxuXG4gICAgaWYgKGJpbmRVbmJpbmQgJiYgIXRoaXMubGlzdGVuZXJzLm1haW4pIHtcbiAgICAgIHRoaXMuZXZlbnRzLmJpbmRHbG9iYWwuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmlzSlF1ZXJ5UGx1Z2luKSBqUXVlcnkodGhpcy5ET00ub3JpZ2luYWxJbnB1dCkub24oJ3RhZ2lmeS5yZW1vdmVBbGxUYWdzJywgdGhpcy5yZW1vdmVBbGxUYWdzLmJpbmQodGhpcykpO1xuICAgIH0gLy8gc2V0dXAgY2FsbGJhY2sgcmVmZXJlbmNlcyBzbyBldmVudHMgY291bGQgYmUgcmVtb3ZlZCBsYXRlclxuXG5cbiAgICBfQ0JSID0gdGhpcy5saXN0ZW5lcnMubWFpbiA9IHRoaXMubGlzdGVuZXJzLm1haW4gfHwge1xuICAgICAgZm9jdXM6IFsnaW5wdXQnLCBfQ0Iub25Gb2N1c0JsdXIuYmluZCh0aGlzKV0sXG4gICAgICBrZXlkb3duOiBbJ2lucHV0JywgX0NCLm9uS2V5ZG93bi5iaW5kKHRoaXMpXSxcbiAgICAgIGNsaWNrOiBbJ3Njb3BlJywgX0NCLm9uQ2xpY2tTY29wZS5iaW5kKHRoaXMpXSxcbiAgICAgIGRibGNsaWNrOiBbJ3Njb3BlJywgX0NCLm9uRG91YmxlQ2xpY2tTY29wZS5iaW5kKHRoaXMpXSxcbiAgICAgIHBhc3RlOiBbJ2lucHV0JywgX0NCLm9uUGFzdGUuYmluZCh0aGlzKV0sXG4gICAgICBkcm9wOiBbJ2lucHV0JywgX0NCLm9uRHJvcC5iaW5kKHRoaXMpXVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gX0NCUikge1xuICAgICAgdGhpcy5ET01bX0NCUltldmVudE5hbWVdWzBdXVthY3Rpb25dKGV2ZW50TmFtZSwgX0NCUltldmVudE5hbWVdWzFdKTtcbiAgICB9IC8vIGxpc3RlbiB0byBvcmlnaW5hbCBpbnB1dCBjaGFuZ2VzICh1bmZvcnR1bmV0bHkgdGhpcyBpcyB0aGUgYmVzdCB3YXkuLi4pXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NDk0MTYvMTA0MzgwXG5cblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5saXN0ZW5lcnMubWFpbi5vcmlnaW5hbElucHV0VmFsdWVPYnNlcnZlckludGVydmFsKTtcbiAgICB0aGlzLmxpc3RlbmVycy5tYWluLm9yaWdpbmFsSW5wdXRWYWx1ZU9ic2VydmVySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChfQ0Iub2JzZXJ2ZU9yaWdpbmFsSW5wdXRWYWx1ZS5iaW5kKHRoaXMpLCA1MDApOyAvLyBvYnNlcnZlcnNcblxuICAgIHZhciBpbnB1dE11dGF0aW9uT2JzZXJ2ZXIgPSB0aGlzLmxpc3RlbmVycy5tYWluLmlucHV0TXV0YXRpb25PYnNlcnZlciB8fCBuZXcgTXV0YXRpb25PYnNlcnZlcihfQ0Iub25JbnB1dERPTUNoYW5nZS5iaW5kKHRoaXMpKTsgLy8gY2xlYXVwIGp1c3QtaW4tY2FzZVxuXG4gICAgaWYgKGlucHV0TXV0YXRpb25PYnNlcnZlcikgaW5wdXRNdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTsgLy8gb2JzZXJ2ZSBzdHVmZlxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubW9kZSA9PSAnbWl4JykgaW5wdXRNdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5ET00uaW5wdXQsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgIH0pO1xuICB9LFxuXG4gIGJpbmRHbG9iYWwodW5iaW5kKSB7XG4gICAgdmFyIF9DQiA9IHRoaXMuZXZlbnRzLmNhbGxiYWNrcyxcbiAgICAgICAgYWN0aW9uID0gdW5iaW5kID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2FkZEV2ZW50TGlzdGVuZXInLFxuICAgICAgICBlO1xuICAgIGlmICghdW5iaW5kICYmIHRoaXMubGlzdGVuZXJzLmdsb2JhbCkgcmV0dXJuOyAvLyBkbyBub3QgcmUtYmluZFxuICAgIC8vIHRoZXNlIGV2ZW50cyBhcmUgZ2xvYmFsIGV2ZW50IHNob3VsZCBuZXZlciBiZSB1bmJpbmRlZCwgdW5sZXNzIHRoZSBpbnN0YW5jZSBpcyBkZXN0cm95ZWQ6XG5cbiAgICB0aGlzLmxpc3RlbmVycy5nbG9iYWwgPSB0aGlzLmxpc3RlbmVycyAmJiB0aGlzLmxpc3RlbmVycy5nbG9iYWwgfHwgW3tcbiAgICAgIHR5cGU6IHRoaXMuaXNJRSA/ICdrZXlkb3duJyA6ICdpbnB1dCcsXG4gICAgICAvLyBJRSBjYW5ub3QgcmVnaXN0ZXIgXCJpbnB1dFwiIGV2ZW50cyBvbiBjb250ZW50ZWRpdGFibGUgZWxlbWVudHMsIHNvIHRoZSBcImtleWRvd25cIiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLi5cbiAgICAgIHRhcmdldDogdGhpcy5ET00uaW5wdXQsXG4gICAgICBjYjogX0NCW3RoaXMuaXNJRSA/ICdvbklucHV0SUUnIDogJ29uSW5wdXQnXS5iaW5kKHRoaXMpXG4gICAgfSwge1xuICAgICAgdHlwZTogJ2tleWRvd24nLFxuICAgICAgdGFyZ2V0OiB3aW5kb3csXG4gICAgICBjYjogX0NCLm9uV2luZG93S2V5RG93bi5iaW5kKHRoaXMpXG4gICAgfSwge1xuICAgICAgdHlwZTogJ2JsdXInLFxuICAgICAgdGFyZ2V0OiB0aGlzLkRPTS5pbnB1dCxcbiAgICAgIGNiOiBfQ0Iub25Gb2N1c0JsdXIuYmluZCh0aGlzKVxuICAgIH1dO1xuXG4gICAgZm9yIChlIG9mIHRoaXMubGlzdGVuZXJzLmdsb2JhbCkgZS50YXJnZXRbYWN0aW9uXShlLnR5cGUsIGUuY2IpO1xuICB9LFxuXG4gIHVuYmluZEdsb2JhbCgpIHtcbiAgICB0aGlzLmV2ZW50cy5iaW5kR2xvYmFsLmNhbGwodGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRE9NIGV2ZW50cyBjYWxsYmFja3NcclxuICAgKi9cbiAgY2FsbGJhY2tzOiB7XG4gICAgb25Gb2N1c0JsdXIoZSkge1xuICAgICAgdmFyIHRleHQgPSBlLnRhcmdldCA/IHRoaXMudHJpbShlLnRhcmdldC50ZXh0Q29udGVudCkgOiAnJyxcbiAgICAgICAgICAvLyBhIHN0cmluZ1xuICAgICAgX3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgIHR5cGUgPSBlLnR5cGUsXG4gICAgICAgICAgZGRFbmFibGVkID0gX3MuZHJvcGRvd24uZW5hYmxlZCA+PSAwLFxuICAgICAgICAgIGV2ZW50RGF0YSA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogZS5yZWxhdGVkVGFyZ2V0XG4gICAgICB9LFxuICAgICAgICAgIGlzVGFyZ2V0U2VsZWN0T3B0aW9uID0gdGhpcy5zdGF0ZS5hY3Rpb25zLnNlbGVjdE9wdGlvbiAmJiAoZGRFbmFibGVkIHx8ICFfcy5kcm9wZG93bi5jbG9zZU9uU2VsZWN0KSxcbiAgICAgICAgICBpc1RhcmdldEFkZE5ld0J0biA9IHRoaXMuc3RhdGUuYWN0aW9ucy5hZGROZXcgJiYgZGRFbmFibGVkLFxuICAgICAgICAgIGlzUmVsYXRlZFRhcmdldFggPSBlLnJlbGF0ZWRUYXJnZXQgJiYgaXNOb2RlVGFnLmNhbGwodGhpcywgZS5yZWxhdGVkVGFyZ2V0KSAmJiB0aGlzLkRPTS5zY29wZS5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpLFxuICAgICAgICAgIHNob3VsZEFkZFRhZ3M7XG5cbiAgICAgIGlmICh0eXBlID09ICdibHVyJykge1xuICAgICAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ID09PSB0aGlzLkRPTS5zY29wZSkge1xuICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgIHRoaXMuRE9NLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3N0VXBkYXRlKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZUV2ZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1RhcmdldFNlbGVjdE9wdGlvbiB8fCBpc1RhcmdldEFkZE5ld0J0bikgcmV0dXJuO1xuICAgICAgdGhpcy5zdGF0ZS5oYXNGb2N1cyA9IHR5cGUgPT0gXCJmb2N1c1wiID8gK25ldyBEYXRlKCkgOiBmYWxzZTtcbiAgICAgIHRoaXMudG9nZ2xlRm9jdXNDbGFzcyh0aGlzLnN0YXRlLmhhc0ZvY3VzKTtcblxuICAgICAgaWYgKF9zLm1vZGUgPT0gJ21peCcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZm9jdXNcIiwgZXZlbnREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gXCJibHVyXCIpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJibHVyXCIsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgdGhpcy5sb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmRyb3Bkb3duLmhpZGUoKTsgLy8gcmVzZXQgc3RhdGUgd2hpY2ggbmVlZHMgcmVzZXRpbmdcblxuICAgICAgICAgIHRoaXMuc3RhdGUuZHJvcGRvd24udmlzaWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09IFwiZm9jdXNcIikge1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJmb2N1c1wiLCBldmVudERhdGEpOyAvLyAgZS50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgncGxhY2Vob2xkZXInKTtcblxuICAgICAgICBpZiAoX3MuZHJvcGRvd24uZW5hYmxlZCA9PT0gMCB8fCAhX3MudXNlcklucHV0KSB7XG4gICAgICAgICAgLy8gJiYgX3MubW9kZSAhPSBcInNlbGVjdFwiXG4gICAgICAgICAgdGhpcy5kcm9wZG93bi5zaG93KHRoaXMudmFsdWUubGVuZ3RoID8gJycgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiYmx1clwiKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcImJsdXJcIiwgZXZlbnREYXRhKTtcbiAgICAgICAgdGhpcy5sb2FkaW5nKGZhbHNlKTsgLy8gd2hlbiBjbGlja2luZyB0aGUgWCBidXR0b24gb2YgYSBzZWxlY3RlZCB0YWcsIGl0IGlzIHVud2FudGVkIGl0IHdpbGwgYmUgYWRkZWQgYmFja1xuICAgICAgICAvLyBhZ2FpbiBpbiBhIGZldyBtb3JlIGxpbmVzIG9mIGNvZGUgKHNob3VsZEFkZFRhZ3MgJiYgYWRkVGFncylcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2RlID09ICdzZWxlY3QnICYmIGlzUmVsYXRlZFRhcmdldFgpIHRleHQgPSAnJztcbiAgICAgICAgc2hvdWxkQWRkVGFncyA9IHRoaXMuc2V0dGluZ3MubW9kZSA9PSAnc2VsZWN0JyAmJiB0ZXh0ID8gIXRoaXMudmFsdWUubGVuZ3RoIHx8IHRoaXMudmFsdWVbMF0udmFsdWUgIT0gdGV4dCA6IHRleHQgJiYgIXRoaXMuc3RhdGUuYWN0aW9ucy5zZWxlY3RPcHRpb24gJiYgX3MuYWRkVGFnT25CbHVyOyAvLyBkbyBub3QgYWRkIGEgdGFnIGlmIFwic2VsZWN0T3B0aW9uXCIgYWN0aW9uIHdhcyBqdXN0IGZpcmVkICh0aGlzIG1lYW5zIGEgdGFnIHdhcyBqdXN0IGFkZGVkIGZyb20gdGhlIGRyb3Bkb3duKVxuXG4gICAgICAgIHNob3VsZEFkZFRhZ3MgJiYgdGhpcy5hZGRUYWdzKHRleHQsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2RlID09ICdzZWxlY3QnICYmICF0ZXh0KSB0aGlzLnJlbW92ZVRhZ3MoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ET00uaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7XG4gICAgfSxcblxuICAgIG9uV2luZG93S2V5RG93bihlKSB7XG4gICAgICB2YXIgZm9jdXNlZEVsbSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgaXNUYWcgPSBpc05vZGVUYWcuY2FsbCh0aGlzLCBmb2N1c2VkRWxtKSxcbiAgICAgICAgICBpc0JlbG9uZyA9IGlzVGFnICYmIHRoaXMuRE9NLnNjb3BlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLFxuICAgICAgICAgIG5leHRUYWc7XG4gICAgICBpZiAoIWlzQmVsb25nKSByZXR1cm47XG4gICAgICBuZXh0VGFnID0gZm9jdXNlZEVsbS5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRhZyBpZiBoYXMgZm9jdXNcbiAgICAgICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ3MoZm9jdXNlZEVsbSk7XG4gICAgICAgICAgICAobmV4dFRhZyA/IG5leHRUYWcgOiB0aGlzLkRPTS5pbnB1dCkuZm9jdXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gZWRpdCB0YWcgaWYgaGFzIGZvY3VzXG5cbiAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5lZGl0VGFnLmJpbmQodGhpcyksIDAsIGZvY3VzZWRFbG0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbktleWRvd24oZSkge1xuICAgICAgdmFyIF9zID0gdGhpcy5zZXR0aW5ncztcblxuICAgICAgaWYgKF9zLm1vZGUgPT0gJ3NlbGVjdCcgJiYgX3MuZW5mb3JjZVdoaXRlbGlzdCAmJiB0aGlzLnZhbHVlLmxlbmd0aCAmJiBlLmtleSAhPSAnVGFiJykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzID0gdGhpcy50cmltKGUudGFyZ2V0LnRleHRDb250ZW50KTtcbiAgICAgIHRoaXMudHJpZ2dlcihcImtleWRvd25cIiwge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiB0aGlzLmNsb25lRXZlbnQoZSlcbiAgICAgIH0pO1xuICAgICAgLyoqXHJcbiAgICAgICAqIE9OTFkgRk9SIE1JWC1NT0RFOlxyXG4gICAgICAgKi9cblxuICAgICAgaWYgKF9zLm1vZGUgPT0gJ21peCcpIHtcbiAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgIGNhc2UgJ0xlZnQnOlxuICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIHdoZW4gbGVmdCBhcnJvdyB3YXMgcHJlc3NlZCwgc2V0IGEgZmxhZyBzbyB3aGVuIHRoZSBkcm9wZG93biBpcyBzaG93biwgcmlnaHQtYXJyb3cgd2lsbCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgc2VlbXMgbGlrZWx5IHRoZSB1c2VyIHdpc2hlcyB0byB1c2UgdGhlIGFycm93cyB0byBtb3ZlIHRoZSBjYXJldFxuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmFjdGlvbnMuQXJyb3dMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdEZWxldGUnOlxuICAgICAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmVkaXRpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgdmFyIHNlbCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5VGFnRGV0ZWN0ZWQgPSBlLmtleSA9PSAnRGVsZXRlJyAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IChzZWwuYW5jaG9yTm9kZS5sZW5ndGggfHwgMCksXG4gICAgICAgICAgICAgICAgICBwcmV2QW5jaG9yU2libGluZyA9IHNlbC5hbmNob3JOb2RlLnByZXZpb3VzU2libGluZyxcbiAgICAgICAgICAgICAgICAgIGlzQ2FyZXRBZnRlclRhZyA9IHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDEgfHwgIXNlbC5hbmNob3JPZmZzZXQgJiYgcHJldkFuY2hvclNpYmxpbmcgJiYgcHJldkFuY2hvclNpYmxpbmcubm9kZVR5cGUgPT0gMSAmJiBzZWwuYW5jaG9yTm9kZS5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZSA9IGRlY29kZSh0aGlzLkRPTS5pbnB1dC5pbm5lckhUTUwpLFxuICAgICAgICAgICAgICAgICAgbGFzdFRhZ0VsZW1zID0gdGhpcy5nZXRUYWdFbG1zKCksXG4gICAgICAgICAgICAgICAgICAvLyAgaXNDYXJldEluc2lkZVRhZyA9IHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUoJy4nICsgX3MuY2xhc3NOYW1lcy50YWcpLFxuICAgICAgICAgICAgICB0YWdCZWZvcmVDYXJldCxcbiAgICAgICAgICAgICAgICAgIHRhZ0VsbVRvQmVEZWxldGVkLFxuICAgICAgICAgICAgICAgICAgZmlyc3RUZXh0Tm9kZUJlZm9yZVRhZztcblxuICAgICAgICAgICAgICBpZiAoX3MuYmFja3NwYWNlID09ICdlZGl0JyAmJiBpc0NhcmV0QWZ0ZXJUYWcpIHtcbiAgICAgICAgICAgICAgICB0YWdCZWZvcmVDYXJldCA9IHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDEgPyBudWxsIDogc2VsLmFuY2hvck5vZGUucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZWRpdFRhZy5iaW5kKHRoaXMpLCAwLCB0YWdCZWZvcmVDYXJldCk7IC8vIHRpbWVvdXQgaXMgbmVlZGVkIHRvIHRoZSBsYXN0IGNhaGFjcnRlciBpbiB0aGUgZWRpdGVkIHRhZyB3b24ndCBnZXQgZGVsZXRlZFxuXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBuZWVkZWQgc28gdGhlIHRhZyBlbG0gd29uJ3QgZ2V0IGRlbGV0ZWRcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpc0Nocm9tZUFuZHJvaWRCcm93c2VyKCkgJiYgaXNDYXJldEFmdGVyVGFnKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RUZXh0Tm9kZUJlZm9yZVRhZyA9IGdldGZpcnN0VGV4dE5vZGUoaXNDYXJldEFmdGVyVGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FyZXRBZnRlclRhZy5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykpIGlzQ2FyZXRBZnRlclRhZy5yZW1vdmUoKTsgLy8gc2luY2UgdGhpcyBpcyBDaHJvbWUsIGNhbiBzYWZldGx5IHVzZSB0aGlzIFwibmV3XCIgRE9NIEFQSVxuICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQtQ2hyb21lIHdyb25nbHkgaGlkZXMgdGhlIGtleWJvYXJkLCBhbmQgbG9zZXMgZm9jdXMsXG4gICAgICAgICAgICAgICAgLy8gc28gdGhpcyBoYWNrIGJlbG93IGlzIG5lZWRlZCB0byByZWdhaW4gZm9jdXMgYXQgdGhlIGNvcnJlY3QgcGxhY2U6XG5cbiAgICAgICAgICAgICAgICB0aGlzLkRPTS5pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZUNhcmV0QWZ0ZXJOb2RlKGZpcnN0VGV4dE5vZGVCZWZvcmVUYWcpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5ET00uaW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoc2VsLmFuY2hvck5vZGUubm9kZU5hbWUgPT0gJ0JSJykgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAoKGRlbGV0ZUtleVRhZ0RldGVjdGVkIHx8IGlzQ2FyZXRBZnRlclRhZykgJiYgc2VsLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWwuYW5jaG9yT2Zmc2V0ID09IDApIC8vIGNhcmV0IGlzIGF0IHRoZSB2ZXJ5IGJlZ2luaW5nLCBiZWZvcmUgYSB0YWdcbiAgICAgICAgICAgICAgICAgIHRhZ0VsbVRvQmVEZWxldGVkID0gZGVsZXRlS2V5VGFnRGV0ZWN0ZWQgLy8gZGVsZXRlIGtleSBwcmVzc2VkXG4gICAgICAgICAgICAgICAgICA/IGxhc3RUYWdFbGVtc1swXSA6IG51bGw7ZWxzZSB0YWdFbG1Ub0JlRGVsZXRlZCA9IGxhc3RUYWdFbGVtc1tzZWwuYW5jaG9yT2Zmc2V0IC0gMV07IC8vIGZpbmQgb3V0IGlmIGEgdGFnICptaWdodCogYmUgYSBjYW5kaWRhdGUgZm9yIGRlbGV0aW9uLCBhbmQgaWYgc28sIHdoaWNoXG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWxldGVLZXlUYWdEZXRlY3RlZCkgdGFnRWxtVG9CZURlbGV0ZWQgPSBzZWwuYW5jaG9yTm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7ZWxzZSBpZiAoaXNDYXJldEFmdGVyVGFnKSB0YWdFbG1Ub0JlRGVsZXRlZCA9IGlzQ2FyZXRBZnRlclRhZzsgLy8gdGFnRWxtLmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKVxuXG4gICAgICAgICAgICAgIGlmIChzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzICYmIC8vIG5vZGUgYXQgY2FyZXQgbG9jYXRpb24gaXMgYSBUZXh0IG5vZGVcbiAgICAgICAgICAgICAgIXNlbC5hbmNob3JOb2RlLm5vZGVWYWx1ZSAmJiAvLyBoYXMgc29tZSB0ZXh0XG4gICAgICAgICAgICAgIHNlbC5hbmNob3JOb2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIC8vIHRleHQgbm9kZSBoYXMgYSBUYWcgbm9kZSBiZWZvcmUgaXRcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIGJhY2tzcGFjZSBub3QgYWxsb3dlZCwgZG8gbm90aGluZ1xuICAgICAgICAgICAgICAvLyBUT0RPOiBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IGlmIG5vZGVzIHdlcmUgZGVsZXRlZCBpcyB0byBzaW1wbHkgY2hlY2sgdGhlIFwidGhpcy52YWx1ZVwiIGJlZm9yZSAmIGFmdGVyXG5cbiAgICAgICAgICAgICAgaWYgKChpc0NhcmV0QWZ0ZXJUYWcgfHwgZGVsZXRlS2V5VGFnRGV0ZWN0ZWQpICYmICFfcy5iYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNlbC50eXBlICE9ICdSYW5nZScgJiYgIXNlbC5hbmNob3JPZmZzZXQgJiYgc2VsLmFuY2hvck5vZGUgPT0gdGhpcy5ET00uaW5wdXQgJiYgZS5rZXkgIT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNlbC50eXBlICE9ICdSYW5nZScgJiYgdGFnRWxtVG9CZURlbGV0ZWQgJiYgdGFnRWxtVG9CZURlbGV0ZWQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpKSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb250aW51YXRpb24gb2YgZGVsZXRpb24gYnkgcGxhY2luZyB0aGUgY2FyZXQgb24gdGhlIGZpcnN0IHByZXZpb3VzIHRleHROb2RlLlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGEgZmV3IHJlYWRvbmx5LXRhZ3MgbWlnaHQgYmUgb25lIGFmdGVyIHRoZSBvdGhlciwgaXRlcmF0aW9uIGlzIG5lZWRlZDpcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlQ2FyZXRBZnRlck5vZGUoZ2V0Zmlyc3RUZXh0Tm9kZSh0YWdFbG1Ub0JlRGVsZXRlZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSAvLyB1cGRhdGUgcmVnYXJkaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS95YWlyRU8vdGFnaWZ5L2lzc3Vlcy83NjIjaXNzdWVjb21tZW50LTc4NjQ2NDMxNzpcbiAgICAgICAgICAgICAgLy8gdGhlIGJ1ZyBkZXNjcmliZWQgaXMgbW9yZSBzZXZlcmUgdGhhbiB0aGUgZml4IGJlbG93LCB0aGVyZWZvcmUgSSBkaXNhYmxlIHRoZSBmaXggdW50aWwgYSBzb2x1dGlvblxuICAgICAgICAgICAgICAvLyBpcyBmb3VuZCB3aGljaCB3b3JrIHdlbGwgZm9yIGJvdGggY2FzZXMuXG4gICAgICAgICAgICAgIC8vIC0tLS0tLS1cbiAgICAgICAgICAgICAgLy8gbm9kZVR5cGUgaXMgXCIxXCIgb25seSB3aGVuIHRoZSBjYXJldCBpcyBhdCB0aGUgZW5kIGFmdGVyIGxhc3QgdGFnIChubyB0ZXh0IGFmdGVyKSwgb3IgYmVmb3JlIGZpcnN0IGZpcnN0IChubyB0ZXh0IGJlZm9yZSlcblxuICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgIGlmKCB0aGlzLmlzRmlyZWZveCAmJiBzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAxICYmIHNlbC5hbmNob3JPZmZzZXQgIT0gMCApe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ3MoKSAvLyByZW1vdmVzIGxhc3QgdGFnIGJ5IGRlZmF1bHQgaWYgbm8gcGFyYW1ldGVyIHN1cHBsaWVkXHJcbiAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGluc2lkZSBsYXN0IHRleHROb2RlLCBpZiBleGlzdC4gaXQncyBhbiBhbm5veWluZyBidWcgb25seSBpbiBGRixcclxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhc3QgdGFnIGlzIHJlbW92ZWQsIGFuZCB0aGVyZSBpcyBhIHRleHROb2RlIGJlZm9yZSBpdCwgdGhlIGNhcmV0IGlzIG5vdCBwbGFjZWQgYXQgaXRzIGVuZFxyXG4gICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlQ2FyZXRBZnRlck5vZGUoIHRoaXMuc2V0UmFuZ2VBdFN0YXJ0RW5kKCkgKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlbGV0ZUJhY2tzcGFjZVRpbWVvdXQpOyAvLyBhIG1pbmltdW0gZGVsYXkgaXMgbmVlZGVkIGJlZm9yZSB0aGUgbm9kZSBhY3R1YWxseSBnZXRzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50IChkb24ndCBrbm93IHdoeSksXG4gICAgICAgICAgICAgIC8vIHRvIGtub3cgZXhhY3RseSB3aGljaCB0YWcgd2FzIGRlbGV0ZWQuIFRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IG9mIGtub3dpbmcgYmVzaWRlcyB1c2luZyBNdXRhdGlvbk9ic2VydmVyXG5cbiAgICAgICAgICAgICAgZGVsZXRlQmFja3NwYWNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBzZWwgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gZGVjb2RlKHRoaXMuRE9NLmlucHV0LmlubmVySFRNTCksXG4gICAgICAgICAgICAgICAgICAgIHByZXZFbG0gPSAhZGVsZXRlS2V5VGFnRGV0ZWN0ZWQgJiYgc2VsLmFuY2hvck5vZGUucHJldmlvdXNTaWJsaW5nOyAvLyBmaXhlcyAjMzg0LCB3aGVyZSB0aGUgZmlyc3QgYW5kIG9ubHkgdGFnIHdpbGwgbm90IGdldCByZW1vdmVkIHdpdGggYmFja3NwYWNlXG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlLmxlbmd0aCA+PSBsYXN0SW5wdXRWYWx1ZS5sZW5ndGggJiYgcHJldkVsbSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZVRhZy5jYWxsKHRoaXMsIHByZXZFbG0pICYmICFwcmV2RWxtLmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ3MocHJldkVsbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4RmlyZWZveExhc3RUYWdOb0NhcmV0KCk7IC8vIHRoZSBhYm92ZSBcInJlbW92ZVRhZ1wiIG1ldGhvZHMgcmVtb3ZlcyB0aGUgdGFnIHdpdGggYSB0cmFuc2l0aW9uLiBDaHJvbWUgYWRkcyBhIDxicj4gZWxlbWVudCBmb3Igc29tZSByZWFzb24gYXQgdGhpcyBzdGFnZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkRPTS5pbnB1dC5jaGlsZHJlbi5sZW5ndGggPT0gMiAmJiB0aGlzLkRPTS5pbnB1dC5jaGlsZHJlblsxXS50YWdOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRE9NLmlucHV0LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgcHJldkVsbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9IC8vIGZpbmQgb3V0IHdoaWNoIHRhZyhzKSB3ZXJlIGRlbGV0ZWQgYW5kIHRyaWdnZXIgXCJyZW1vdmVcIiBldmVudFxuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgbGlzdCBvZiB0YWdzIHN0aWxsIGluIHRoZSBkb2N1bWVudCBhbmQgdGhlbiBmaWx0ZXIgb25seSB0aG9zZSBmcm9tIHRoZSBcInRoaXMudmFsdWVcIiBjb2xsZWN0aW9uXG5cblxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXS5tYXAuY2FsbChsYXN0VGFnRWxlbXMsIChub2RlLCBub2RlSWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFnRGF0YSA9IHRoaXMudGFnRGF0YShub2RlKTsgLy8gc2luY2UgcmVhZG9ubHkgY2Fubm90IGJlIHJlbW92ZWQgKGl0J3MgdGVjaG5pY2FsbHkgcmVzdXJyZWN0ZWQgaWYgcmVtb3ZlZCBzb21laG93KVxuXG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlIHx8IHRhZ0RhdGEucmVhZG9ubHkpIHJldHVybiB0YWdEYXRhO2Vsc2UgdGhpcy50cmlnZ2VyKCdyZW1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG5vZGVJZHgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhZ0RhdGFcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihuID0+IG4pOyAvLyByZW1vdmUgZW1wdHkgaXRlbXMgaW4gdGhlIG1hcHBlZCBhcnJheVxuICAgICAgICAgICAgICB9LCAyMCk7IC8vIEZpcmVmb3ggbmVlZHMgdGhpcyBoaWdoZXIgZHVyYXRpb24gZm9yIHNvbWUgcmVhc29uIG9yIHRoaW5ncyBnZXQgYnVnZ3kgd2hlbiBkZWxldGluZyB0ZXh0IGZyb20gdGhlIGVuZFxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGN1cnJlbnRseSBjb21tZW50ZWQgdG8gYWxsb3cgbmV3IGxpbmVzIGluIG1peGVkLW1vZGVcbiAgICAgICAgICAvLyBjYXNlICdFbnRlcicgOlxuICAgICAgICAgIC8vICAgICAvLyBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHNvbHZlcyBDaHJvbWUgYnVnIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAzOTgxOTEvMTA0MzgwXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgICAgIGlmIChfcy5tb2RlID09ICdzZWxlY3QnICYmIF9zLmVuZm9yY2VXaGl0ZWxpc3QgJiYgdGhpcy52YWx1ZS5sZW5ndGgpIHRoaXMucmVtb3ZlVGFncygpO2Vsc2UgaWYgKCF0aGlzLnN0YXRlLmRyb3Bkb3duLnZpc2libGUgfHwgX3MuZHJvcGRvd24ucG9zaXRpb24gPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC50ZXh0Q29udGVudCA9PSBcIlwiIHx8IHMuY2hhckNvZGVBdCgwKSA9PSA4MjAzKSB7XG4gICAgICAgICAgICAgIC8vIDgyMDM6IFpFUk8gV0lEVEggU1BBQ0UgdW5pY29kZVxuICAgICAgICAgICAgICBpZiAoX3MuYmFja3NwYWNlID09PSB0cnVlKSB0aGlzLnJlbW92ZVRhZ3MoKTtlbHNlIGlmIChfcy5iYWNrc3BhY2UgPT0gJ2VkaXQnKSBzZXRUaW1lb3V0KHRoaXMuZWRpdFRhZy5iaW5kKHRoaXMpLCAwKTsgLy8gdGltZW91dCByZWFzb246IHdoZW4gZWRpdGVkIHRhZyBnZXRzIGZvY3VzZWQgYW5kIHRoZSBjYXJldCBpcyBwbGFjZWQgYXQgdGhlIGVuZCwgdGhlIGxhc3QgY2hhcmFjdGVyIGdldHMgZGVsZXRlYyAoYmVjYXVzZSBvZiBiYWNrc3BhY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0VzYyc6XG4gICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZHJvcGRvd24udmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICAgIGUudGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAvLyBpZiggX3MubW9kZSA9PSAnc2VsZWN0JyApIC8vIGlzc3VlICMzMzNcbiAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZHJvcGRvd24udmlzaWJsZSkgdGhpcy5kcm9wZG93bi5zaG93KCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IHRhZ0RhdGEgPSB0aGlzLnN0YXRlLmlucHV0U3VnZ2VzdGlvbiB8fCB0aGlzLnN0YXRlLmRkSXRlbURhdGE7XG5cbiAgICAgICAgICAgIGlmICh0YWdEYXRhICYmIF9zLmF1dG9Db21wbGV0ZS5yaWdodEtleSkge1xuICAgICAgICAgICAgICB0aGlzLmFkZFRhZ3MoW3RhZ0RhdGFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0TW9kZSA9IF9zLm1vZGUgPT0gJ3NlbGVjdCc7XG4gICAgICAgICAgICBpZiAocyAmJiAhc2VsZWN0TW9kZSkgZS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kcm9wZG93bi52aXNpYmxlIHx8IGUua2V5Q29kZSA9PSAyMjkpIHJldHVybjtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHNvbHZlcyBDaHJvbWUgYnVnIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAzOTgxOTEvMTA0MzgwXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGUgbWFpbiBcImtleWRvd25cIiBldmVudCBpcyBib3VuZCBiZWZvcmUgdGhlIGRyb3Bkb3duIGV2ZW50cywgdGhpcyB3aWxsIGZpcmUgZmlyc3QgYW5kIHdpbGwgbm90ICp5ZXQqXG4gICAgICAgICAgLy8ga25vdyBpZiBhbiBvcHRpb24gd2FzIGp1c3Qgc2VsZWN0ZWQgZnJvbSB0aGUgZHJvcGRvd24gbWVudS4gSWYgYW4gb3B0aW9uIHdhcyBzZWxlY3RlZCxcbiAgICAgICAgICAvLyB0aGUgZHJvcGRvd24gZXZlbnRzIHNob3VsZCBoYW5kbGUgYWRkaW5nIHRoZSB0YWdcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuYWN0aW9ucy5zZWxlY3RPcHRpb24pIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuYWRkVGFncyhzLCB0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25JbnB1dChlKSB7XG4gICAgICB0aGlzLnBvc3RVcGRhdGUoKTsgLy8gdG9nZ2xlcyBcInRhZ2lmeS0tZW1wdHlcIiBjbGFzc1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2RlID09ICdtaXgnKSByZXR1cm4gdGhpcy5ldmVudHMuY2FsbGJhY2tzLm9uTWl4VGFnc0lucHV0LmNhbGwodGhpcywgZSk7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0Lm5vcm1hbGl6ZS5jYWxsKHRoaXMpLFxuICAgICAgICAgIHNob3dTdWdnZXN0aW9ucyA9IHZhbHVlLmxlbmd0aCA+PSB0aGlzLnNldHRpbmdzLmRyb3Bkb3duLmVuYWJsZWQsXG4gICAgICAgICAgZXZlbnREYXRhID0ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5wdXRFbG06IHRoaXMuRE9NLmlucHV0XG4gICAgICB9O1xuICAgICAgZXZlbnREYXRhLmlzVmFsaWQgPSB0aGlzLnZhbGlkYXRlVGFnKHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pOyAvLyBmb3IgSUU7IHNpbmNlIElFIGRvZXNuJ3QgaGF2ZSBhbiBcImlucHV0XCIgZXZlbnQgc28gXCJrZXlEb3duXCIgaXMgdXNlZCBpbnN0ZWFkIHRvIHRyaWdnZXIgdGhlIFwib25JbnB1dFwiIGNhbGxiYWNrLFxuICAgICAgLy8gYW5kIHNvIG1hbnkga2V5cyBkbyBub3QgY2hhbmdlIHRoZSBpbnB1dCwgYW5kIGZvciB0aG9zZSBkbyBub3QgY29udGludWUuXG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmlucHV0VGV4dCA9PSB2YWx1ZSkgcmV0dXJuOyAvLyBzYXZlIHRoZSB2YWx1ZSBvbiB0aGUgaW5wdXQncyBTdGF0ZSBvYmplY3RcblxuICAgICAgdGhpcy5pbnB1dC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSwgZmFsc2UpOyAvLyB1cGRhdGUgdGhlIGlucHV0IHdpdGggdGhlIG5vcm1hbGl6ZWQgdmFsdWUgYW5kIHJ1biB2YWxpZGF0aW9uc1xuICAgICAgLy8gdGhpcy5zZXRSYW5nZUF0U3RhcnRFbmQoKTsgLy8gZml4IGNhcmV0IHBvc2l0aW9uXG5cbiAgICAgIGlmICh2YWx1ZS5zZWFyY2godGhpcy5zZXR0aW5ncy5kZWxpbWl0ZXJzKSAhPSAtMSkge1xuICAgICAgICBpZiAodGhpcy5hZGRUYWdzKHZhbHVlKSkge1xuICAgICAgICAgIHRoaXMuaW5wdXQuc2V0LmNhbGwodGhpcyk7IC8vIGNsZWFyIHRoZSBpbnB1dCBmaWVsZCdzIHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5kcm9wZG93bi5lbmFibGVkID49IDApIHtcbiAgICAgICAgdGhpcy5kcm9wZG93bltzaG93U3VnZ2VzdGlvbnMgPyBcInNob3dcIiA6IFwiaGlkZVwiXSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcignaW5wdXQnLCBldmVudERhdGEpOyAvLyBcImlucHV0XCIgZXZlbnQgbXVzdCBiZSB0cmlnZ2VyZWQgYXQgdGhpcyBwb2ludCwgYmVmb3JlIHRoZSBkcm9wZG93biBpcyBzaG93blxuICAgIH0sXG5cbiAgICBvbk1peFRhZ3NJbnB1dChlKSB7XG4gICAgICB2YXIgcmFuZ2VUZXh0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZWRQYXR0ZXJuQ291bnQsXG4gICAgICAgICAgdGFnLFxuICAgICAgICAgIHNob3dTdWdnZXN0aW9ucyxcbiAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgX3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgIGxhc3RUYWdzQ291bnQgPSB0aGlzLnZhbHVlLmxlbmd0aCxcbiAgICAgICAgICBtYXRjaEZsYWdnZWRUYWcsXG4gICAgICAgICAgbWF0Y2hEZWxpbWl0ZXJzLFxuICAgICAgICAgIHRhZ3NFbGVtcyA9IHRoaXMuZ2V0VGFnRWxtcygpLFxuICAgICAgICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgIHJhbmdlID0gd2luZG93LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCksXG4gICAgICAgICAgcmVtYWluaW5nVGFnc1ZhbHVlcyA9IFtdLm1hcC5jYWxsKHRhZ3NFbGVtcywgbm9kZSA9PiB0aGlzLnRhZ0RhdGEobm9kZSkudmFsdWUpOyAvLyBBbmRyb2lkIENocm9tZSBcImtleWRvd25cIiBldmVudCBhcmd1bWVudCBkb2VzIG5vdCByZXBvcnQgdGhlIGNvcnJlY3QgXCJrZXlcIi5cbiAgICAgIC8vIHRoaXMgd29ya2Fyb3VuZCBpcyBuZWVkZWQgdG8gbWFudWFsbHkgY2FsbCBcIm9uS2V5ZG93blwiIG1ldGhvZCB3aXRoIGEgc3ludGhlc2l6ZWQgZXZlbnQgb2JqZWN0XG5cbiAgICAgIGlmIChlLmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiICYmIGlzQ2hyb21lQW5kcm9pZEJyb3dzZXIoKSkge1xuICAgICAgICB0aGlzLmV2ZW50cy5jYWxsYmFja3Mub25LZXlkb3duLmNhbGwodGhpcywge1xuICAgICAgICAgIHRhcmdldDogZS50YXJnZXQsXG4gICAgICAgICAga2V5OiBcIkJhY2tzcGFjZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZS1hZGQgXCJyZWFkb25seVwiIHRhZ3Mgd2hpY2ggbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcblxuXG4gICAgICB0aGlzLnZhbHVlLnNsaWNlKCkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0ucmVhZG9ubHkgJiYgIXJlbWFpbmluZ1RhZ3NWYWx1ZXMuaW5jbHVkZXMoaXRlbS52YWx1ZSkpIGZyYWdtZW50LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlVGFnRWxlbShpdGVtKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUoZnJhZ21lbnQpO1xuICAgICAgICB0aGlzLnNldFJhbmdlQXRTdGFydEVuZChmYWxzZSwgZnJhZ21lbnQubGFzdENoaWxkKTtcbiAgICAgIH0gLy8gY2hlY2sgaWYgdGFncyB3ZXJlIFwibWFnaWNhbGx5XCIgYWRkZWQvcmVtb3ZlZCAoYnJvd3NlciByZWRvL3VuZG8gb3IgQ1RSTC1BIC0+IGRlbGV0ZSlcblxuXG4gICAgICBpZiAodGFnc0VsZW1zLmxlbmd0aCAhPSBsYXN0VGFnc0NvdW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXS5tYXAuY2FsbCh0aGlzLmdldFRhZ0VsbXMoKSwgbm9kZSA9PiB0aGlzLnRhZ0RhdGEobm9kZSkpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgd2l0aG91dENoYW5nZUV2ZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc01heFRhZ3MoKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTsgLy8gb25seSBkZXRlY3QgdGFncyBpZiBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgdGV4dE5vZGUgKG5vdCBzb21laG93IG9uIGFscmVhZHktZXhpc3RpbmcgdGFnKVxuXG4gICAgICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDAgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHNlbGVjdGlvbi5mb2N1c05vZGUsIDApO1xuICAgICAgICAgIHJhbmdlVGV4dCA9IHJhbmdlLnRvU3RyaW5nKCkuc2xpY2UoMCwgcmFuZ2UuZW5kT2Zmc2V0KTsgLy8gc2xpY2UgdGhlIHJhbmdlIHNvIGV2ZXJ5dGhpbmcgQUZURVIgdGhlIGNhcmV0IHdpbGwgYmUgdHJpbW1lZFxuICAgICAgICAgIC8vIHNwbGl0ID0gcmFuZ2UudG9TdHJpbmcoKS5zcGxpdChfcy5taXhUYWdzQWxsb3dlZEFmdGVyKSAgLy8gW1wiZm9vXCIsIFwiYmFyXCIsIFwiQGJhelwiXVxuXG4gICAgICAgICAgbWF0Y2hlZFBhdHRlcm5Db3VudCA9IHJhbmdlVGV4dC5zcGxpdChfcy5wYXR0ZXJuKS5sZW5ndGggLSAxO1xuICAgICAgICAgIG1hdGNoID0gcmFuZ2VUZXh0Lm1hdGNoKF9zLnBhdHRlcm4pO1xuICAgICAgICAgIGlmIChtYXRjaCkgLy8gdGFnIHN0cmluZywgZXhhbXBsZTogXCJAYWFhIGNjY1wiXG4gICAgICAgICAgICB0YWcgPSByYW5nZVRleHQuc2xpY2UocmFuZ2VUZXh0Lmxhc3RJbmRleE9mKG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdKSk7XG5cbiAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmFjdGlvbnMuQXJyb3dMZWZ0ID0gZmFsc2U7IC8vIHN0YXJ0IGZyZXNoLCBhc3N1bWluZyB0aGUgdXNlciBkaWQgbm90ICh5ZXQpIHVzZWQgYW55IGFycm93IHRvIG1vdmUgdGhlIGNhcmV0XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUudGFnID0ge1xuICAgICAgICAgICAgICBwcmVmaXg6IHRhZy5tYXRjaChfcy5wYXR0ZXJuKVswXSxcbiAgICAgICAgICAgICAgdmFsdWU6IHRhZy5yZXBsYWNlKF9zLnBhdHRlcm4sICcnKSAvLyBnZXQgcmlkIG9mIHRoZSBwcmVmaXhcblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudGFnLmJhc2VPZmZzZXQgPSBzZWxlY3Rpb24uYmFzZU9mZnNldCAtIHRoaXMuc3RhdGUudGFnLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIG1hdGNoRGVsaW1pdGVycyA9IHRoaXMuc3RhdGUudGFnLnZhbHVlLm1hdGNoKF9zLmRlbGltaXRlcnMpOyAvLyBpZiBhIGRlbGltZXRlciBleGlzdHMsIGFkZCB0aGUgdmFsdWUgYXMgdGFnIChleGx1ZGluZyB0aGUgZGVsaW1pdGVyKVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hEZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUudGFnLnZhbHVlID0gdGhpcy5zdGF0ZS50YWcudmFsdWUucmVwbGFjZShfcy5kZWxpbWl0ZXJzLCAnJyk7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUudGFnLmRlbGltaXRlcnMgPSBtYXRjaERlbGltaXRlcnNbMF07XG4gICAgICAgICAgICAgIHRoaXMuYWRkVGFncyh0aGlzLnN0YXRlLnRhZy52YWx1ZSwgX3MuZHJvcGRvd24uY2xlYXJPblNlbGVjdCk7XG4gICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNob3dTdWdnZXN0aW9ucyA9IHRoaXMuc3RhdGUudGFnLnZhbHVlLmxlbmd0aCA+PSBfcy5kcm9wZG93bi5lbmFibGVkOyAvLyBXaGVuIHdyaXRlaW5nIHNvbWV0aGluZyB0aGF0IG1pZ2h0IGxvb2sgbGlrZSBhIHRhZyAoYW4gZW1haWwgYWRkcmVzcykgYnV0IGlzbid0IG9uZSAtIGl0IGlzIHVud2FudGVkXG4gICAgICAgICAgICAvLyB0aGUgc3VnZ2VzdGlvbnMgZHJvcGRvd24gYmUgc2hvd24sIHNvIHRoZSB1c2VyIGNsb3NlcyBpdCAoaW4gYW55IHdheSksIGFuZCB3aGlsZSBjb250aW51ZSB0eXBpbmcsXG4gICAgICAgICAgICAvLyBkcm9wZG93biBzaG91bGQgc3RheSBjbG9zZWQgdW50aWwgYW5vdGhlciB0YWcgaXMgdHlwZWQuXG4gICAgICAgICAgICAvLyBpZiggdGhpcy5zdGF0ZS50YWcudmFsdWUubGVuZ3RoICYmIHRoaXMuc3RhdGUuZHJvcGRvd24udmlzaWJsZSA9PT0gZmFsc2UgKVxuICAgICAgICAgICAgLy8gICAgIHNob3dTdWdnZXN0aW9ucyA9IGZhbHNlXG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBzaW1pbGFyIGZsYWdnZWQgdGFncyB0byB0aGUgY3VycmVudCB0YWdcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbWF0Y2hGbGFnZ2VkVGFnID0gdGhpcy5zdGF0ZS5mbGFnZ2VkVGFnc1t0aGlzLnN0YXRlLnRhZy5iYXNlT2Zmc2V0XTtcbiAgICAgICAgICAgICAgbWF0Y2hGbGFnZ2VkVGFnID0gbWF0Y2hGbGFnZ2VkVGFnLnByZWZpeCA9PSB0aGlzLnN0YXRlLnRhZy5wcmVmaXggJiYgbWF0Y2hGbGFnZ2VkVGFnLnZhbHVlWzBdID09IHRoaXMuc3RhdGUudGFnLnZhbHVlWzBdOyAvLyByZXNldFxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZsYWdnZWRUYWdzW3RoaXMuc3RhdGUudGFnLmJhc2VPZmZzZXRdICYmICF0aGlzLnN0YXRlLnRhZy52YWx1ZSkgZGVsZXRlIHRoaXMuc3RhdGUuZmxhZ2dlZFRhZ3NbdGhpcy5zdGF0ZS50YWcuYmFzZU9mZnNldF07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9IC8vIHNjZW5hcmlvOiAoZG8gbm90IHNob3cgc3VnZ2VzdGlvbnMgb2YgcHJldmlvdXMgbWF0Y2hlZCB0YWcsIGlmIG1vcmUgdGhhbiAxIGRldGVjdGVkKVxuICAgICAgICAgICAgLy8gKDIgdGFncyBleGlzdCkgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGFAYS5jb20gYW5kIEBcIlxuICAgICAgICAgICAgLy8gKHNlY29uZCB0YWcgaXMgcmVtb3ZlZCBieSBiYWNrc3BhY2UpICAgIFwiIGFAYS5jb20gYW5kIFwiXG5cblxuICAgICAgICAgICAgaWYgKG1hdGNoRmxhZ2dlZFRhZyB8fCBtYXRjaGVkUGF0dGVybkNvdW50IDwgdGhpcy5zdGF0ZS5taXhNb2RlLm1hdGNoZWRQYXR0ZXJuQ291bnQpIHNob3dTdWdnZXN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgIH0gLy8gbm8gKHBvdGVudGlhbCkgdGFnIGZvdW5kXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZsYWdnZWRUYWdzID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGF0ZS5taXhNb2RlLm1hdGNoZWRQYXR0ZXJuQ291bnQgPSBtYXRjaGVkUGF0dGVybkNvdW50O1xuICAgICAgICB9XG4gICAgICB9IC8vIHdhaXQgdW50aWwgdGhlIFwidGhpcy52YWx1ZVwiIGhhcyBiZWVuIHVwZGF0ZWQgKHNlZSBcIm9uS2V5ZG93blwiIG1ldGhvZCBmb3IgXCJtaXgtbW9kZVwiKVxuICAgICAgLy8gdGhlIGRyb3Bkb3duIG11c3QgYmUgc2hvd24gb25seSBhZnRlciB0aGlzIGV2ZW50IGhhcyBiZWVuIGRyaWdnZXJlZCwgc28gYW4gaW1wbGVtZW50ZXIgY291bGRcbiAgICAgIC8vIGR5bmFtaWNhbGx5IGNoYW5nZSB0aGUgd2hpdGVsaXN0LlxuXG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgd2l0aG91dENoYW5nZUV2ZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJpbnB1dFwiLCBleHRlbmQoe30sIHRoaXMuc3RhdGUudGFnLCB7XG4gICAgICAgICAgdGV4dENvbnRlbnQ6IHRoaXMuRE9NLmlucHV0LnRleHRDb250ZW50XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudGFnKSB0aGlzLmRyb3Bkb3duW3Nob3dTdWdnZXN0aW9ucyA/IFwic2hvd1wiIDogXCJoaWRlXCJdKHRoaXMuc3RhdGUudGFnLnZhbHVlKTtcbiAgICAgIH0sIDEwKTtcbiAgICB9LFxuXG4gICAgb25JbnB1dElFKGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIGZvciB0aGUgXCJlLnRhcmdldC50ZXh0Q29udGVudFwiIHRvIGJlIGNoYW5nZWQsIHRoZSBicm93c2VyIHJlcXVpcmVzIGEgc21hbGwgZGVsYXlcblxuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZXZlbnRzLmNhbGxiYWNrcy5vbklucHV0LmNhbGwoX3RoaXMsIGUpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9ic2VydmVPcmlnaW5hbElucHV0VmFsdWUoKSB7XG4gICAgICAvLyBpZiBvcmlnaW5hbCBpbnB1dCB2YWx1ZSBjaGFuZ2VkIGZvciBzb21lIHJlYXNvbiAoZm9yIGV4bWFwbGUgYSBmb3JtIHJlc2V0KVxuICAgICAgaWYgKHRoaXMuRE9NLm9yaWdpbmFsSW5wdXQudmFsdWUgIT0gdGhpcy5ET00ub3JpZ2luYWxJbnB1dC50YWdpZnlWYWx1ZSkgdGhpcy5sb2FkT3JpZ2luYWxWYWx1ZXMoKTtcbiAgICB9LFxuXG4gICAgb25DbGlja1Njb3BlKGUpIHtcbiAgICAgIHZhciBfcyA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgdGFnRWxtID0gZS50YXJnZXQuY2xvc2VzdCgnLicgKyBfcy5jbGFzc05hbWVzLnRhZyksXG4gICAgICAgICAgdGltZURpZmZGb2N1cyA9ICtuZXcgRGF0ZSgpIC0gdGhpcy5zdGF0ZS5oYXNGb2N1cztcblxuICAgICAgaWYgKGUudGFyZ2V0ID09IHRoaXMuRE9NLnNjb3BlKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5oYXNGb2N1cykgdGhpcy5ET00uaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoX3MuY2xhc3NOYW1lcy50YWdYKSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhZ3MoZS50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGFnRWxtKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcImNsaWNrXCIsIHtcbiAgICAgICAgICB0YWc6IHRhZ0VsbSxcbiAgICAgICAgICBpbmRleDogdGhpcy5nZXROb2RlSW5kZXgodGFnRWxtKSxcbiAgICAgICAgICBkYXRhOiB0aGlzLnRhZ0RhdGEodGFnRWxtKSxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0aGlzLmNsb25lRXZlbnQoZSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfcy5lZGl0VGFncyA9PT0gMSB8fCBfcy5lZGl0VGFncy5jbGlja3MgPT09IDEpIHRoaXMuZXZlbnRzLmNhbGxiYWNrcy5vbkRvdWJsZUNsaWNrU2NvcGUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB3aGVuIGNsaWNraW5nIG9uIHRoZSBpbnB1dCBpdHNlbGZcbiAgICAgIGVsc2UgaWYgKGUudGFyZ2V0ID09IHRoaXMuRE9NLmlucHV0KSB7XG4gICAgICAgIGlmIChfcy5tb2RlID09ICdtaXgnKSB7XG4gICAgICAgICAgLy8gZmlyZWZveCB3b24ndCBzaG93IGNhcmV0IGlmIGxhc3QgZWxlbWVudCBpcyBhIHRhZyAoYW5kIG5vdCBhIHRleHROb2RlKSxcbiAgICAgICAgICAvLyBzbyBhbiBlbXB0eSB0ZXh0bm9kZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICB0aGlzLmZpeEZpcmVmb3hMYXN0VGFnTm9DYXJldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWVEaWZmRm9jdXMgPiA1MDApIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kcm9wZG93bi52aXNpYmxlKSB0aGlzLmRyb3Bkb3duLmhpZGUoKTtlbHNlIGlmIChfcy5kcm9wZG93bi5lbmFibGVkID09PSAwICYmIF9zLm1vZGUgIT0gJ21peCcpIHRoaXMuZHJvcGRvd24uc2hvdyh0aGlzLnZhbHVlLmxlbmd0aCA/ICcnIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9zLm1vZGUgPT0gJ3NlbGVjdCcpICF0aGlzLnN0YXRlLmRyb3Bkb3duLnZpc2libGUgJiYgdGhpcy5kcm9wZG93bi5zaG93KCk7XG4gICAgfSxcblxuICAgIC8vIHNwZWNpYWwgcHJvY2Nlc3MgaXMgbmVlZGVkIGZvciBwYXN0ZWQgY29udGVudCBpbiBvcmRlciB0byBcImNsZWFuXCIgaXRcbiAgICBvblBhc3RlKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBfcyA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgc2VsZWN0TW9kZVdpdGhvdXRJbnB1dCA9IF9zLm1vZGUgPT0gJ3NlbGVjdCcgJiYgX3MuZW5mb3JjZVdoaXRlbGlzdDtcblxuICAgICAgaWYgKHNlbGVjdE1vZGVXaXRob3V0SW5wdXQgfHwgIV9zLnVzZXJJbnB1dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGlwYm9hcmREYXRhLCBwYXN0ZWRUZXh0O1xuICAgICAgaWYgKF9zLnJlYWRvbmx5KSByZXR1cm47IC8vIEdldCBwYXN0ZWQgZGF0YSB2aWEgY2xpcGJvYXJkIEFQSVxuXG4gICAgICBjbGlwYm9hcmREYXRhID0gZS5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgICAgcGFzdGVkVGV4dCA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpO1xuXG4gICAgICBfcy5ob29rcy5iZWZvcmVQYXN0ZShlLCB7XG4gICAgICAgIHRhZ2lmeTogdGhpcyxcbiAgICAgICAgcGFzdGVkVGV4dCxcbiAgICAgICAgY2xpcGJvYXJkRGF0YVxuICAgICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IHBhc3RlZFRleHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHRoaXMuaW5qZWN0QXRDYXJldChyZXN1bHQsIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApKTtcblxuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1vZGUgPT0gJ21peCcpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmNhbGxiYWNrcy5vbk1peFRhZ3NJbnB1dC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5wYXN0ZUFzVGFncykge1xuICAgICAgICAgICAgdGhpcy5hZGRUYWdzKHRoaXMuc3RhdGUuaW5wdXRUZXh0ICsgcmVzdWx0LCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgdGhpcy5zdGF0ZS5pbnB1dFRleHQgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGVyciA9PiBlcnIpO1xuICAgIH0sXG5cbiAgICBvbkRyb3AoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbkVkaXRUYWdJbnB1dChlZGl0YWJsZUVsbSwgZSkge1xuICAgICAgdmFyIHRhZ0VsbSA9IGVkaXRhYmxlRWxtLmNsb3Nlc3QoJy4nICsgdGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZyksXG4gICAgICAgICAgdGFnRWxtSWR4ID0gdGhpcy5nZXROb2RlSW5kZXgodGFnRWxtKSxcbiAgICAgICAgICB0YWdEYXRhID0gdGhpcy50YWdEYXRhKHRhZ0VsbSksXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmlucHV0Lm5vcm1hbGl6ZS5jYWxsKHRoaXMsIGVkaXRhYmxlRWxtKSxcbiAgICAgICAgICBoYXNDaGFuZ2VkID0gdGFnRWxtLmlubmVySFRNTCAhPSB0YWdFbG0uX190YWdpZnlUYWdEYXRhLl9fb3JpZ2luYWxIVE1MLFxuICAgICAgICAgIGlzVmFsaWQgPSB0aGlzLnZhbGlkYXRlVGFnKHtcbiAgICAgICAgW3RoaXMuc2V0dGluZ3MudGFnVGV4dFByb3BdOiB2YWx1ZVxuICAgICAgfSk7IC8vIHRoZSB2YWx1ZSBjb3VsZCBoYXZlIGJlZW4gaW52YWxpZCBpbiB0aGUgZmlyc3QtcGxhY2Ugc28gbWFrZSBzdXJlIHRvIHJlLXZhbGlkYXRlIGl0ICh2aWEgXCJhZGRFbXB0eVRhZ1wiIG1ldGhvZClcbiAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBzYW1lIGFzIGJlZm9yZS1lZGl0aW5nIGFuZCB0aGUgdGFnIHdhcyB2YWxpZCBiZWZvcmUgYXMgd2VsbCwgaWdub3JlIHRoZSAgY3VycmVudCBcImlzVmFsaWRcIiByZXN1bHQsIHdoaWNoIGlzIGZhbHNlLXBvc2l0aXZlXG5cbiAgICAgIGlmICghaGFzQ2hhbmdlZCAmJiBlZGl0YWJsZUVsbS5vcmlnaW5hbElzVmFsaWQgPT09IHRydWUpIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgdGFnRWxtLmNsYXNzTGlzdC50b2dnbGUodGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZ0ludmFsaWQsIGlzVmFsaWQgIT09IHRydWUpO1xuICAgICAgdGFnRGF0YS5fX2lzVmFsaWQgPSBpc1ZhbGlkO1xuICAgICAgdGFnRWxtLnRpdGxlID0gaXNWYWxpZCA9PT0gdHJ1ZSA/IHRhZ0RhdGEudGl0bGUgfHwgdGFnRGF0YS52YWx1ZSA6IGlzVmFsaWQ7IC8vIGNoYW5nZSB0aGUgdGFnJ3MgdGl0bGUgdG8gaW5kaWNhdGUgd2h5IGlzIHRoZSB0YWcgaW52YWxpZCAoaWYgaXQncyBzbylcbiAgICAgIC8vIHNob3cgZHJvcGRvd24gaWYgdHlwZWQgdGV4dCBpcyBlcXVhbCBvciBtb3JlIHRoYW4gdGhlIFwiZW5hYmxlZFwiIGRyb3Bkb3duIHNldHRpbmdcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSB0aGlzLnNldHRpbmdzLmRyb3Bkb3duLmVuYWJsZWQpIHtcbiAgICAgICAgLy8gdGhpcyBjaGVjayBpcyBuZWVkZWQgYXBwYXJlbnRseSBiZWNhdXNlIGRvaW5nIGJyb3dzZXIgXCJ1bmRvXCIgd2lsbCBmaXJlXG4gICAgICAgIC8vICBcIm9uRWRpdFRhZ0lucHV0XCIgYnV0IFwidGhpcy5zdGF0ZS5lZGl0aW5nXCIgd2lsbCBiZSBcImZhbHNlXCJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZWRpdGluZykgdGhpcy5zdGF0ZS5lZGl0aW5nLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uc2hvdyh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcihcImVkaXQ6aW5wdXRcIiwge1xuICAgICAgICB0YWc6IHRhZ0VsbSxcbiAgICAgICAgaW5kZXg6IHRhZ0VsbUlkeCxcbiAgICAgICAgZGF0YTogZXh0ZW5kKHt9LCB0aGlzLnZhbHVlW3RhZ0VsbUlkeF0sIHtcbiAgICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgICAgfSksXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRoaXMuY2xvbmVFdmVudChlKVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uRWRpdFRhZ0ZvY3VzKHRhZ0VsbSkge1xuICAgICAgdGhpcy5zdGF0ZS5lZGl0aW5nID0ge1xuICAgICAgICBzY29wZTogdGFnRWxtLFxuICAgICAgICBpbnB1dDogdGFnRWxtLnF1ZXJ5U2VsZWN0b3IoXCJbY29udGVudGVkaXRhYmxlXVwiKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgb25FZGl0VGFnQmx1cihlZGl0YWJsZUVsbSkge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmhhc0ZvY3VzKSB0aGlzLnRvZ2dsZUZvY3VzQ2xhc3MoKTsgLy8gb25lIHNjZW5hcmlvIGlzIHdoZW4gc2VsZWN0aW5nIGEgc3VnZ2VzdGlvbiBmcm9tIHRoZSBkcm9wZG93biwgd2hlbiBlZGl0aW5nLCBhbmQgYnkgc2VsZWN0aW5nIGl0XG4gICAgICAvLyB0aGUgXCJvbkVkaXRUYWdEb25lXCIgaXMgY2FsbGVkIGRpcmVjdGx5LCBhbHJlYWR5IHJlcGxhY2luZyB0aGUgdGFnLCBzbyB0aGUgYXJndW1lbnQgXCJlZGl0YWJsZUVsbVwiXG4gICAgICAvLyBub2RlIGlzbid0IGluIHRoZSBET00gYW55bm1vcmUgYmVjYXVzZSBpdCBoYXMgYmVlbiByZXBsYWNlZC5cblxuICAgICAgaWYgKCF0aGlzLkRPTS5zY29wZS5jb250YWlucyhlZGl0YWJsZUVsbSkpIHJldHVybjtcblxuICAgICAgdmFyIF9zID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICB0YWdFbG0gPSBlZGl0YWJsZUVsbS5jbG9zZXN0KCcuJyArIF9zLmNsYXNzTmFtZXMudGFnKSxcbiAgICAgICAgICB0ZXh0VmFsdWUgPSB0aGlzLmlucHV0Lm5vcm1hbGl6ZS5jYWxsKHRoaXMsIGVkaXRhYmxlRWxtKSxcbiAgICAgICAgICBvcmlnaW5hbERhdGEgPSB0aGlzLnRhZ0RhdGEodGFnRWxtKS5fX29yaWdpbmFsRGF0YSxcbiAgICAgICAgICAvLyBwcmUtZWRpdCBkYXRhXG4gICAgICBoYXNDaGFuZ2VkID0gdGFnRWxtLmlubmVySFRNTCAhPSB0YWdFbG0uX190YWdpZnlUYWdEYXRhLl9fb3JpZ2luYWxIVE1MLFxuICAgICAgICAgIGlzVmFsaWQgPSB0aGlzLnZhbGlkYXRlVGFnKHtcbiAgICAgICAgW19zLnRhZ1RleHRQcm9wXTogdGV4dFZhbHVlXG4gICAgICB9KSxcbiAgICAgICAgICBoYXNNYXhUYWdzLFxuICAgICAgICAgIG5ld1RhZ0RhdGE7IC8vICB0aGlzLkRPTS5pbnB1dC5mb2N1cygpXG5cblxuICAgICAgaWYgKCF0ZXh0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5vbkVkaXRUYWdEb25lKHRhZ0VsbSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaWYgbm90aGluZyBjaGFuZ2VkIHJldmVydCBiYWNrIHRvIGhvdyBpdCB3YXMgYmVmb3JlIGVkaXRpbmdcblxuXG4gICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vbkVkaXRUYWdEb25lKHRhZ0VsbSwgb3JpZ2luYWxEYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBoYXNNYXhUYWdzID0gdGhpcy5oYXNNYXhUYWdzKCk7XG4gICAgICBuZXdUYWdEYXRhID0gdGhpcy5nZXRXaGl0ZWxpc3RJdGVtKHRleHRWYWx1ZSkgfHwgZXh0ZW5kKHt9LCBvcmlnaW5hbERhdGEsIHtcbiAgICAgICAgW19zLnRhZ1RleHRQcm9wXTogdGV4dFZhbHVlLFxuICAgICAgICB2YWx1ZTogdGV4dFZhbHVlLFxuICAgICAgICBfX2lzVmFsaWQ6IGlzVmFsaWRcbiAgICAgIH0pO1xuXG4gICAgICBfcy50cmFuc2Zvcm1UYWcuY2FsbCh0aGlzLCBuZXdUYWdEYXRhLCBvcmlnaW5hbERhdGEpOyAvLyBNVVNUIHJlLXZhbGlkYXRlIGFmdGVyIHRhZyB0cmFuc2Zvcm1hdGlvblxuICAgICAgLy8gb25seSB2YWxpZGF0ZSB0aGUgXCJ0YWdUZXh0UHJvcFwiIGJlY2F1c2UgaXMgdGhlIG9ubHkgdGhpbmcgdGhhdCBtZXR0ZXJzIGZvciB2YWxpZGF0aW5nIGFuIGVkaXRlZCB0YWcuXG4gICAgICAvLyAtLSBTY2VuYXJpb3M6IC0tXG4gICAgICAvLyAxLiBtYXggMyB0YWdzIGFsbG93ZC4gdGhlcmUgYXJlIDQgdGFncywgb25lIGhhcyBpbnZhbGlkIGlucHV0IGFuZCBpcyBlZGl0ZWQgdG8gYSB2YWxpZCBvbmUsIGFuZCBub3cgc2hvdWxkIGJlIG1hcmtlZCBhcyBcIm5vdCBhbGxvd2VkXCIgYmVjYXVzZSBsaW1pdCBvZiB0YWdzIGhhcyByZWFjaGVkXG4gICAgICAvLyAyLiBtYXggMyB0YWdzIGFsbG93ZWQuIHRoZXJlIGFyZSAzIHRhZ3MsIG9uZSBpcyBlZGl0ZWQsIGFuZCBzbyBtYXgtdGFncyB2YWlsZGF0aW9uIHNob3VsZCBiZSBPS1xuXG5cbiAgICAgIGlzVmFsaWQgPSAhaGFzTWF4VGFncyAmJiB0aGlzLnZhbGlkYXRlVGFnKHtcbiAgICAgICAgW19zLnRhZ1RleHRQcm9wXTogbmV3VGFnRGF0YVtfcy50YWdUZXh0UHJvcF1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNWYWxpZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJpbnZhbGlkXCIsIHtcbiAgICAgICAgICBkYXRhOiBuZXdUYWdEYXRhLFxuICAgICAgICAgIHRhZzogdGFnRWxtLFxuICAgICAgICAgIG1lc3NhZ2U6IGlzVmFsaWRcbiAgICAgICAgfSk7IC8vIGRvIG5vdGhpbmcgaWYgaW52YWxpZCwgc3RheSBpbiBlZGl0LW1vZGUgdW50aWwgY29ycmVjdGVkIG9yIHJldmVydGVkIGJ5IHByZXNzc2luZyBlc2NcblxuICAgICAgICBpZiAoX3MuZWRpdFRhZ3Mua2VlcEludmFsaWQpIHJldHVybjtcbiAgICAgICAgaWYgKF9zLmtlZXBJbnZhbGlkVGFncykgbmV3VGFnRGF0YS5fX2lzVmFsaWQgPSBpc1ZhbGlkO2Vsc2UgLy8gcmV2ZXJ0IGJhY2sgaWYgbm90IHNwZWNpZmllZCB0byBrZWVwXG4gICAgICAgICAgbmV3VGFnRGF0YSA9IG9yaWdpbmFsRGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoX3Mua2VlcEludmFsaWRUYWdzKSB7XG4gICAgICAgIC8vIGNsZWF1cCBhbnkgcHJldmlvdXMgbGVmdG92ZXJzIGlmIHRoZSB0YWcgd2FzXG4gICAgICAgIGRlbGV0ZSBuZXdUYWdEYXRhLnRpdGxlO1xuICAgICAgICBkZWxldGUgbmV3VGFnRGF0YVtcImFyaWEtaW52YWxpZFwiXTtcbiAgICAgICAgZGVsZXRlIG5ld1RhZ0RhdGEuY2xhc3M7XG4gICAgICB9IC8vIHRhZ0VsbS5jbGFzc0xpc3QudG9nZ2xlKF9zLmNsYXNzTmFtZXMudGFnSW52YWxpZCwgdHJ1ZSlcblxuXG4gICAgICB0aGlzLm9uRWRpdFRhZ0RvbmUodGFnRWxtLCBuZXdUYWdEYXRhKTtcbiAgICB9LFxuXG4gICAgb25FZGl0VGFna2V5ZG93bihlLCB0YWdFbG0pIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImVkaXQ6a2V5ZG93blwiLCB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRoaXMuY2xvbmVFdmVudChlKVxuICAgICAgfSk7XG5cbiAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgY2FzZSAnRXNjJzpcbiAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICB0YWdFbG0uaW5uZXJIVE1MID0gdGFnRWxtLl9fdGFnaWZ5VGFnRGF0YS5fX29yaWdpbmFsSFRNTDtcblxuICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUudGFyZ2V0LmJsdXIoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Eb3VibGVDbGlja1Njb3BlKGUpIHtcbiAgICAgIHZhciB0YWdFbG0gPSBlLnRhcmdldC5jbG9zZXN0KCcuJyArIHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy50YWcpLFxuICAgICAgICAgIF9zID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICBpc0VkaXRpbmdUYWcsXG4gICAgICAgICAgaXNSZWFkeU9ubHlUYWc7XG4gICAgICBpZiAoIXRhZ0VsbSB8fCAhX3MudXNlcklucHV0KSByZXR1cm47XG4gICAgICBpc0VkaXRpbmdUYWcgPSB0YWdFbG0uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy50YWdFZGl0aW5nKTtcbiAgICAgIGlzUmVhZHlPbmx5VGFnID0gdGFnRWxtLmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKTtcbiAgICAgIGlmIChfcy5tb2RlICE9ICdzZWxlY3QnICYmICFfcy5yZWFkb25seSAmJiAhaXNFZGl0aW5nVGFnICYmICFpc1JlYWR5T25seVRhZyAmJiB0aGlzLnNldHRpbmdzLmVkaXRUYWdzKSB0aGlzLmVkaXRUYWcodGFnRWxtKTtcbiAgICAgIHRoaXMudG9nZ2xlRm9jdXNDbGFzcyh0cnVlKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZGJsY2xpY2snLCB7XG4gICAgICAgIHRhZzogdGFnRWxtLFxuICAgICAgICBpbmRleDogdGhpcy5nZXROb2RlSW5kZXgodGFnRWxtKSxcbiAgICAgICAgZGF0YTogdGhpcy50YWdEYXRhKHRhZ0VsbSlcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBvYnNlcnZlZCBET00gY2hhbmdlc1xyXG4gICAgICovXG4gICAgb25JbnB1dERPTUNoYW5nZShtKSB7XG4gICAgICAvLyBpdGVyYXRlIGFsbCBET20gbXV0YXRpb25cbiAgICAgIG0uZm9yRWFjaChyZWNvcmQgPT4ge1xuICAgICAgICAvLyBvbmx5IHRoZSBBRERFRCBub2Rlc1xuICAgICAgICByZWNvcmQuYWRkZWROb2Rlcy5mb3JFYWNoKGFkZGVkTm9kZSA9PiB7XG4gICAgICAgICAgaWYgKGFkZGVkTm9kZSkge1xuICAgICAgICAgICAgLy8gZml4IGNocm9tZSdzIHBsYWNpbmcgJzxkaXY+PGJyPjwvZGl2PicgZXZlcnl0aW1lIEVOVEVSIGtleSBpcyBwcmVzc2VkLCBhbmQgcmVwbGFjZSB3aXRoIGp1c3QgYDxicidcbiAgICAgICAgICAgIGlmIChhZGRlZE5vZGUub3V0ZXJIVE1MID09ICc8ZGl2Pjxicj48L2Rpdj4nKSB7XG4gICAgICAgICAgICAgIGFkZGVkTm9kZS5yZXBsYWNlV2l0aChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICAgICAgICAgIH0gLy8gaWYgdGhlIGFkZGVkIGVsZW1lbnQgaXMgYSBkaXYgY29udGFpbmluZyBhIHRhZyB3aXRoaW4gaXQgKGNocm9tZSBkb2VzIHRoaXMgd2hlbiBwcmVzc2luZyBFTlRFUiBiZWZvcmUgYSB0YWcpXG4gICAgICAgICAgICBlbHNlIGlmIChhZGRlZE5vZGUubm9kZVR5cGUgPT0gMSAmJiBhZGRlZE5vZGUucXVlcnlTZWxlY3Rvcih0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMudGFnU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIGxldCBuZXdsaW5lVGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgaWYgKGFkZGVkTm9kZS5jaGlsZE5vZGVzWzBdLm5vZGVUeXBlID09IDMgJiYgYWRkZWROb2RlLnByZXZpb3VzU2libGluZy5ub2RlTmFtZSAhPSAnQlInKSBuZXdsaW5lVGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXG4nKTsgLy8gdW53cmFwIHRoZSB1c2VsZXNzIGRpdlxuICAgICAgICAgICAgICAvLyBjaHJvbWUgYWRkcyBhIEJSIGF0IHRoZSBlbmQgd2hpY2ggc2hvdWxkIGJlIHJlbW92ZWRcblxuICAgICAgICAgICAgICBhZGRlZE5vZGUucmVwbGFjZVdpdGgoLi4uW25ld2xpbmVUZXh0LCAuLi5bLi4uYWRkZWROb2RlLmNoaWxkTm9kZXNdLnNsaWNlKDAsIC0xKV0pO1xuICAgICAgICAgICAgICB0aGlzLnBsYWNlQ2FyZXRBZnRlck5vZGUobmV3bGluZVRleHQucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gLy8gaWYgdGhpcyBpcyBhIHRhZ1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNOb2RlVGFnLmNhbGwodGhpcywgYWRkZWROb2RlKSkge1xuICAgICAgICAgICAgICAvLyBhbmQgaXQgaXMgdGhlIGZpcnN0IG5vZGUgaW4gYSBuZXcgbGluZVxuICAgICAgICAgICAgICBpZiAoYWRkZWROb2RlLnByZXZpb3VzU2libGluZyAmJiBhZGRlZE5vZGUucHJldmlvdXNTaWJsaW5nLm5vZGVOYW1lID09ICdCUicpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvd3MgcGxhY2luZyB0aGUgY2FyZXQganVzdCBiZWZvcmUgdGhlIHRhZywgd2hlbiB0aGUgdGFnIGlzIHRoZSBmaXJzdCBub2RlIGluIHRoYXQgbGluZVxuICAgICAgICAgICAgICAgIGFkZGVkTm9kZS5wcmV2aW91c1NpYmxpbmcucmVwbGFjZVdpdGgoJ1xcblxcdTIwMEInKTsgLy8gd2hlbiBoaXR0aW5nIEVOVEVSIGZvciBuZXcgbGluZSBqdXN0IGJlZm9yZSBhIHRhZ1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZUNhcmV0QWZ0ZXJOb2RlKGFkZGVkTm9kZS5wcmV2aW91c1NpYmxpbmcucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMuZm9yRWFjaChyZW1vdmVkTm9kZSA9PiB7XG4gICAgICAgICAgLy8gd2hlbiB0cnlpbmcgdG8gZGVsZXRlIGEgdGFnIHdoaWNoIGlzIGluIGEgbmV3IGxpbmUgYW5kIHRoZXJlJ3Mgbm90aGluZyBlbHNlIHRoZXJlIChjYXJldCBpcyBhZnRlciB0aGUgdGFnKVxuICAgICAgICAgIGlmIChyZW1vdmVkTm9kZSAmJiByZW1vdmVkTm9kZS5ub2RlTmFtZSA9PSAnQlInICYmIGlzTm9kZVRhZy5jYWxsKHRoaXMsIGxhc3RJbnB1dENoaWxkKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWdzKGxhc3RJbnB1dENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuZml4RmlyZWZveExhc3RUYWdOb0NhcmV0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBnZXQgdGhlIGxhc3QgY2hpbGQgb25seSBhZnRlciB0aGUgYWJvdmUgRE9NIG1vZGlmaWNhdGlvbnNcbiAgICAgIC8vIGNoZWNrIHRoZXNlIHNjZW5hcmlvczpcbiAgICAgIC8vIDEuIGFmdGVyIGEgc2luZ2xlIGxpbmUsIHByZXNzIEVOVEVSIG9uY2UgLSBzaG91bGQgYWRkIG9ubHkgMSBCUlxuICAgICAgLy8gMi4gcHJlc3NzIEVOVEVSIHJpZ2h0IGJlZm9yZSBhIHRhZ1xuICAgICAgLy8gMy4gcHJlc3MgZW50ZXIgd2l0aGluIGEgdGV4dCBub2RlIGJlZm9yZSBhIHRhZ1xuXG4gICAgICB2YXIgbGFzdElucHV0Q2hpbGQgPSB0aGlzLkRPTS5pbnB1dC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAobGFzdElucHV0Q2hpbGQgJiYgbGFzdElucHV0Q2hpbGQubm9kZVZhbHVlID09ICcnKSBsYXN0SW5wdXRDaGlsZC5yZW1vdmUoKTsgLy8gbWFrZSBzdXJlIHRoZSBsYXN0IGVsZW1lbnQgaXMgYWx3YXlzIGEgQlJcblxuICAgICAgaWYgKCFsYXN0SW5wdXRDaGlsZCB8fCBsYXN0SW5wdXRDaGlsZC5ub2RlTmFtZSAhPSAnQlInKSB7XG4gICAgICAgIHRoaXMuRE9NLmlucHV0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG59O1xuXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAgICBET00gZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3Mgc2V0dGluZ3Mgb2JqZWN0XHJcbiAqL1xuXG5mdW5jdGlvbiBUYWdpZnkoaW5wdXQsIHNldHRpbmdzKSB7XG4gIGlmICghaW5wdXQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1RhZ2lmeTogJywgJ2lucHV0IGVsZW1lbnQgbm90IGZvdW5kJywgaW5wdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKGlucHV0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgaW5wdXQucHJldmlvdXNFbGVtZW50U2libGluZy5jbGFzc0xpc3QuY29udGFpbnMoJ3RhZ2lmeScpKSB7XG4gICAgY29uc29sZS53YXJuKCdUYWdpZnk6ICcsICdpbnB1dCBlbGVtZW50IGlzIGFscmVhZHkgVGFnaWZpZWQnLCBpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBleHRlbmQodGhpcywgRXZlbnREaXNwYXRjaGVyKHRoaXMpKTtcbiAgdGhpcy5pc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuICB0aGlzLmlzSUUgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvY29tcGF0TW9kZSNCcm93c2VyX2NvbXBhdGliaWxpdHlcblxuICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICB0aGlzLmdldFBlcnNpc3RlZERhdGEgPSBnZXRQZXJzaXN0ZWREYXRhKHNldHRpbmdzLmlkKTtcbiAgdGhpcy5zZXRQZXJzaXN0ZWREYXRhID0gc2V0UGVyc2lzdGVkRGF0YShzZXR0aW5ncy5pZCk7XG4gIHRoaXMuY2xlYXJQZXJzaXN0ZWREYXRhID0gY2xlYXJQZXJzaXN0ZWREYXRhKHNldHRpbmdzLmlkKTtcbiAgdGhpcy5hcHBseVNldHRpbmdzKGlucHV0LCBzZXR0aW5ncyk7XG4gIHRoaXMuc3RhdGUgPSB7XG4gICAgaW5wdXRUZXh0OiAnJyxcbiAgICBlZGl0aW5nOiBmYWxzZSxcbiAgICBhY3Rpb25zOiB7fSxcbiAgICAvLyBVSSBhY3Rpb25zIGZvciBzdGF0ZS1sb2NraW5nXG4gICAgbWl4TW9kZToge30sXG4gICAgZHJvcGRvd246IHt9LFxuICAgIGZsYWdnZWRUYWdzOiB7fSAvLyBpbiBtaXgtbW9kZSwgd2hlbiBhIHN0cmluZyBpcyBkZXRldGNlZCBhcyBwb3RlbnRpYWwgdGFnLCBhbmQgdGhlIHVzZXIgaGFzIGNob2NlbiB0byBjbG9zZSB0aGUgc3VnZ2VzdGlvbnMgZHJvcGRvd24sIGtlZXAgdGhlIHJlY29yZCBvZiB0aGUgdGFzZyBoZXJlXG5cbiAgfTtcbiAgdGhpcy52YWx1ZSA9IFtdOyAvLyB0YWdzJyBkYXRhXG4gIC8vIGV2ZW50cycgY2FsbGJhY2tzIHJlZmVyZW5jZXMgd2lsbCBiZSBzdG9yZXMgaGVyZSwgc28gZXZlbnRzIGNvdWxkIGJlIHVuYmluZGVkXG5cbiAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgdGhpcy5ET00gPSB7fTsgLy8gU3RvcmUgYWxsIHJlbGV2YW50IERPTSBlbGVtZW50cyBpbiBhbiBPYmplY3RcblxuICB0aGlzLmJ1aWxkKGlucHV0KTtcbiAgaW5pdERyb3Bkb3duLmNhbGwodGhpcyk7XG4gIHRoaXMuZ2V0Q1NTVmFycygpO1xuICB0aGlzLmxvYWRPcmlnaW5hbFZhbHVlcygpO1xuICB0aGlzLmV2ZW50cy5jdXN0b21CaW5kaW5nLmNhbGwodGhpcyk7XG4gIHRoaXMuZXZlbnRzLmJpbmRpbmcuY2FsbCh0aGlzKTtcbiAgaW5wdXQuYXV0b2ZvY3VzICYmIHRoaXMuRE9NLmlucHV0LmZvY3VzKCk7XG59XG5cblRhZ2lmeS5wcm90b3R5cGUgPSB7XG4gIF9kcm9wZG93bixcbiAgY3VzdG9tRXZlbnRzTGlzdDogWydjaGFuZ2UnLCAnYWRkJywgJ3JlbW92ZScsICdpbnZhbGlkJywgJ2lucHV0JywgJ2NsaWNrJywgJ2tleWRvd24nLCAnZm9jdXMnLCAnYmx1cicsICdlZGl0OmlucHV0JywgJ2VkaXQ6YmVmb3JlVXBkYXRlJywgJ2VkaXQ6dXBkYXRlZCcsICdlZGl0OnN0YXJ0JywgJ2VkaXQ6a2V5ZG93bicsICdkcm9wZG93bjpzaG93JywgJ2Ryb3Bkb3duOmhpZGUnLCAnZHJvcGRvd246c2VsZWN0JywgJ2Ryb3Bkb3duOnVwZGF0ZWQnLCAnZHJvcGRvd246bm9NYXRjaCcsICdkcm9wZG93bjpzY3JvbGwnXSxcbiAgZGF0YVByb3BzOiBbJ19faXNWYWxpZCcsICdfX3JlbW92ZWQnLCAnX19vcmlnaW5hbERhdGEnLCAnX19vcmlnaW5hbEhUTUwnLCAnX190YWdJZCddLFxuXG4gIC8vIGludGVybmFsLXVhc2dlIHByb3BzXG4gIHRyaW0odGV4dCkge1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnRyaW0gJiYgdGV4dCAmJiB0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiID8gdGV4dC50cmltKCkgOiB0ZXh0O1xuICB9LFxuXG4gIC8vIGV4cG9zZSB0aGlzIGhhbmR5IHV0aWxpdHkgZnVuY3Rpb25cbiAgcGFyc2VIVE1MLFxuICB0ZW1wbGF0ZXMsXG5cbiAgcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YSkge1xuICAgIHRlbXBsYXRlID0gdGhpcy5zZXR0aW5ncy50ZW1wbGF0ZXNbdGVtcGxhdGVdIHx8IHRlbXBsYXRlO1xuICAgIHJldHVybiB0aGlzLnBhcnNlSFRNTCh0ZW1wbGF0ZS5hcHBseSh0aGlzLCBkYXRhKSk7XG4gIH0sXG5cbiAgc2V0IHdoaXRlbGlzdChhcnIpIHtcbiAgICBjb25zdCBpc0FycmF5ID0gYXJyICYmIEFycmF5LmlzQXJyYXkoYXJyKTtcbiAgICB0aGlzLnNldHRpbmdzLndoaXRlbGlzdCA9IGlzQXJyYXkgPyBhcnIgOiBbXTtcbiAgICB0aGlzLnNldFBlcnNpc3RlZERhdGEoaXNBcnJheSA/IGFyciA6IFtdLCAnd2hpdGVsaXN0Jyk7XG4gIH0sXG5cbiAgZ2V0IHdoaXRlbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy53aGl0ZWxpc3Q7XG4gIH0sXG5cbiAgYXBwbHlTZXR0aW5ncyhpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICBERUZBVUxUUy50ZW1wbGF0ZXMgPSB0aGlzLnRlbXBsYXRlcztcblxuICAgIHZhciBfcyA9IHRoaXMuc2V0dGluZ3MgPSBleHRlbmQoe30sIERFRkFVTFRTLCBzZXR0aW5ncyk7XG5cbiAgICBfcy5kaXNhYmxlZCA9IGlucHV0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICBfcy5yZWFkb25seSA9IGlucHV0Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKTsgLy8gaWYgXCJyZWFkb25seVwiIGRvIG5vdCBpbmNsdWRlIGFuIFwiaW5wdXRcIiBlbGVtZW50IGluc2lkZSB0aGUgVGFncyBjb21wb25lbnRcblxuICAgIF9zLnBsYWNlaG9sZGVyID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpIHx8IF9zLnBsYWNlaG9sZGVyIHx8IFwiXCI7XG4gICAgX3MucmVxdWlyZWQgPSBpbnB1dC5oYXNBdHRyaWJ1dGUoJ3JlcXVpcmVkJyk7XG5cbiAgICBmb3IgKGxldCBuYW1lIGluIF9zLmNsYXNzTmFtZXMpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfcy5jbGFzc05hbWVzLCBuYW1lICsgXCJTZWxlY3RvclwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBcIi5cIiArIHRoaXNbbmFtZV0uc3BsaXQoXCIgXCIpWzBdO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5pc0lFKSBfcy5hdXRvQ29tcGxldGUgPSBmYWxzZTsgLy8gSUUgZ29lcyBjcmF6eSBpZiB0aGlzIGlzbid0IGZhbHNlXG5cbiAgICBbXCJ3aGl0ZWxpc3RcIiwgXCJibGFja2xpc3RcIl0uZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIHZhciBhdHRyVmFsID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lKTtcblxuICAgICAgaWYgKGF0dHJWYWwpIHtcbiAgICAgICAgYXR0clZhbCA9IGF0dHJWYWwuc3BsaXQoX3MuZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChhdHRyVmFsIGluc3RhbmNlb2YgQXJyYXkpIF9zW25hbWVdID0gYXR0clZhbDtcbiAgICAgIH1cbiAgICB9KTsgLy8gYmFja3dhcmQtY29tcGF0aWJpbGl0eSBmb3Igb2xkIHZlcnNpb24gb2YgXCJhdXRvQ29tcGxldGVcIiBzZXR0aW5nOlxuXG4gICAgaWYgKFwiYXV0b0NvbXBsZXRlXCIgaW4gc2V0dGluZ3MgJiYgIWlzT2JqZWN0KHNldHRpbmdzLmF1dG9Db21wbGV0ZSkpIHtcbiAgICAgIF9zLmF1dG9Db21wbGV0ZSA9IERFRkFVTFRTLmF1dG9Db21wbGV0ZTtcbiAgICAgIF9zLmF1dG9Db21wbGV0ZS5lbmFibGVkID0gc2V0dGluZ3MuYXV0b0NvbXBsZXRlO1xuICAgIH1cblxuICAgIGlmIChfcy5tb2RlID09ICdtaXgnKSB7XG4gICAgICBfcy5hdXRvQ29tcGxldGUucmlnaHRLZXkgPSB0cnVlO1xuICAgICAgX3MuZGVsaW1pdGVycyA9IHNldHRpbmdzLmRlbGltaXRlcnMgfHwgbnVsbDsgLy8gZGVmYXVsdCBkbGltaXRlcnMgaW4gbWl4LW1vZGUgbXVzdCBiZSBOVUxMXG4gICAgICAvLyBuZWVkZWQgZm9yIFwiZmlsdGVyTGlzdEl0ZW1zXCIuIFRoaXMgYXNzdW1lcyB0aGUgdXNlciBtaWdodCBoYXZlIGZvcmdvdHRlbiB0byBtYW51YWxseVxuICAgICAgLy8gZGVmaW5lIHRoZSBzYW1lIHRlcm0gaW4gXCJkcm9wZG93bi5zZWFyY2hLZXlzXCIgYXMgZGVmaW5lZCBpbiBcInRhZ1RleHRQcm9wXCIgc2V0dGluZywgc29cbiAgICAgIC8vIGJ5IGF1dG9tYXRpY2FsbHkgYWRkaW5nIGl0LCB0YWdpZnkgaXMgXCJoZWxwaW5nXCIgb3V0LCBndWVzc2luZyB0aGUgaW50ZXNudGlvbnMgb2YgdGhlIGRldmVsb3Blci5cblxuICAgICAgaWYgKF9zLnRhZ1RleHRQcm9wICYmICFfcy5kcm9wZG93bi5zZWFyY2hLZXlzLmluY2x1ZGVzKF9zLnRhZ1RleHRQcm9wKSkgX3MuZHJvcGRvd24uc2VhcmNoS2V5cy5wdXNoKF9zLnRhZ1RleHRQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQucGF0dGVybikgdHJ5IHtcbiAgICAgIF9zLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGlucHV0LnBhdHRlcm4pO1xuICAgIH0gY2F0Y2ggKGUpIHt9IC8vIENvbnZlcnQgdGhlIFwiZGVsaW1pdGVyc1wiIHNldHRpbmcgaW50byBhIFJFR0VYIG9iamVjdFxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVsaW1pdGVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3MuZGVsaW1pdGVycyA9IG5ldyBSZWdFeHAodGhpcy5zZXR0aW5ncy5kZWxpbWl0ZXJzLCBcImdcIik7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIGlmIChfcy5kaXNhYmxlZCkgX3MudXNlcklucHV0ID0gZmFsc2U7XG4gICAgdGhpcy5URVhUUyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBURVhUUyksIF9zLnRleHRzIHx8IHt9KTsgLy8gbWFrZSBzdXJlIHRoZSBkcm9wZG93biB3aWxsIGJlIHNob3duIG9uIFwiZm9jdXNcIiBhbmQgbm90IG9ubHkgYWZ0ZXIgdHlwaW5nIHNvbWV0aGluZyAoaW4gXCJzZWxlY3RcIiBtb2RlKVxuXG4gICAgaWYgKF9zLm1vZGUgPT0gJ3NlbGVjdCcgfHwgIV9zLnVzZXJJbnB1dCkgX3MuZHJvcGRvd24uZW5hYmxlZCA9IDA7XG4gICAgX3MuZHJvcGRvd24uYXBwZW5kVGFyZ2V0ID0gc2V0dGluZ3MuZHJvcGRvd24gJiYgc2V0dGluZ3MuZHJvcGRvd24uYXBwZW5kVGFyZ2V0ID8gc2V0dGluZ3MuZHJvcGRvd24uYXBwZW5kVGFyZ2V0IDogZG9jdW1lbnQuYm9keTsgLy8gZ2V0ICYgbWVyZ2UgcGVyc2lzdGVkIGRhdGEgd2l0aCBjdXJyZW50IGRhdGFcblxuICAgIGxldCBwZXJzaXN0ZWRXaGl0ZWxpc3QgPSB0aGlzLmdldFBlcnNpc3RlZERhdGEoJ3doaXRlbGlzdCcpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBlcnNpc3RlZFdoaXRlbGlzdCkpIHRoaXMud2hpdGVsaXN0ID0gQXJyYXkuaXNBcnJheShfcy53aGl0ZWxpc3QpID8gY29uY2F0V2l0aG91dER1cHMoX3Mud2hpdGVsaXN0LCBwZXJzaXN0ZWRXaGl0ZWxpc3QpIDogcGVyc2lzdGVkV2hpdGVsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCBlbGVtZW50IGF0dHJpYnV0ZXNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBbVGFnIGRhdGFdXHJcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoZGF0YSkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuZ2V0Q3VzdG9tQXR0cmlidXRlcyhkYXRhKSxcbiAgICAgICAgcyA9ICcnLFxuICAgICAgICBrO1xuXG4gICAgZm9yIChrIGluIGF0dHJzKSBzICs9IFwiIFwiICsgayArIChkYXRhW2tdICE9PSB1bmRlZmluZWQgPyBgPVwiJHthdHRyc1trXX1cImAgOiBcIlwiKTtcblxuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdG8gYmUgdXNlZCBmb3IgdGhlIHRlbXBsYXRlc1xyXG4gICAqL1xuICBnZXRDdXN0b21BdHRyaWJ1dGVzKGRhdGEpIHtcbiAgICAvLyBvbmx5IGl0ZW1zIHdoaWNoIGFyZSBvYmplY3RzIGhhdmUgcHJvcGVydGllcyB3aGljaCBjYW4gYmUgdXNlZCBhcyBhdHRyaWJ1dGVzXG4gICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuICcnO1xuICAgIHZhciBvdXRwdXQgPSB7fSxcbiAgICAgICAgcHJvcE5hbWU7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRhdGEpIHtcbiAgICAgIGlmIChwcm9wTmFtZS5zbGljZSgwLCAyKSAhPSAnX18nICYmIHByb3BOYW1lICE9ICdjbGFzcycgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiYgZGF0YVtwcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkgb3V0cHV0W3Byb3BOYW1lXSA9IGVzY2FwZUhUTUwoZGF0YVtwcm9wTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG5cbiAgc2V0U3RhdGVTZWxlY3Rpb24oKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTsgLy8gc2F2ZSBsYXN0IHNlbGVjdGlvbiBwbGFjZSB0byBiZSBhYmxlIHRvIGluamVjdCBhbnl0aGluZyBmcm9tIG91dHNpZGUgdG8gdGhhdCBzcGVjaWZpYyBwbGFjZVxuXG4gICAgdmFyIHNlbCA9IHtcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgcmFuZ2U6IHNlbGVjdGlvbi5nZXRSYW5nZUF0ICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmIHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApXG4gICAgfTtcbiAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHNlbDtcbiAgICByZXR1cm4gc2VsO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY2FyZXQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XHJcbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU4OTg1MDc2LzEwNDM4MFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge29iamVjdH0gbGVmdCwgdG9wIGRpc3RhbmNlIGluIHBpeGVsc1xyXG4gICAqL1xuICBnZXRDYXJldEdsb2JhbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHNlbCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKHNlbC5yYW5nZUNvdW50KSB7XG4gICAgICBjb25zdCByID0gc2VsLmdldFJhbmdlQXQoMCk7XG4gICAgICBjb25zdCBub2RlID0gci5zdGFydENvbnRhaW5lcjtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHIuc3RhcnRPZmZzZXQ7XG4gICAgICBsZXQgcmVjdCwgcjI7XG5cbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIHIyID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcjIuc2V0U3RhcnQobm9kZSwgb2Zmc2V0IC0gMSk7XG4gICAgICAgIHIyLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICByZWN0ID0gcjIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogcmVjdC5yaWdodCxcbiAgICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogLTk5OTksXG4gICAgICB0b3A6IC05OTk5XG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgc3BlY2lmaWMgQ1NTIHZhcmlhYmxlcyB3aGljaCBhcmUgcmVsZXZhbnQgdG8gdGhpcyBzY3JpcHQgYW5kIHBhcnNlIHRoZW0gYXMgbmVlZGVkLlxyXG4gICAqIFRoZSByZXN1bHQgaXMgc2F2ZWQgb24gdGhlIGluc3RhbmNlIGluIFwidGhpcy5DU1NWYXJzXCJcclxuICAgKi9cbiAgZ2V0Q1NTVmFycygpIHtcbiAgICB2YXIgY29tcFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLkRPTS5zY29wZSwgbnVsbCk7XG5cbiAgICBjb25zdCBnZXRQcm9wID0gbmFtZSA9PiBjb21wU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnLS0nICsgbmFtZSk7XG5cbiAgICBmdW5jdGlvbiBzZXByYXRlVW5pdEZyb21WYWx1ZShhKSB7XG4gICAgICBpZiAoIWEpIHJldHVybiB7fTtcbiAgICAgIGEgPSBhLnRyaW0oKS5zcGxpdCgnICcpWzBdO1xuICAgICAgdmFyIHVuaXQgPSBhLnNwbGl0KC9cXGQrL2cpLmZpbHRlcihuID0+IG4pLnBvcCgpLnRyaW0oKSxcbiAgICAgICAgICB2YWx1ZSA9ICthLnNwbGl0KHVuaXQpLmZpbHRlcihuID0+IG4pWzBdLnRyaW0oKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB1bml0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuQ1NTVmFycyA9IHtcbiAgICAgIHRhZ0hpZGVUcmFuc2l0aW9uOiAoKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHVuaXRcbiAgICAgIH0pID0+IHVuaXQgPT0gJ3MnID8gdmFsdWUgKiAxMDAwIDogdmFsdWUpKHNlcHJhdGVVbml0RnJvbVZhbHVlKGdldFByb3AoJ3RhZy1oaWRlLXRyYW5zaXRpb24nKSkpXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBidWlsZHMgdGhlIEhUTUwgb2YgdGhpcyBjb21wb25lbnRcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGlucHV0IFtET00gZWxlbWVudCB3aGljaCB3b3VsZCBiZSBcInRyYW5zZm9ybWVkXCIgaW50byBcIlRhZ3NcIl1cclxuICAgKi9cbiAgYnVpbGQoaW5wdXQpIHtcbiAgICB2YXIgRE9NID0gdGhpcy5ET007XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5taXhNb2RlLmludGVncmF0ZWQpIHtcbiAgICAgIERPTS5vcmlnaW5hbElucHV0ID0gbnVsbDtcbiAgICAgIERPTS5zY29wZSA9IGlucHV0O1xuICAgICAgRE9NLmlucHV0ID0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTS5vcmlnaW5hbElucHV0ID0gaW5wdXQ7XG4gICAgICBET00uc2NvcGUgPSB0aGlzLnBhcnNlVGVtcGxhdGUoJ3dyYXBwZXInLCBbaW5wdXQsIHRoaXMuc2V0dGluZ3NdKTtcbiAgICAgIERPTS5pbnB1dCA9IERPTS5zY29wZS5xdWVyeVNlbGVjdG9yKHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy5pbnB1dFNlbGVjdG9yKTtcbiAgICAgIGlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKERPTS5zY29wZSwgaW5wdXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiByZXZlcnQgYW55IGNoYW5nZXMgbWFkZSBieSB0aGlzIGNvbXBvbmVudFxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzLnVuYmluZEdsb2JhbC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuRE9NLnNjb3BlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ET00uc2NvcGUpO1xuICAgIHRoaXMuZHJvcGRvd24uaGlkZSh0cnVlKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5kcm9wZG93bkhpZGVfX2JpbmRFdmVudHNUaW1lb3V0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBpZiB0aGUgb3JpZ2luYWwgaW5wdXQgaGFkIGFueSB2YWx1ZXMsIGFkZCB0aGVtIGFzIHRhZ3NcclxuICAgKi9cbiAgbG9hZE9yaWdpbmFsVmFsdWVzKHZhbHVlKSB7XG4gICAgdmFyIGxhc3RDaGlsZCxcbiAgICAgICAgX3MgPSB0aGlzLnNldHRpbmdzO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHBlcnNpc3RlZE9yaWdpbmFsVmFsdWUgPSB0aGlzLmdldFBlcnNpc3RlZERhdGEoJ3ZhbHVlJyk7IC8vIGlmIHRoZSBmaWVsZCBhbHJlYWR5IGhhcyBhIGZpZWxkLCB0cnVzdCBpdHMgdGhlIGRlc2lyZWRcbiAgICAgIC8vIG9uZSB0byBiZSByZW5kZXJlZCBhbmQgZG8gbm90IHVzZSB0aGUgcGVyc2lzdGVkIG9uZVxuXG4gICAgICBpZiAocGVyc2lzdGVkT3JpZ2luYWxWYWx1ZSAmJiAhdGhpcy5ET00ub3JpZ2luYWxJbnB1dC52YWx1ZSkgdmFsdWUgPSBwZXJzaXN0ZWRPcmlnaW5hbFZhbHVlO2Vsc2UgdmFsdWUgPSBfcy5taXhNb2RlLmludGVncmF0ZWQgPyB0aGlzLkRPTS5pbnB1dC50ZXh0Q29udGVudCA6IHRoaXMuRE9NLm9yaWdpbmFsSW5wdXQudmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVBbGxUYWdzKHtcbiAgICAgIHdpdGhvdXRDaGFuZ2VFdmVudDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoX3MubW9kZSA9PSAnbWl4Jykge1xuICAgICAgICB0aGlzLnBhcnNlTWl4VGFncyh2YWx1ZS50cmltKCkpO1xuICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLkRPTS5pbnB1dC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdENoaWxkIHx8IGxhc3RDaGlsZC50YWdOYW1lICE9ICdCUicpIHRoaXMuRE9NLmlucHV0Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgJzxicj4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKEpTT04ucGFyc2UodmFsdWUpIGluc3RhbmNlb2YgQXJyYXkpIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgICAgICB0aGlzLmFkZFRhZ3ModmFsdWUpLmZvckVhY2godGFnID0+IHRhZyAmJiB0YWcuY2xhc3NMaXN0LmFkZChfcy5jbGFzc05hbWVzLnRhZ05vQW5pbWF0aW9uKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHRoaXMucG9zdFVwZGF0ZSgpO1xuXG4gICAgdGhpcy5zdGF0ZS5sYXN0T3JpZ2luYWxWYWx1ZVJlcG9ydGVkID0gX3MubWl4TW9kZS5pbnRlZ3JhdGVkID8gJycgOiB0aGlzLkRPTS5vcmlnaW5hbElucHV0LnZhbHVlO1xuICAgIHRoaXMuc3RhdGUubG9hZGVkT3JpZ2luYWxWYWx1ZXMgPSB0cnVlO1xuICB9LFxuXG4gIGNsb25lRXZlbnQoZSkge1xuICAgIHZhciBjbG9uZWRFdmVudCA9IHt9O1xuXG4gICAgZm9yICh2YXIgdiBpbiBlKSBjbG9uZWRFdmVudFt2XSA9IGVbdl07XG5cbiAgICByZXR1cm4gY2xvbmVkRXZlbnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVG9vZ2xlIGdsb2JhbCBsb2FkaW5nIHN0YXRlIG9uL29mZlxyXG4gICAqIFVzZWZ1bCB3aGVuIGZldGNoaW5nIGFzeW5jIHdoaXRlbGlzdCB3aGlsZSB1c2VyIGlzIHR5cGluZ1xyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNMb2FkaW5nXHJcbiAgICovXG4gIGxvYWRpbmcoaXNMb2FkaW5nKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0xvYWRpbmcgPSBpc0xvYWRpbmc7IC8vIElFMTEgZG9lc24ndCBzdXBwb3J0IHRvZ2dsZSB3aXRoIHNlY29uZCBwYXJhbWV0ZXJcblxuICAgIHRoaXMuRE9NLnNjb3BlLmNsYXNzTGlzdFtpc0xvYWRpbmcgPyBcImFkZFwiIDogXCJyZW1vdmVcIl0odGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnNjb3BlTG9hZGluZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVG9vZ2xlIHNwZWNpZWlmIHRhZyBsb2FkaW5nIHN0YXRlIG9uL29mZlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNMb2FkaW5nXHJcbiAgICovXG4gIHRhZ0xvYWRpbmcodGFnRWxtLCBpc0xvYWRpbmcpIHtcbiAgICBpZiAodGFnRWxtKSAvLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCB0b2dnbGUgd2l0aCBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICB0YWdFbG0uY2xhc3NMaXN0W2lzTG9hZGluZyA/IFwiYWRkXCIgOiBcInJlbW92ZVwiXSh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMudGFnTG9hZGluZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVG9nZ2xlcyBjbGFzcyBvbiB0aGUgbWFpbiB0YWdpZnkgY29udGFpbmVyIChcInNjb3BlXCIpXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VcclxuICAgKi9cbiAgdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCBmb3JjZSkge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09ICdzdHJpbmcnKSB0aGlzLkRPTS5zY29wZS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgZm9yY2UpO1xuICB9LFxuXG4gIHRvZ2dsZUZvY3VzQ2xhc3MoZm9yY2UpIHtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzKHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy5mb2N1cywgISFmb3JjZSk7XG4gIH0sXG5cbiAgdHJpZ2dlckNoYW5nZUV2ZW50LFxuICBldmVudHMsXG5cbiAgZml4RmlyZWZveExhc3RUYWdOb0NhcmV0KCkge1xuICAgIHJldHVybjsgLy8gc2VlbXMgdG8gYmUgZml4ZWQgaW4gbmV3ZXIgdmVyc2lvbiBvZiBGRiwgc28gcmV0aXJpbmcgYmVsb3cgY29kZSAoZm9yIG5vdylcbiAgfSxcblxuICBwbGFjZUNhcmV0QWZ0ZXJOb2RlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUucGFyZW50Tm9kZSkgcmV0dXJuO1xuICAgIHZhciBuZXh0U2libGluZyA9IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcblxuICAgIGlmIChzZWwucmFuZ2VDb3VudCkge1xuICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcihuZXh0U2libGluZyB8fCBub2RlKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpOyAvLyByYW5nZS5zZXRFbmRCZWZvcmUobmV4dFNpYmxpbmcgfHwgbm9kZSk7XG5cbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9LFxuXG4gIGluc2VydEFmdGVyVGFnKHRhZ0VsbSwgbmV3Tm9kZSkge1xuICAgIG5ld05vZGUgPSBuZXdOb2RlIHx8IHRoaXMuc2V0dGluZ3MubWl4TW9kZS5pbnNlcnRBZnRlclRhZztcbiAgICBpZiAoIXRhZ0VsbSB8fCAhdGFnRWxtLnBhcmVudE5vZGUgfHwgIW5ld05vZGUpIHJldHVybjtcbiAgICBuZXdOb2RlID0gdHlwZW9mIG5ld05vZGUgPT0gJ3N0cmluZycgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdOb2RlKSA6IG5ld05vZGU7XG4gICAgdGFnRWxtLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHRhZ0VsbS5uZXh0U2libGluZyk7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRW50ZXJzIGEgdGFnIGludG8gXCJlZGl0XCIgbW9kZVxyXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFnRWxtIHRoZSB0YWcgZWxlbWVudCB0byBlZGl0LiBpZiBub3RoaW5nIHNwZWNpZmllZCwgdXNlIGxhc3QgbGFzdFxyXG4gICAqL1xuICBlZGl0VGFnKHRhZ0VsbSwgb3B0cykge1xuICAgIHRhZ0VsbSA9IHRhZ0VsbSB8fCB0aGlzLmdldExhc3RUYWcoKTtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLmRyb3Bkb3duLmhpZGUoKTtcbiAgICB2YXIgX3MgPSB0aGlzLnNldHRpbmdzO1xuXG4gICAgZnVuY3Rpb24gZ2V0RWRpdGFibGVFbG0oKSB7XG4gICAgICByZXR1cm4gdGFnRWxtLnF1ZXJ5U2VsZWN0b3IoX3MuY2xhc3NOYW1lcy50YWdUZXh0U2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHZhciBlZGl0YWJsZUVsbSA9IGdldEVkaXRhYmxlRWxtKCksXG4gICAgICAgIHRhZ0lkeCA9IHRoaXMuZ2V0Tm9kZUluZGV4KHRhZ0VsbSksXG4gICAgICAgIHRhZ0RhdGEgPSB0aGlzLnRhZ0RhdGEodGFnRWxtKSxcbiAgICAgICAgX0NCID0gdGhpcy5ldmVudHMuY2FsbGJhY2tzLFxuICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgaXNWYWxpZCA9IHRydWUsXG4gICAgICAgIGRlbGF5ZWRfb25FZGl0VGFnQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gX0NCLm9uRWRpdFRhZ0JsdXIuY2FsbCh0aGF0LCBnZXRFZGl0YWJsZUVsbSgpKSk7XG4gICAgfTtcblxuICAgIGlmICghZWRpdGFibGVFbG0pIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IGZpbmQgZWxlbWVudCBpbiBUYWcgdGVtcGxhdGU6IC4nLCBfcy5jbGFzc05hbWVzLnRhZ1RleHRTZWxlY3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRhZ0RhdGEgaW5zdGFuY2VvZiBPYmplY3QgJiYgXCJlZGl0YWJsZVwiIGluIHRhZ0RhdGEgJiYgIXRhZ0RhdGEuZWRpdGFibGUpIHJldHVybjtcbiAgICBlZGl0YWJsZUVsbS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuICAgIHRhZ0VsbS5jbGFzc0xpc3QuYWRkKF9zLmNsYXNzTmFtZXMudGFnRWRpdGluZyk7IC8vIGNhY2hlIHRoZSBvcmlnaW5hbCBkYXRhLCBvbiB0aGUgRE9NIG5vZGUsIGJlZm9yZSBhbnkgbW9kaWZpY2F0aW9uIG9jdXJzLCBmb3IgcG9zc2libGUgcmV2ZXJ0XG5cbiAgICB0aGlzLnRhZ0RhdGEodGFnRWxtLCB7XG4gICAgICBfX29yaWdpbmFsRGF0YTogZXh0ZW5kKHt9LCB0YWdEYXRhKSxcbiAgICAgIF9fb3JpZ2luYWxIVE1MOiB0YWdFbG0uaW5uZXJIVE1MXG4gICAgfSk7XG4gICAgZWRpdGFibGVFbG0uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBfQ0Iub25FZGl0VGFnRm9jdXMuYmluZCh0aGlzLCB0YWdFbG0pKTtcbiAgICBlZGl0YWJsZUVsbS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZGVsYXllZF9vbkVkaXRUYWdCbHVyKTtcbiAgICBlZGl0YWJsZUVsbS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIF9DQi5vbkVkaXRUYWdJbnB1dC5iaW5kKHRoaXMsIGVkaXRhYmxlRWxtKSk7XG4gICAgZWRpdGFibGVFbG0uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4gX0NCLm9uRWRpdFRhZ2tleWRvd24uY2FsbCh0aGlzLCBlLCB0YWdFbG0pKTtcbiAgICBlZGl0YWJsZUVsbS5mb2N1cygpO1xuICAgIHRoaXMuc2V0UmFuZ2VBdFN0YXJ0RW5kKGZhbHNlLCBlZGl0YWJsZUVsbSk7XG4gICAgaWYgKCFvcHRzLnNraXBWYWxpZGF0aW9uKSBpc1ZhbGlkID0gdGhpcy5lZGl0VGFnVG9nZ2xlVmFsaWRpdHkodGFnRWxtKTtcbiAgICBlZGl0YWJsZUVsbS5vcmlnaW5hbElzVmFsaWQgPSBpc1ZhbGlkO1xuICAgIHRoaXMudHJpZ2dlcihcImVkaXQ6c3RhcnRcIiwge1xuICAgICAgdGFnOiB0YWdFbG0sXG4gICAgICBpbmRleDogdGFnSWR4LFxuICAgICAgZGF0YTogdGFnRGF0YSxcbiAgICAgIGlzVmFsaWRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcclxuICAgKiBJZiBhIHRhZyBpcyBpbnZhbGlkLCBmb3IgYW55IHJlYXNvbiwgc2V0IGl0cyBjbGFzcyB0byBhcyBcIm5vdCBhbGxvd2VkXCIgKHNlZSBkZWZhdWx0cyBmaWxlKVxyXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFnRWxtIHJlcXVpcmVkXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhZ0RhdGEgb3B0aW9uYWxcclxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHZhbGlkLCBhIHN0cmluZyAocmVhc29uKSBpZiBub3RcclxuICAgKi9cbiAgZWRpdFRhZ1RvZ2dsZVZhbGlkaXR5KHRhZ0VsbSwgdGFnRGF0YSkge1xuICAgIHZhciB0YWdEYXRhID0gdGFnRGF0YSB8fCB0aGlzLnRhZ0RhdGEodGFnRWxtKSxcbiAgICAgICAgaXNWYWxpZDtcblxuICAgIGlmICghdGFnRGF0YSkge1xuICAgICAgY29uc29sZS53YXJuKFwidGFnIGhhcyBubyBkYXRhOiBcIiwgdGFnRWxtLCB0YWdEYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1ZhbGlkID0gIShcIl9faXNWYWxpZFwiIGluIHRhZ0RhdGEpIHx8IHRhZ0RhdGEuX19pc1ZhbGlkID09PSB0cnVlO1xuXG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZ3NGcm9tVmFsdWUodGFnRWxtKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZSgpOyAvL3RoaXMudmFsaWRhdGVUYWcodGFnRGF0YSk7XG5cbiAgICB0YWdFbG0uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMudGFnTm90QWxsb3dlZCwgIWlzVmFsaWQpO1xuICAgIHJldHVybiB0YWdEYXRhLl9faXNWYWxpZDtcbiAgfSxcblxuICBvbkVkaXRUYWdEb25lKHRhZ0VsbSwgdGFnRGF0YSkge1xuICAgIHRhZ0VsbSA9IHRhZ0VsbSB8fCB0aGlzLnN0YXRlLmVkaXRpbmcuc2NvcGU7XG4gICAgdGFnRGF0YSA9IHRhZ0RhdGEgfHwge307XG4gICAgdmFyIGV2ZW50RGF0YSA9IHtcbiAgICAgIHRhZzogdGFnRWxtLFxuICAgICAgaW5kZXg6IHRoaXMuZ2V0Tm9kZUluZGV4KHRhZ0VsbSksXG4gICAgICBwcmV2aW91c0RhdGE6IHRoaXMudGFnRGF0YSh0YWdFbG0pLFxuICAgICAgZGF0YTogdGFnRGF0YVxuICAgIH07XG4gICAgdGhpcy50cmlnZ2VyKFwiZWRpdDpiZWZvcmVVcGRhdGVcIiwgZXZlbnREYXRhLCB7XG4gICAgICBjbG9uZURhdGE6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5lZGl0aW5nID0gZmFsc2U7XG4gICAgZGVsZXRlIHRhZ0RhdGEuX19vcmlnaW5hbERhdGE7XG4gICAgZGVsZXRlIHRhZ0RhdGEuX19vcmlnaW5hbEhUTUw7XG5cbiAgICBpZiAodGFnRWxtICYmIHRhZ0RhdGFbdGhpcy5zZXR0aW5ncy50YWdUZXh0UHJvcF0pIHtcbiAgICAgIHRhZ0VsbSA9IHRoaXMucmVwbGFjZVRhZyh0YWdFbG0sIHRhZ0RhdGEpO1xuICAgICAgdGhpcy5lZGl0VGFnVG9nZ2xlVmFsaWRpdHkodGFnRWxtLCB0YWdEYXRhKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmExMXkuZm9jdXNhYmxlVGFncykgdGFnRWxtLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmICh0YWdFbG0pIHRoaXMucmVtb3ZlVGFncyh0YWdFbG0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwiZWRpdDp1cGRhdGVkXCIsIGV2ZW50RGF0YSk7XG4gICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7IC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgY3VycmVudCB0YWdzIHdoaWNoIG1pZ2h0IGhhdmUgYmVlbiBtYXJrZWQgYXMgXCJkdXBsaWNhdGVcIiBzaG91bGQgYmUgbm93IHVuLW1hcmtlZFxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mua2VlcEludmFsaWRUYWdzKSB0aGlzLnJlQ2hlY2tJbnZhbGlkVGFncygpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJlcGxhY2VzIGFuIGV4aXNpdG5nIHRhZyB3aXRoIGEgbmV3IG9uZS4gVXNlZCBmb3IgdXBkYXRpbmcgYSB0YWcncyBkYXRhXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhZ0VsbSAgW0RPTSBub2RlIHRvIHJlcGxhY2VdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhZ0RhdGEgW2RhdGEgdG8gY3JlYXRlIG5ldyB0YWcgZnJvbV1cclxuICAgKi9cbiAgcmVwbGFjZVRhZyh0YWdFbG0sIHRhZ0RhdGEpIHtcbiAgICBpZiAoIXRhZ0RhdGEgfHwgIXRhZ0RhdGEudmFsdWUpIHRhZ0RhdGEgPSB0YWdFbG0uX190YWdpZnlUYWdEYXRhOyAvLyBpZiB0YWcgaXMgaW52YWxpZCwgbWFrZSB0aGUgYWNjb3JkaW5nIGNoYW5nZXMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuXG4gICAgaWYgKHRhZ0RhdGEuX19pc1ZhbGlkICYmIHRhZ0RhdGEuX19pc1ZhbGlkICE9IHRydWUpIGV4dGVuZCh0YWdEYXRhLCB0aGlzLmdldEludmFsaWRUYWdBdHRycyh0YWdEYXRhLCB0YWdEYXRhLl9faXNWYWxpZCkpO1xuICAgIHZhciBuZXdUYWdFbG0gPSB0aGlzLmNyZWF0ZVRhZ0VsZW0odGFnRGF0YSk7IC8vIHVwZGF0ZSBET01cblxuICAgIHRhZ0VsbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdUYWdFbG0sIHRhZ0VsbSk7XG4gICAgdGhpcy51cGRhdGVWYWx1ZUJ5RE9NVGFncygpO1xuICAgIHJldHVybiBuZXdUYWdFbG07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogdXBkYXRlIFwidmFsdWVcIiAoQXJyYXkgb2YgT2JqZWN0cykgYnkgdHJhdmVyc2luZyBhbGwgdmFsaWQgdGFnc1xyXG4gICAqL1xuICB1cGRhdGVWYWx1ZUJ5RE9NVGFncygpIHtcbiAgICB0aGlzLnZhbHVlLmxlbmd0aCA9IDA7XG4gICAgW10uZm9yRWFjaC5jYWxsKHRoaXMuZ2V0VGFnRWxtcygpLCBub2RlID0+IHtcbiAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMudGFnTm90QWxsb3dlZC5zcGxpdCgnICcpWzBdKSkgcmV0dXJuO1xuICAgICAgdGhpcy52YWx1ZS5wdXNoKHRoaXMudGFnRGF0YShub2RlKSk7XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSxcblxuICAvKiogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU5MTU2ODcyLzEwNDM4MFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhcnQgaW5kaWNhdGluZyB3aGVyZSB0byBwbGFjZSBpdCAoc3RhcnQgb3IgZW5kIG9mIHRoZSBub2RlKVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgbm9kZSAgRE9NIG5vZGUgdG8gcGxhY2UgdGhlIGNhcmV0IGF0XHJcbiAgICovXG4gIHNldFJhbmdlQXRTdGFydEVuZChzdGFydCwgbm9kZSkge1xuICAgIHN0YXJ0ID0gdHlwZW9mIHN0YXJ0ID09ICdudW1iZXInID8gc3RhcnQgOiAhIXN0YXJ0O1xuICAgIG5vZGUgPSBub2RlIHx8IHRoaXMuRE9NLmlucHV0O1xuICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZCB8fCBub2RlO1xuICAgIHZhciBzZWwgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoc2VsLnJhbmdlQ291bnQgPj0gMSkge1xuICAgICAgICBbJ1N0YXJ0JywgJ0VuZCddLmZvckVhY2gocG9zID0+IHNlbC5nZXRSYW5nZUF0KDApW1wic2V0XCIgKyBwb3NdKG5vZGUsIHN0YXJ0ID8gc3RhcnQgOiBub2RlLmxlbmd0aCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikgey8vIGNvbnNvbGUud2FybihcIlRhZ2lmeTogXCIsIGVycilcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogaW5qZWN0cyBub2Rlcy90ZXh0IGF0IGNhcmV0IHBvc2l0aW9uLCB3aGljaCBpcyBzYXZlZCBvbiB0aGUgXCJzdGF0ZVwiIHdoZW4gXCJibHVyXCIgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcclxuICAgKiBAcGFyYW0ge05vZGV9IGluamVjdGVkTm9kZSBbdGhlIG5vZGUgdG8gaW5qZWN0IGF0IHRoZSBjYXJldCBwb3NpdGlvbl1cclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZWN0aW9uIFtvcHRpb25hbCByYW5nZSBPYmplY3QuIG11c3QgaGF2ZSBcImFuY2hvck5vZGVcIiAmIFwiYW5jaG9yT2Zmc2V0XCJdXHJcbiAgICovXG4gIGluamVjdEF0Q2FyZXQoaW5qZWN0ZWROb2RlLCByYW5nZSkge1xuICAgIHJhbmdlID0gcmFuZ2UgfHwgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2U7XG4gICAgaWYgKCFyYW5nZSkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgaW5qZWN0ZWROb2RlID09ICdzdHJpbmcnKSBpbmplY3RlZE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpbmplY3RlZE5vZGUpO1xuICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgcmFuZ2UuaW5zZXJ0Tm9kZShpbmplY3RlZE5vZGUpO1xuICAgIHRoaXMuc2V0UmFuZ2VBdFN0YXJ0RW5kKGZhbHNlLCBpbmplY3RlZE5vZGUpO1xuICAgIHRoaXMudXBkYXRlVmFsdWVCeURPTVRhZ3MoKTsgLy8gdXBkYXRlcyBpbnRlcm5hbCBcInRoaXMudmFsdWVcIlxuXG4gICAgdGhpcy51cGRhdGUoKTsgLy8gdXBkYXRlcyBvcmlnaW5hbCBpbnB1dC90ZXh0YXJlYVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogaW5wdXQgYnJpZGdlIGZvciBhY2Nlc3NpbmcgJiBzZXR0aW5nXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgaW5wdXQ6IHtcbiAgICBzZXQocyA9ICcnLCB1cGRhdGVET00gPSB0cnVlKSB7XG4gICAgICB2YXIgaGlkZURyb3Bkb3duID0gdGhpcy5zZXR0aW5ncy5kcm9wZG93bi5jbG9zZU9uU2VsZWN0O1xuICAgICAgdGhpcy5zdGF0ZS5pbnB1dFRleHQgPSBzO1xuICAgICAgaWYgKHVwZGF0ZURPTSkgdGhpcy5ET00uaW5wdXQuaW5uZXJIVE1MID0gZXNjYXBlSFRNTChcIlwiICsgcyk7XG4gICAgICBpZiAoIXMgJiYgaGlkZURyb3Bkb3duKSB0aGlzLmRyb3Bkb3duLmhpZGUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuaW5wdXQuYXV0b2NvbXBsZXRlLnN1Z2dlc3QuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaW5wdXQudmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgcmF3KCkge1xuICAgICAgcmV0dXJuIHRoaXMuRE9NLmlucHV0LnRleHRDb250ZW50O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIE1hcmtzIHRoZSB0YWdpZnkncyBpbnB1dCBhcyBcImludmFsaWRcIiBpZiB0aGUgdmFsdWUgZGlkIG5vdCBwYXNzIFwidmFsaWRhdGVUYWcoKVwiXHJcbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gIXRoaXMuc3RhdGUuaW5wdXRUZXh0IHx8IHRoaXMudmFsaWRhdGVUYWcoe1xuICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5pbnB1dFRleHRcbiAgICAgIH0pID09PSB0cnVlO1xuICAgICAgdGhpcy5ET00uaW5wdXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMuaW5wdXRJbnZhbGlkLCAhaXNWYWxpZCk7XG4gICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9LFxuXG4gICAgLy8gcmVtb3ZlIGFueSBjaGlsZCBET00gZWxlbWVudHMgdGhhdCBhcmVuJ3Qgb2YgdHlwZSBURVhUIChsaWtlIDxicj4pXG4gICAgbm9ybWFsaXplKG5vZGUpIHtcbiAgICAgIHZhciBjbG9uZSA9IG5vZGUgfHwgdGhpcy5ET00uaW5wdXQsXG4gICAgICAgICAgLy8uY2xvbmVOb2RlKHRydWUpLFxuICAgICAgdiA9IFtdOyAvLyB3aGVuIGEgdGV4dCB3YXMgcGFzdGVkIGluIEZGLCB0aGUgXCJ0aGlzLkRPTS5pbnB1dFwiIGVsZW1lbnQgd2lsbCBoYXZlIDxicj4gYnV0IG5vIG5ld2xpbmUgc3ltYm9scyAoXFxuKSwgYW5kIHRoaXMgd2lsbFxuICAgICAgLy8gcmVzdWx0IGluIHRhZ3Mgbm90IGJlaW5nIHByb3Blcmx5IGNyZWF0ZWQgaWYgb25lIHdpc2hlcyB0byBjcmVhdGUgYSBzZXBhcmF0ZSB0YWcgcGVyIG5ld2xpbmUuXG5cbiAgICAgIGNsb25lLmNoaWxkTm9kZXMuZm9yRWFjaChuID0+IG4ubm9kZVR5cGUgPT0gMyAmJiB2LnB1c2gobi5ub2RlVmFsdWUpKTtcbiAgICAgIHYgPSB2LmpvaW4oXCJcXG5cIik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFwiZGVsaW1pdGVyc1wiIG1pZ2h0IGJlIG9mIGEgbm9uLXJlZ2V4IHZhbHVlLCB3aGVyZSB0aGlzIHdpbGwgZmFpbCAoXCJUYWdzIFdpdGggUHJvcGVydGllc1wiIGV4YW1wbGUgaW4gZGVtbyBwYWdlKTpcbiAgICAgICAgdiA9IHYucmVwbGFjZSgvKD86XFxyXFxufFxccnxcXG4pL2csIHRoaXMuc2V0dGluZ3MuZGVsaW1pdGVycy5zb3VyY2UuY2hhckF0KDApKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgICAgdiA9IHYucmVwbGFjZSgvXFxzL2csICcgJyk7IC8vIHJlcGxhY2UgTkJTUHMgd2l0aCBzcGFjZXMgY2hhcmFjdGVyc1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmltKSB2ID0gdi5yZXBsYWNlKC9eXFxzKy8sICcnKTsgLy8gdHJpbUxlZnRcblxuICAgICAgcmV0dXJuIHY7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogc3VnZ2VzdCB0aGUgcmVzdCBvZiB0aGUgaW5wdXQncyB2YWx1ZSAodmlhIENTUyBcIjo6YWZ0ZXJcIiB1c2luZyBcImNvbnRlbnQ6YXR0ciguLi4pXCIpXHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXG4gICAgYXV0b2NvbXBsZXRlOiB7XG4gICAgICBzdWdnZXN0KGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmF1dG9Db21wbGV0ZS5lbmFibGVkKSByZXR1cm47XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIGRhdGEgPSB7XG4gICAgICAgICAgdmFsdWU6IGRhdGFcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN1Z2dlc3RlZFRleHQgPSBkYXRhLnZhbHVlID8gJycgKyBkYXRhLnZhbHVlIDogJycsXG4gICAgICAgICAgICBzdWdnZXN0aW9uU3RhcnQgPSBzdWdnZXN0ZWRUZXh0LnN1YnN0cigwLCB0aGlzLnN0YXRlLmlucHV0VGV4dC5sZW5ndGgpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBzdWdnZXN0aW9uVHJpbW1lZCA9IHN1Z2dlc3RlZFRleHQuc3Vic3RyaW5nKHRoaXMuc3RhdGUuaW5wdXRUZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCFzdWdnZXN0ZWRUZXh0IHx8ICF0aGlzLnN0YXRlLmlucHV0VGV4dCB8fCBzdWdnZXN0aW9uU3RhcnQgIT0gdGhpcy5zdGF0ZS5pbnB1dFRleHQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHRoaXMuRE9NLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc3VnZ2VzdFwiKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdGF0ZS5pbnB1dFN1Z2dlc3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ET00uaW5wdXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdWdnZXN0XCIsIHN1Z2dlc3Rpb25UcmltbWVkKTtcbiAgICAgICAgICB0aGlzLnN0YXRlLmlucHV0U3VnZ2VzdGlvbiA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxyXG4gICAgICAgKiBzZXRzIHRoZSBzdWdnZXN0ZWQgdGV4dCBhcyB0aGUgaW5wdXQncyB2YWx1ZSAmIGNsZWFudXAgdGhlIHN1Z2dlc3Rpb24gYXV0b2NvbXBsZXRlLlxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcyBbdGV4dF1cclxuICAgICAgICovXG4gICAgICBzZXQocykge1xuICAgICAgICB2YXIgZGF0YVN1Z2dlc3QgPSB0aGlzLkRPTS5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3VnZ2VzdCcpLFxuICAgICAgICAgICAgc3VnZ2VzdGlvbiA9IHMgfHwgKGRhdGFTdWdnZXN0ID8gdGhpcy5zdGF0ZS5pbnB1dFRleHQgKyBkYXRhU3VnZ2VzdCA6IG51bGwpO1xuXG4gICAgICAgIGlmIChzdWdnZXN0aW9uKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubW9kZSA9PSAnbWl4Jykge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlVGV4dFdpdGhOb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuc3RhdGUudGFnLnByZWZpeCArIHN1Z2dlc3Rpb24pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXQuY2FsbCh0aGlzLCBzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VBdFN0YXJ0RW5kKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5pbnB1dC5hdXRvY29tcGxldGUuc3VnZ2VzdC5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSB0aGUgdGFnRGF0YSB3aXRoaW4gdGhlIFwidGhpcy52YWx1ZVwiIGFycmF5IGNvbGxlY3Rpb24uXHJcbiAgICogc2luY2UgdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUsIGl0IGlzIHN1ZmZpY2UgdG8gb25seSBzZWFyY2ggYnkgXCJ2YWx1ZVwiIHByb3BlcnR5XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhZ0RhdGFcclxuICAgKi9cbiAgZ2V0VGFnSWR4KHRhZ0RhdGEpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLl9fdGFnSWQgPT0gKHRhZ0RhdGEgfHwge30pLl9fdGFnSWQpO1xuICB9LFxuXG4gIGdldE5vZGVJbmRleChub2RlKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobm9kZSkgd2hpbGUgKG5vZGUgPSBub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIGluZGV4Kys7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9LFxuXG4gIGdldFRhZ0VsbXMoLi4uY2xhc3Nlc3MpIHtcbiAgICB2YXIgY2xhc3NuYW1lID0gJy4nICsgWy4uLnRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy50YWcuc3BsaXQoJyAnKSwgLi4uY2xhc3Nlc3NdLmpvaW4oJy4nKTtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLkRPTS5zY29wZS5xdWVyeVNlbGVjdG9yQWxsKGNsYXNzbmFtZSkpOyAvLyBjb252ZXJ0IG5vZGVMaXN0IHRvIEFycmF5IC0gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxOTk2MjcvMTA0MzgwXG4gIH0sXG5cbiAgLyoqXHJcbiAgICogZ2V0cyB0aGUgbGFzdCBub24tcmVhZG9ubHksIG5vdC1pbi10aGUtcHJvY2Nlc3Mtb2YtcmVtb3ZhbCB0YWdcclxuICAgKi9cbiAgZ2V0TGFzdFRhZygpIHtcbiAgICB2YXIgbGFzdFRhZyA9IHRoaXMuRE9NLnNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoYCR7dGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZ1NlbGVjdG9yfTpub3QoLiR7dGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZ0hpZGV9KTpub3QoW3JlYWRvbmx5XSlgKTtcbiAgICByZXR1cm4gbGFzdFRhZ1tsYXN0VGFnLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIC8qKiBTZXR0ZXIvR2V0dGVyXHJcbiAgICogRWFjaCB0YWcgRE9NIG5vZGUgY29udGFpbnMgYSBjdXN0b20gcHJvcGVydHkgY2FsbGVkIFwiX190YWdpZnlUYWdEYXRhXCIgd2hpY2ggaG9zdHMgaXRzIGRhdGFcclxuICAgKiBAcGFyYW0ge05vZGV9ICAgdGFnRWxtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICAgKi9cbiAgdGFnRGF0YSh0YWdFbG0sIGRhdGEsIG92ZXJyaWRlKSB7XG4gICAgaWYgKCF0YWdFbG0pIHtcbiAgICAgIGNvbnNvbGUud2FybihcInRhZyBlbG1lbnQgZG9lc24ndCBleGlzdFwiLCB0YWdFbG0sIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHRhZ0VsbS5fX3RhZ2lmeVRhZ0RhdGEgPSBvdmVycmlkZSA/IGRhdGEgOiBleHRlbmQoe30sIHRhZ0VsbS5fX3RhZ2lmeVRhZ0RhdGEgfHwge30sIGRhdGEpO1xuICAgIHJldHVybiB0YWdFbG0uX190YWdpZnlUYWdEYXRhO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNlYXJjaGVzIGlmIGFueSB0YWcgd2l0aCBhIGNlcnRhaW4gdmFsdWUgYWxyZWFkeSBleGlzXHJcbiAgICogQHBhcmFtICB7U3RyaW5nL09iamVjdH0gdiBbdGV4dCB2YWx1ZSAvIHRhZyBkYXRhIG9iamVjdF1cclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xuICBpc1RhZ0R1cGxpY2F0ZSh2YWx1ZSwgY2FzZVNlbnNpdGl2ZSkge1xuICAgIHZhciBkdXBsaWNhdGlvbnMsXG4gICAgICAgIF9zID0gdGhpcy5zZXR0aW5nczsgLy8gZHVwbGljYXRpb25zIGFyZSBpcnJlbGV2YW50IGZvciB0aGlzIHNjZW5hcmlvXG5cbiAgICBpZiAoX3MubW9kZSA9PSAnc2VsZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIGR1cGxpY2F0aW9ucyA9IHRoaXMudmFsdWUucmVkdWNlKChhY2MsIGl0ZW0pID0+IHNhbWVTdHIodGhpcy50cmltKFwiXCIgKyB2YWx1ZSksIGl0ZW0udmFsdWUsIGNhc2VTZW5zaXRpdmUgfHwgX3MuZHJvcGRvd24uY2FzZVNlbnNpdGl2ZSkgPyBhY2MgKyAxIDogYWNjLCAwKTtcbiAgICByZXR1cm4gZHVwbGljYXRpb25zO1xuICB9LFxuXG4gIGdldFRhZ0luZGV4QnlWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgdGhpcy5nZXRUYWdFbG1zKCkuZm9yRWFjaCgodGFnRWxtLCBpKSA9PiB7XG4gICAgICBpZiAoc2FtZVN0cih0aGlzLnRyaW0odGFnRWxtLnRleHRDb250ZW50KSwgdmFsdWUsIHRoaXMuc2V0dGluZ3MuZHJvcGRvd24uY2FzZVNlbnNpdGl2ZSkpIGluZGljZXMucHVzaChpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfSxcblxuICBnZXRUYWdFbG1CeVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHRhZ0lkeCA9IHRoaXMuZ2V0VGFnSW5kZXhCeVZhbHVlKHZhbHVlKVswXTtcbiAgICByZXR1cm4gdGhpcy5nZXRUYWdFbG1zKClbdGFnSWR4XTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUZW1wb3JhcmlseSBtYXJrcyBhIHRhZyBlbGVtZW50IChieSB2YWx1ZSBvciBOb2RlIGFyZ3VtZW50KVxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFnRWxtIFthIHNwZWNpZmljIFwidGFnXCIgZWxlbWVudCB0byBjb21wYXJlIHRvIHRoZSBvdGhlciB0YWcgZWxlbWVudHMgc2libGluZ3NdXHJcbiAgICovXG4gIGZsYXNoVGFnKHRhZ0VsbSkge1xuICAgIGlmICh0YWdFbG0pIHtcbiAgICAgIHRhZ0VsbS5jbGFzc0xpc3QuYWRkKHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lcy50YWdGbGFzaCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFnRWxtLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZ0ZsYXNoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIGNoZWNrcyBpZiB0ZXh0IGlzIGluIHRoZSBibGFja2xpc3RcclxuICAgKi9cbiAgaXNUYWdCbGFja2xpc3RlZCh2KSB7XG4gICAgdiA9IHRoaXMudHJpbSh2LnRvTG93ZXJDYXNlKCkpO1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmJsYWNrbGlzdC5maWx0ZXIoeCA9PiAoXCJcIiArIHgpLnRvTG93ZXJDYXNlKCkgPT0gdikubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIGNoZWNrcyBpZiB0ZXh0IGlzIGluIHRoZSB3aGl0ZWxpc3RcclxuICAgKi9cbiAgaXNUYWdXaGl0ZWxpc3RlZCh2KSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRXaGl0ZWxpc3RJdGVtKHYpO1xuICAgIC8qXHJcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy53aGl0ZWxpc3Quc29tZShpdGVtID0+XHJcbiAgICAgICAgdHlwZW9mIHYgPT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBzYW1lU3RyKHRoaXMudHJpbSh2KSwgKGl0ZW0udmFsdWUgfHwgaXRlbSkpXHJcbiAgICAgICAgICAgIDogc2FtZVN0cihKU09OLnN0cmluZ2lmeShpdGVtKSwgSlNPTi5zdHJpbmdpZnkodikpXHJcbiAgICApXHJcbiAgICAqL1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHdoaXRlbGlzdCBpdGVtIG1hdGNoZWQsIGJ5IHZhbHVlIChpZiBtYXRjaCBmb3VuZClcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgW3RleHQgdG8gbWF0Y2ggYnldXHJcbiAgICovXG4gIGdldFdoaXRlbGlzdEl0ZW0odmFsdWUsIHByb3AsIHdoaXRlbGlzdCkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIHByb3AgPSBwcm9wIHx8ICd2YWx1ZScsXG4gICAgICAgIF9zID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgd2hpdGVsaXN0ID0gd2hpdGVsaXN0IHx8IF9zLndoaXRlbGlzdDtcbiAgICB3aGl0ZWxpc3Quc29tZShfd2kgPT4ge1xuICAgICAgdmFyIF93aXYgPSB0eXBlb2YgX3dpID09ICdzdHJpbmcnID8gX3dpIDogX3dpW3Byb3BdIHx8IF93aS52YWx1ZSxcbiAgICAgICAgICBpc1NhbWVTdHIgPSBzYW1lU3RyKF93aXYsIHZhbHVlLCBfcy5kcm9wZG93bi5jYXNlU2Vuc2l0aXZlLCBfcy50cmltKTtcblxuICAgICAgaWYgKGlzU2FtZVN0cikge1xuICAgICAgICByZXN1bHQgPSB0eXBlb2YgX3dpID09ICdzdHJpbmcnID8ge1xuICAgICAgICAgIHZhbHVlOiBfd2lcbiAgICAgICAgfSA6IF93aTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIGZpcnN0IGl0ZXJhdGUgdGhlIHdoaXRlbGlzdCwgdHJ5IGZpbmQgbWFjaGVzIGJ5IFwidmFsdWVcIiBhbmQgaWYgdGhhdCBmYWlsc1xuICAgIC8vIGFuZCBhIFwidGFnVGV4dFByb3BcIiBpcyBzZXQgdG8gYmUgb3RoZXIgdGhhbiBcInZhbHVlXCIsIHRyeSB0aGF0IGFsc29cblxuICAgIGlmICghcmVzdWx0ICYmIHByb3AgPT0gJ3ZhbHVlJyAmJiBfcy50YWdUZXh0UHJvcCAhPSAndmFsdWUnKSB7XG4gICAgICAvLyBpZiBmb3VuZCwgYWRkcyB0aGUgZmlyc3Qgd2hpY2ggbWF0Y2hlc1xuICAgICAgcmVzdWx0ID0gdGhpcy5nZXRXaGl0ZWxpc3RJdGVtKHZhbHVlLCBfcy50YWdUZXh0UHJvcCwgd2hpdGVsaXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIHZhbGlkYXRlIGEgdGFnIG9iamVjdCBCRUZPUkUgdGhlIGFjdHVhbCB0YWcgd2lsbCBiZSBjcmVhdGVkICYgYXBwZW5lZGVkXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSB1aWQgICAgICBbdW5pcXVlIElELCB0byBub3QgaW5jbHVlIG93biB0YWcgd2hlbiBjaGVraW5nIGZvciBkdXBsaWNhdGVzXVxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW4vU3RyaW5nfSAgW1widHJ1ZVwiIGlmIHZhbGlkYXRpb24gaGFzIHBhc3NlZCwgU3RyaW5nIGZvciBhIGZhaWxdXHJcbiAgICovXG4gIHZhbGlkYXRlVGFnKHRhZ0RhdGEpIHtcbiAgICB2YXIgX3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICAvLyB3aGVuIHZhbGlkYXRpbmcgYSB0YWcgaW4gZWRpdC1tb2RlLCBuZWVkIHRvIHRha2UgXCJ0YWdUZXh0UHJvcFwiIGludG8gY29uc2lkZXJhdGlvblxuICAgIHByb3AgPSBcInZhbHVlXCIgaW4gdGFnRGF0YSA/IFwidmFsdWVcIiA6IF9zLnRhZ1RleHRQcm9wLFxuICAgICAgICB2ID0gdGhpcy50cmltKHRhZ0RhdGFbcHJvcF0gKyBcIlwiKTsgLy8gY2hlY2sgZm9yIGRlZmluaXRpdmUgZW1wdHkgdmFsdWVcblxuICAgIGlmICghKHRhZ0RhdGFbcHJvcF0gKyBcIlwiKS50cmltKCkpIHJldHVybiB0aGlzLlRFWFRTLmVtcHR5OyAvLyBjaGVjayBpZiBwYXR0ZXJuIHNob3VsZCBiZSB1c2VkIGFuZCBpZiBzbywgdXNlIGl0IHRvIHRlc3QgdGhlIHZhbHVlXG5cbiAgICBpZiAoX3MucGF0dGVybiAmJiBfcy5wYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwICYmICFfcy5wYXR0ZXJuLnRlc3QodikpIHJldHVybiB0aGlzLlRFWFRTLnBhdHRlcm47IC8vIGlmIGR1cGxpY2F0ZXMgYXJlIG5vdCBhbGxvd2VkIGFuZCB0aGVyZSBpcyBhIGR1cGxpY2F0ZVxuXG4gICAgaWYgKCFfcy5kdXBsaWNhdGVzICYmIHRoaXMuaXNUYWdEdXBsaWNhdGUodiwgdGhpcy5zdGF0ZS5lZGl0aW5nKSkgcmV0dXJuIHRoaXMuVEVYVFMuZHVwbGljYXRlO1xuICAgIGlmICh0aGlzLmlzVGFnQmxhY2tsaXN0ZWQodikgfHwgX3MuZW5mb3JjZVdoaXRlbGlzdCAmJiAhdGhpcy5pc1RhZ1doaXRlbGlzdGVkKHYpKSByZXR1cm4gdGhpcy5URVhUUy5ub3RBbGxvd2VkO1xuICAgIGlmIChfcy52YWxpZGF0ZSkgcmV0dXJuIF9zLnZhbGlkYXRlKHRhZ0RhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGdldEludmFsaWRUYWdBdHRycyh0YWdEYXRhLCB2YWxpZGF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiYXJpYS1pbnZhbGlkXCI6IHRydWUsXG4gICAgICBcImNsYXNzXCI6IGAke3RhZ0RhdGEuY2xhc3MgfHwgJyd9ICR7dGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZ05vdEFsbG93ZWR9YC50cmltKCksXG4gICAgICBcInRpdGxlXCI6IHZhbGlkYXRpb25cbiAgICB9O1xuICB9LFxuXG4gIGhhc01heFRhZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoID49IHRoaXMuc2V0dGluZ3MubWF4VGFncyA/IHRoaXMuVEVYVFMuZXhjZWVkIDogZmFsc2U7XG4gIH0sXG5cbiAgc2V0UmVhZG9ubHkodG9nZ2xlLCBhdHRycmlidXRlKSB7XG4gICAgdmFyIF9zID0gdGhpcy5zZXR0aW5ncztcbiAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTsgLy8gZXhpc3RzIHBvc3NpYmxlIGVkaXQtbW9kZVxuXG4gICAgX3NbYXR0cnJpYnV0ZSB8fCAncmVhZG9ubHknXSA9IHRvZ2dsZTtcbiAgICB0aGlzLkRPTS5zY29wZVsodG9nZ2xlID8gJ3NldCcgOiAncmVtb3ZlJykgKyAnQXR0cmlidXRlJ10oYXR0cnJpYnV0ZSB8fCAncmVhZG9ubHknLCB0cnVlKTtcblxuICAgIGlmIChfcy5tb2RlID09ICdtaXgnKSB7XG4gICAgICB0aGlzLnNldENvbnRlbnRFZGl0YWJsZSghdG9nZ2xlKTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0Q29udGVudEVkaXRhYmxlKHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnJlYWRvbmx5ICYmIHRoaXMuc2V0dGluZ3MudXNlcklucHV0KSB0aGlzLkRPTS5pbnB1dC5jb250ZW50RWRpdGFibGUgPSBzdGF0ZTtcbiAgfSxcblxuICBzZXREaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgdGhpcy5zZXRSZWFkb25seShpc0Rpc2FibGVkLCAnZGlzYWJsZWQnKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBwcmUtcHJvY2Nlc3MgdGhlIHRhZ3NJdGVtcywgd2hpY2ggY2FuIGJlIGEgY29tcGxleCB0YWdzSXRlbXMgbGlrZSBhbiBBcnJheSBvZiBPYmplY3RzIG9yIGEgc3RyaW5nIGNvbXByaXNlZCBvZiBtdWx0aXBsZSB3b3Jkc1xyXG4gICAqIHNvIGVhY2ggaXRlbSBzaG91bGQgYmUgaXRlcmF0ZWQgb24gYW5kIGEgdGFnIGNyZWF0ZWQgZm9yLlxyXG4gICAqIEByZXR1cm4ge0FycmF5fSBbQXJyYXkgb2YgT2JqZWN0c11cclxuICAgKi9cbiAgbm9ybWFsaXplVGFncyh0YWdzSXRlbXMpIHtcbiAgICB2YXIgX3RoaXMkc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICB3aGl0ZWxpc3QgPSBfdGhpcyRzZXR0aW5ncy53aGl0ZWxpc3QsXG4gICAgICAgIGRlbGltaXRlcnMgPSBfdGhpcyRzZXR0aW5ncy5kZWxpbWl0ZXJzLFxuICAgICAgICBtb2RlID0gX3RoaXMkc2V0dGluZ3MubW9kZSxcbiAgICAgICAgdGFnVGV4dFByb3AgPSBfdGhpcyRzZXR0aW5ncy50YWdUZXh0UHJvcDtcbiAgICAgICAgX3RoaXMkc2V0dGluZ3MuZW5mb3JjZVdoaXRlbGlzdDtcbiAgICAgICAgdmFyIHdoaXRlbGlzdE1hdGNoZXMgPSBbXSxcbiAgICAgICAgd2hpdGVsaXN0V2l0aFByb3BzID0gd2hpdGVsaXN0ID8gd2hpdGVsaXN0WzBdIGluc3RhbmNlb2YgT2JqZWN0IDogZmFsc2UsXG4gICAgICAgIGlzQXJyYXkgPSB0YWdzSXRlbXMgaW5zdGFuY2VvZiBBcnJheSxcbiAgICAgICAgbWFwU3RyaW5nVG9Db2xsZWN0aW9uID0gcyA9PiAocyArIFwiXCIpLnNwbGl0KGRlbGltaXRlcnMpLmZpbHRlcihuID0+IG4pLm1hcCh2ID0+ICh7XG4gICAgICBbdGFnVGV4dFByb3BdOiB0aGlzLnRyaW0odiksXG4gICAgICB2YWx1ZTogdGhpcy50cmltKHYpXG4gICAgfSkpO1xuXG4gICAgaWYgKHR5cGVvZiB0YWdzSXRlbXMgPT0gJ251bWJlcicpIHRhZ3NJdGVtcyA9IHRhZ3NJdGVtcy50b1N0cmluZygpOyAvLyBpZiB0aGUgYXJndW1lbnQgaXMgYSBcInNpbXBsZVwiIFN0cmluZywgZXg6IFwiYWFhLCBiYmIsIGNjY1wiXG5cbiAgICBpZiAodHlwZW9mIHRhZ3NJdGVtcyA9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCF0YWdzSXRlbXMudHJpbSgpKSByZXR1cm4gW107IC8vIGdvIG92ZXIgZWFjaCB0YWcgYW5kIGFkZCBpdCAoaWYgdGhlcmUgd2VyZSBtdWx0aXBsZSBvbmVzKVxuXG4gICAgICB0YWdzSXRlbXMgPSBtYXBTdHJpbmdUb0NvbGxlY3Rpb24odGFnc0l0ZW1zKTtcbiAgICB9IC8vIGlzIGlzIGFuIEFycmF5IG9mIFN0cmluZ3MsIGNvbnZlcnQgdG8gYW4gQXJyYXkgb2YgT2JqZWN0c1xuICAgIGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICAgIC8vIGZsYXR0ZW4gdGhlIDJEIGFycmF5XG4gICAgICB0YWdzSXRlbXMgPSBbXS5jb25jYXQoLi4udGFnc0l0ZW1zLm1hcChpdGVtID0+IGl0ZW0udmFsdWUgPyBpdGVtIC8vIG1hcFN0cmluZ1RvQ29sbGVjdGlvbihpdGVtLnZhbHVlKS5tYXAobmV3SXRlbSA9PiAoey4uLml0ZW0sLi4ubmV3SXRlbX0pKVxuICAgICAgOiBtYXBTdHJpbmdUb0NvbGxlY3Rpb24oaXRlbSkpKTtcbiAgICB9IC8vIHNlYXJjaCBpZiB0aGUgdGFnIGV4aXN0cyBpbiB0aGUgd2hpdGVsaXN0IGFzIGFuIE9iamVjdCAoaGFzIHByb3BzKSxcbiAgICAvLyB0byBiZSBhYmxlIHRvIHVzZSBpdHMgcHJvcGVydGllc1xuXG5cbiAgICBpZiAod2hpdGVsaXN0V2l0aFByb3BzKSB7XG4gICAgICB0YWdzSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgdmFyIHdoaXRlbGlzdE1hdGNoZXNWYWx1ZXMgPSB3aGl0ZWxpc3RNYXRjaGVzLm1hcChhID0+IGEudmFsdWUpOyAvLyBpZiBzdWdnZXN0aW9ucyBhcmUgc2hvd24sIHRoZXkgYXJlIGFscmVhZHkgZmlsdGVyZWQsIHNvIGl0J3MgZWFzaWVyIHRvIHVzZSB0aGVtLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSB3aGl0ZWxpc3QgbWlnaHQgYWxzbyBpbmNsdWRlIGl0ZW1zIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkXG5cbiAgICAgICAgdmFyIGZpbHRlcmVkTGlzdCA9IHRoaXMuZHJvcGRvd24uZmlsdGVyTGlzdEl0ZW1zLmNhbGwodGhpcywgaXRlbVt0YWdUZXh0UHJvcF0sIHtcbiAgICAgICAgICBleGFjdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmR1cGxpY2F0ZXMpIC8vIGFsc28gZmlsdGVyIG91dCBpdGVtcyB3aGljaCBoYXZlIGFscmVhZHkgYmVlbiBtYXRjaGVkIGluIHByZXZpb3VzIGl0ZXJhdGlvbnNcbiAgICAgICAgICBmaWx0ZXJlZExpc3QgPSBmaWx0ZXJlZExpc3QuZmlsdGVyKGZpbHRlcmVkSXRlbSA9PiAhd2hpdGVsaXN0TWF0Y2hlc1ZhbHVlcy5pbmNsdWRlcyhmaWx0ZXJlZEl0ZW0udmFsdWUpKTsgLy8gZ2V0IHRoZSBiZXN0IG1hdGNoIG91dCBvZiBsaXN0IG9mIHBvc3NpYmxlIG1hdGNoZXMuXG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHNpbmdsZSBpdGVtIGluIHRoZSBmaWx0ZXJlZCBsaXN0LCB1c2UgdGhhdCBvbmVcblxuICAgICAgICB2YXIgbWF0Y2hPYmogPSBmaWx0ZXJlZExpc3QubGVuZ3RoID4gMSA/IHRoaXMuZ2V0V2hpdGVsaXN0SXRlbShpdGVtW3RhZ1RleHRQcm9wXSwgdGFnVGV4dFByb3AsIGZpbHRlcmVkTGlzdCkgOiBmaWx0ZXJlZExpc3RbMF07XG5cbiAgICAgICAgaWYgKG1hdGNoT2JqICYmIG1hdGNoT2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgd2hpdGVsaXN0TWF0Y2hlcy5wdXNoKG1hdGNoT2JqKTsgLy8gc2V0IHRoZSBBcnJheSAod2l0aCB0aGUgZm91bmQgT2JqZWN0KSBhcyB0aGUgbmV3IHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSAhPSAnbWl4Jykge1xuICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09IHVuZGVmaW5lZCkgaXRlbS52YWx1ZSA9IGl0ZW1bdGFnVGV4dFByb3BdO1xuICAgICAgICAgIHdoaXRlbGlzdE1hdGNoZXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAod2hpdGVsaXN0TWF0Y2hlcy5sZW5ndGgpIHRhZ3NJdGVtcyA9IHdoaXRlbGlzdE1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ3NJdGVtcztcbiAgfSxcblxuICAvKipcclxuICAgKiBQYXJzZSB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBhIHRleHRhcmVhIChvciBpbnB1dCkgZWxlbWVudCBhbmQgZ2VuZXJhdGUgbWl4ZWQgdGV4dCB3LyB0YWdzXHJcbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU3NTk4ODkyLzEwNDM4MFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzXHJcbiAgICovXG4gIHBhcnNlTWl4VGFncyhzKSB7XG4gICAgdmFyIF90aGlzJHNldHRpbmdzMiA9IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgIG1peFRhZ3NJbnRlcnBvbGF0b3IgPSBfdGhpcyRzZXR0aW5nczIubWl4VGFnc0ludGVycG9sYXRvcixcbiAgICAgICAgZHVwbGljYXRlcyA9IF90aGlzJHNldHRpbmdzMi5kdXBsaWNhdGVzLFxuICAgICAgICB0cmFuc2Zvcm1UYWcgPSBfdGhpcyRzZXR0aW5nczIudHJhbnNmb3JtVGFnLFxuICAgICAgICBlbmZvcmNlV2hpdGVsaXN0ID0gX3RoaXMkc2V0dGluZ3MyLmVuZm9yY2VXaGl0ZWxpc3QsXG4gICAgICAgIG1heFRhZ3MgPSBfdGhpcyRzZXR0aW5nczIubWF4VGFncyxcbiAgICAgICAgdGFnVGV4dFByb3AgPSBfdGhpcyRzZXR0aW5nczIudGFnVGV4dFByb3AsXG4gICAgICAgIHRhZ3NEYXRhU2V0ID0gW107XG4gICAgcyA9IHMuc3BsaXQobWl4VGFnc0ludGVycG9sYXRvclswXSkubWFwKChzMSwgaSkgPT4ge1xuICAgICAgdmFyIHMyID0gczEuc3BsaXQobWl4VGFnc0ludGVycG9sYXRvclsxXSksXG4gICAgICAgICAgcHJlSW50ZXJwb2xhdGVkID0gczJbMF0sXG4gICAgICAgICAgbWF4VGFnc1JlYWNoZWQgPSB0YWdzRGF0YVNldC5sZW5ndGggPT0gbWF4VGFncyxcbiAgICAgICAgICB0ZXh0UHJvcCxcbiAgICAgICAgICB0YWdEYXRhLFxuICAgICAgICAgIHRhZ0VsbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gc2tpcCBudW1iZXJzIGFuZCBnbyBzdHJhaWdodCB0byB0aGUgXCJjYXRjaFwiIHN0YXRlbWVudFxuICAgICAgICBpZiAocHJlSW50ZXJwb2xhdGVkID09ICtwcmVJbnRlcnBvbGF0ZWQpIHRocm93IEVycm9yO1xuICAgICAgICB0YWdEYXRhID0gSlNPTi5wYXJzZShwcmVJbnRlcnBvbGF0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRhZ0RhdGEgPSB0aGlzLm5vcm1hbGl6ZVRhZ3MocHJlSW50ZXJwb2xhdGVkKVswXSB8fCB7XG4gICAgICAgICAgdmFsdWU6IHByZUludGVycG9sYXRlZFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zvcm1UYWcuY2FsbCh0aGlzLCB0YWdEYXRhKTtcblxuICAgICAgaWYgKCFtYXhUYWdzUmVhY2hlZCAmJiBzMi5sZW5ndGggPiAxICYmICghZW5mb3JjZVdoaXRlbGlzdCB8fCB0aGlzLmlzVGFnV2hpdGVsaXN0ZWQodGFnRGF0YS52YWx1ZSkpICYmICEoIWR1cGxpY2F0ZXMgJiYgdGhpcy5pc1RhZ0R1cGxpY2F0ZSh0YWdEYXRhLnZhbHVlKSkpIHtcbiAgICAgICAgLy8gaW4gY2FzZSBcInRhZ1RleHRQcm9wXCIgc2V0dGluZyBpcyBzZXQgdG8gb3RoZXIgdGhhbiBcInZhbHVlXCIgYW5kIHRoaXMgdGFnIGRvZXMgbm90IGhhdmUgdGhpcyBwcm9wXG4gICAgICAgIHRleHRQcm9wID0gdGFnRGF0YVt0YWdUZXh0UHJvcF0gPyB0YWdUZXh0UHJvcCA6ICd2YWx1ZSc7XG4gICAgICAgIHRhZ0RhdGFbdGV4dFByb3BdID0gdGhpcy50cmltKHRhZ0RhdGFbdGV4dFByb3BdKTtcbiAgICAgICAgdGFnRWxtID0gdGhpcy5jcmVhdGVUYWdFbGVtKHRhZ0RhdGEpO1xuICAgICAgICB0YWdzRGF0YVNldC5wdXNoKHRhZ0RhdGEpO1xuICAgICAgICB0YWdFbG0uY2xhc3NMaXN0LmFkZCh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMudGFnTm9BbmltYXRpb24pO1xuICAgICAgICBzMlswXSA9IHRhZ0VsbS5vdXRlckhUTUw7IC8vKyBcIiYjODI4ODtcIiAgLy8gcHV0IGEgemVyby1zcGFjZSBhdCB0aGUgZW5kIHNvIHRoZSBjYXJldCB3b24ndCBqdW1wIGJhY2sgdG8gdGhlIHN0YXJ0ICh3aGVuIHRoZSBsYXN0IGlucHV0J3MgY2hpbGQgZWxlbWVudCBpcyBhIHRhZylcblxuICAgICAgICB0aGlzLnZhbHVlLnB1c2godGFnRGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHMxKSByZXR1cm4gaSA/IG1peFRhZ3NJbnRlcnBvbGF0b3JbMF0gKyBzMSA6IHMxO1xuXG4gICAgICByZXR1cm4gczIuam9pbignJyk7XG4gICAgfSkuam9pbignJyk7XG4gICAgdGhpcy5ET00uaW5wdXQuaW5uZXJIVE1MID0gcztcbiAgICB0aGlzLkRPTS5pbnB1dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJykpO1xuICAgIHRoaXMuRE9NLmlucHV0Lm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuZ2V0VGFnRWxtcygpLmZvckVhY2goKGVsbSwgaWR4KSA9PiB0aGlzLnRhZ0RhdGEoZWxtLCB0YWdzRGF0YVNldFtpZHhdKSk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgd2l0aG91dENoYW5nZUV2ZW50OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRm9yIG1peGVkLW1vZGU6IHJlcGxhY2VzIGEgdGV4dCBzdGFydGluZyB3aXRoIGEgcHJlZml4IHdpdGggYSB3cmFwcGVyIGVsZW1lbnQgKHRhZyBvciBzb21ldGhpbmcpXHJcbiAgICogRmlyc3QgdGhlcmUgKmhhcyogdG8gYmUgYSBcInRoaXMuc3RhdGUudGFnXCIgd2hpY2ggaXMgYSBzdHJpbmcgdGhhdCB3YXMganVzdCB0eXBlZCBhbmQgaXMgc3RhcmluZyB3aXRoIGEgcHJlZml4XHJcbiAgICovXG4gIHJlcGxhY2VUZXh0V2l0aE5vZGUobmV3V3JhcHBlck5vZGUsIHN0clRvUmVwbGFjZSkge1xuICAgIGlmICghdGhpcy5zdGF0ZS50YWcgJiYgIXN0clRvUmVwbGFjZSkgcmV0dXJuO1xuICAgIHN0clRvUmVwbGFjZSA9IHN0clRvUmVwbGFjZSB8fCB0aGlzLnN0YXRlLnRhZy5wcmVmaXggKyB0aGlzLnN0YXRlLnRhZy52YWx1ZTtcbiAgICB2YXIgaWR4LFxuICAgICAgICBub2RlVG9SZXBsYWNlLFxuICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgIG5vZGVBdENhcmV0ID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICAgIGZpcnN0U3BsaXRPZmZzZXQgPSB0aGlzLnN0YXRlLnRhZy5kZWxpbWl0ZXJzID8gdGhpcy5zdGF0ZS50YWcuZGVsaW1pdGVycy5sZW5ndGggOiAwOyAvLyBTVEVQIDE6IGV4LiByZXBsYWNlICNiYSB3aXRoIHRoZSB0YWcgXCJiYXJ0XCIgd2hlcmUgXCJ8XCIgaXMgd2hlcmUgdGhlIGNhcmV0IGlzOlxuICAgIC8vIENVUlJFTlQgU1RBVEU6IFwiZm9vICNiYSAjYmF8ICNiYVwiXG4gICAgLy8gc3BsaXQgdGhlIHRleHQgbm9kZSBhdCB0aGUgaW5kZXggb2YgdGhlIGNhcmV0XG5cbiAgICBub2RlQXRDYXJldC5zcGxpdFRleHQoc2VsZWN0aW9uLmFuY2hvck9mZnNldCAtIGZpcnN0U3BsaXRPZmZzZXQpOyAvLyBub2RlIDA6IFwiZm9vICNiYSAjYmF8XCJcbiAgICAvLyBub2RlIDE6IFwiICNiYVwiXG4gICAgLy8gZ2V0IGluZGV4IG9mIExBU1Qgb2NjdXJlbmNlIG9mIFwiI2JhXCJcblxuICAgIGlkeCA9IG5vZGVBdENhcmV0Lm5vZGVWYWx1ZS5sYXN0SW5kZXhPZihzdHJUb1JlcGxhY2UpO1xuICAgIGlmIChpZHggPT0gLTEpIHJldHVybiB0cnVlO1xuICAgIG5vZGVUb1JlcGxhY2UgPSBub2RlQXRDYXJldC5zcGxpdFRleHQoaWR4KTsgLy8gbm9kZSAwOiBcImZvbyAjYmEgXCJcbiAgICAvLyBub2RlIDE6IFwiI2JhXCIgICAgPC0gbm9kZVRvUmVwbGFjZVxuXG4gICAgbmV3V3JhcHBlck5vZGUgJiYgbm9kZUF0Q2FyZXQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3V3JhcHBlck5vZGUsIG5vZGVUb1JlcGxhY2UpOyAvLyBtdXN0IE5PVCBub3JtYWxpemUgY29udGVudGVkaXRhYmxlIG9yIGl0IHdpbGwgY2F1c2UgdW53YW50ZWQgaXNzdWVzOlxuICAgIC8vIGh0dHBzOi8vbW9ub3NuYXAuY29tL2ZpbGUvWkRWbVJ2cTV1cFlraWRpRmVkdnJ3elNzd2VnV2s3XG4gICAgLy8gbm9kZUF0Q2FyZXQucGFyZW50Tm9kZS5ub3JtYWxpemUoKVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRm9yIHNlbGVjdGluZyBhIHNpbmdsZSBvcHRpb24gKG5vdCB1c2VkIGZvciBtdWx0aXBsZSB0YWdzLCBidXQgZm9yIFwibW9kZTpzZWxlY3RcIiBvbmx5KVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YWdFbG0gICBUYWcgRE9NIG5vZGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFnRGF0YSAgVGFnIGRhdGFcclxuICAgKi9cbiAgc2VsZWN0VGFnKHRhZ0VsbSwgdGFnRGF0YSkge1xuICAgIHZhciBfcyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgaWYgKF9zLmVuZm9yY2VXaGl0ZWxpc3QgJiYgIXRoaXMuaXNUYWdXaGl0ZWxpc3RlZCh0YWdEYXRhLnZhbHVlKSkgcmV0dXJuO1xuICAgIHRoaXMuaW5wdXQuc2V0LmNhbGwodGhpcywgdGFnRGF0YVtfcy50YWdUZXh0UHJvcF0gfHwgdGFnRGF0YS52YWx1ZSwgdHJ1ZSk7IC8vIHBsYWNlIHRoZSBjYXJldCBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCwgb25seSBpZiBhIGRyb3Bkb3duIG9wdGlvbiB3YXMgc2VsZWN0ZWQgKGFuZCBub3QgYnkgbWFudWFsbHkgdHlwaW5nIGFub3RoZXIgdmFsdWUgYW5kIGNsaWNraW5nIFwiVEFCXCIpXG5cbiAgICBpZiAodGhpcy5zdGF0ZS5hY3Rpb25zLnNlbGVjdE9wdGlvbikgc2V0VGltZW91dCh0aGlzLnNldFJhbmdlQXRTdGFydEVuZC5iaW5kKHRoaXMpKTtcbiAgICB2YXIgbGFzdFRhZ0VsbSA9IHRoaXMuZ2V0TGFzdFRhZygpO1xuICAgIGlmIChsYXN0VGFnRWxtKSB0aGlzLnJlcGxhY2VUYWcobGFzdFRhZ0VsbSwgdGFnRGF0YSk7ZWxzZSB0aGlzLmFwcGVuZFRhZyh0YWdFbG0pO1xuICAgIGlmIChfcy5lbmZvcmNlV2hpdGVsaXN0KSB0aGlzLnNldENvbnRlbnRFZGl0YWJsZShmYWxzZSk7XG4gICAgdGhpcy52YWx1ZVswXSA9IHRhZ0RhdGE7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2FkZCcsIHtcbiAgICAgIHRhZzogdGFnRWxtLFxuICAgICAgZGF0YTogdGFnRGF0YVxuICAgIH0pO1xuICAgIHJldHVybiBbdGFnRWxtXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBhZGQgYW4gZW1wdHkgXCJ0YWdcIiBlbGVtZW50IGluIGFuIGVkaXRhYmxlIHN0YXRlXHJcbiAgICovXG4gIGFkZEVtcHR5VGFnKGluaXRpYWxEYXRhKSB7XG4gICAgdmFyIHRhZ0RhdGEgPSBleHRlbmQoe1xuICAgICAgdmFsdWU6IFwiXCJcbiAgICB9LCBpbml0aWFsRGF0YSB8fCB7fSksXG4gICAgICAgIHRhZ0VsbSA9IHRoaXMuY3JlYXRlVGFnRWxlbSh0YWdEYXRhKTtcbiAgICB0aGlzLnRhZ0RhdGEodGFnRWxtLCB0YWdEYXRhKTsgLy8gYWRkIHRoZSB0YWcgdG8gdGhlIGNvbXBvbmVudCdzIERPTVxuXG4gICAgdGhpcy5hcHBlbmRUYWcodGFnRWxtKTtcbiAgICB0aGlzLmVkaXRUYWcodGFnRWxtLCB7XG4gICAgICBza2lwVmFsaWRhdGlvbjogdHJ1ZVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIGFkZCBhIFwidGFnXCIgZWxlbWVudCB0byB0aGUgXCJ0YWdzXCIgY29tcG9uZW50XHJcbiAgICogQHBhcmFtIHtTdHJpbmcvQXJyYXl9IHRhZ3NJdGVtcyAgIFtBIHN0cmluZyAoc2luZ2xlIG9yIG11bHRpcGxlIHZhbHVlcyB3aXRoIGEgZGVsaW1pdGVyKSwgb3IgYW4gQXJyYXkgb2YgT2JqZWN0cyBvciBqdXN0IEFycmF5IG9mIFN0cmluZ3NdXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSAgICAgIGNsZWFySW5wdXQgIFtmbGFnIGlmIHRoZSBpbnB1dCdzIHZhbHVlIHNob3VsZCBiZSBjbGVhcmVkIGFmdGVyIGFkZGluZyB0YWdzXVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICBza2lwSW52YWxpZCBbZG8gbm90IGFkZCwgbWFyayAmIHJlbW92ZSBpbnZhbGlkIHRhZ3NdXHJcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIERPTSBlbGVtZW50cyAodGFncylcclxuICAgKi9cbiAgYWRkVGFncyh0YWdzSXRlbXMsIGNsZWFySW5wdXQsIHNraXBJbnZhbGlkKSB7XG4gICAgdmFyIHRhZ0VsZW1zID0gW10sXG4gICAgICAgIF9zID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBza2lwSW52YWxpZCA9IHNraXBJbnZhbGlkIHx8IF9zLnNraXBJbnZhbGlkO1xuXG4gICAgaWYgKCF0YWdzSXRlbXMgfHwgdGFnc0l0ZW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICBpZiAoX3MubW9kZSA9PSAnc2VsZWN0JykgdGhpcy5yZW1vdmVBbGxUYWdzKCk7XG4gICAgICByZXR1cm4gdGFnRWxlbXM7XG4gICAgfSAvLyBjb252ZXJ0cyBBcnJheS9TdHJpbmcvT2JqZWN0IHRvIGFuIEFycmF5IG9mIE9iamVjdHNcblxuXG4gICAgdGFnc0l0ZW1zID0gdGhpcy5ub3JtYWxpemVUYWdzKHRhZ3NJdGVtcyk7XG5cbiAgICBpZiAoX3MubW9kZSA9PSAnbWl4Jykge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTWl4VGFncyh0YWdzSXRlbXMpO1xuICAgIH1cblxuICAgIGlmIChfcy5tb2RlID09ICdzZWxlY3QnKSBjbGVhcklucHV0ID0gZmFsc2U7XG4gICAgdGhpcy5ET00uaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIHRhZ3NJdGVtcy5mb3JFYWNoKHRhZ0RhdGEgPT4ge1xuICAgICAgdmFyIHRhZ0VsbSxcbiAgICAgICAgICB0YWdFbG1QYXJhbXMgPSB7fSxcbiAgICAgICAgICBvcmlnaW5hbERhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB0YWdEYXRhLCB7XG4gICAgICAgIHZhbHVlOiB0YWdEYXRhLnZhbHVlICsgXCJcIlxuICAgICAgfSk7IC8vIHNoYWxsb3ctY2xvbmUgdGFnRGF0YSBzbyBsYXRlciBtb2RpZmljYXRpb25zIHdpbGwgbm90IGFwcGx5IHRvIHRoZSBzb3VyY2VcblxuICAgICAgdGFnRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsRGF0YSk7XG5cbiAgICAgIF9zLnRyYW5zZm9ybVRhZy5jYWxsKHRoaXMsIHRhZ0RhdGEpO1xuXG4gICAgICB0YWdEYXRhLl9faXNWYWxpZCA9IHRoaXMuaGFzTWF4VGFncygpIHx8IHRoaXMudmFsaWRhdGVUYWcodGFnRGF0YSk7XG5cbiAgICAgIGlmICh0YWdEYXRhLl9faXNWYWxpZCAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc2tpcEludmFsaWQpIHJldHVybjsgLy8gb3JpZ2luYWxEYXRhIGlzIGtlcHQgYmVjYXVzZSBpdCBtaWdodCBiZSB0aGF0IHRoaXMgdGFnIGlzIGludmFsaWQgYmVjYXVzZSBpdCBpcyBhIGR1cGxpY2F0ZSBvZiBhbm90aGVyLFxuICAgICAgICAvLyBhbmQgaWYgdGhhdCBvdGhlciB0YWdzIGlzIGVkaXRlZC9kZWxldGVkLCB0aGlzIG9uZSBzaG91bGQgYmUgcmUtdmFsaWRhdGVkIGFuZCBpZiBpcyBubyBtb3JlIGEgZHVwbGljYXRlIC0gcmVzdG9yZWRcblxuICAgICAgICBleHRlbmQodGFnRWxtUGFyYW1zLCB0aGlzLmdldEludmFsaWRUYWdBdHRycyh0YWdEYXRhLCB0YWdEYXRhLl9faXNWYWxpZCksIHtcbiAgICAgICAgICBfX3ByZUludmFsaWREYXRhOiBvcmlnaW5hbERhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0YWdEYXRhLl9faXNWYWxpZCA9PSB0aGlzLlRFWFRTLmR1cGxpY2F0ZSkgLy8gbWFyaywgZm9yIGEgYnJpZWYgbW9tZW50LCB0aGUgdGFnICh0aGlzIHRoaXMgb25lKSB3aGljaCBUSElTIENVUlJFTlQgdGFnIGlzIGEgZHVwbGNhdGUgb2ZcbiAgICAgICAgICB0aGlzLmZsYXNoVGFnKHRoaXMuZ2V0VGFnRWxtQnlWYWx1ZSh0YWdEYXRhLnZhbHVlKSk7XG4gICAgICB9IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuICAgICAgaWYgKCdyZWFkb25seScgaW4gdGFnRGF0YSkge1xuICAgICAgICBpZiAodGFnRGF0YS5yZWFkb25seSkgdGFnRWxtUGFyYW1zW1wiYXJpYS1yZWFkb25seVwiXSA9IHRydWU7IC8vIGlmIFwicmVhZG9ubHlcIiBpcyBcImZhbHNlXCIsIHJlbW92ZSBpdCBmcm9tIHRoZSB0YWdEYXRhIHNvIGl0IHdvbid0IGJlIGFkZGVkIGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgdGVtcGxhdGVcbiAgICAgICAgZWxzZSBkZWxldGUgdGFnRGF0YS5yZWFkb25seTtcbiAgICAgIH0gLy8gQ3JlYXRlIHRhZyBIVE1MIGVsZW1lbnRcblxuXG4gICAgICB0YWdFbG0gPSB0aGlzLmNyZWF0ZVRhZ0VsZW0odGFnRGF0YSwgdGFnRWxtUGFyYW1zKTtcbiAgICAgIHRhZ0VsZW1zLnB1c2godGFnRWxtKTsgLy8gbW9kZS1zZWxlY3Qgb3ZlcnJpZGVzXG5cbiAgICAgIGlmIChfcy5tb2RlID09ICdzZWxlY3QnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdFRhZyh0YWdFbG0sIHRhZ0RhdGEpO1xuICAgICAgfSAvLyBhZGQgdGhlIHRhZyB0byB0aGUgY29tcG9uZW50J3MgRE9NXG4gICAgICAvLyB0aGlzLmFwcGVuZFRhZyh0YWdFbG0pXG5cblxuICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0YWdFbG0pO1xuXG4gICAgICBpZiAodGFnRGF0YS5fX2lzVmFsaWQgJiYgdGFnRGF0YS5fX2lzVmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlXG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh0YWdEYXRhKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdhZGQnLCB7XG4gICAgICAgICAgdGFnOiB0YWdFbG0sXG4gICAgICAgICAgaW5kZXg6IHRoaXMudmFsdWUubGVuZ3RoIC0gMSxcbiAgICAgICAgICBkYXRhOiB0YWdEYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiaW52YWxpZFwiLCB7XG4gICAgICAgICAgZGF0YTogdGFnRGF0YSxcbiAgICAgICAgICBpbmRleDogdGhpcy52YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgdGFnOiB0YWdFbG0sXG4gICAgICAgICAgbWVzc2FnZTogdGFnRGF0YS5fX2lzVmFsaWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghX3Mua2VlcEludmFsaWRUYWdzKSAvLyByZW1vdmUgaW52YWxpZCB0YWdzIChpZiBcImtlZXBJbnZhbGlkVGFnc1wiIGlzIHNldCB0byBcImZhbHNlXCIpXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlbW92ZVRhZ3ModGFnRWxtLCB0cnVlKSwgMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJvcGRvd24ucG9zaXRpb24oKTsgLy8gcmVwb3NpdGlvbiB0aGUgZHJvcGRvd24gYmVjYXVzZSB0aGUganVzdC1hZGRlZCB0YWcgbWlnaHQgY2F1c2UgYSBuZXctbGluZVxuICAgIH0pO1xuICAgIHRoaXMuYXBwZW5kVGFnKGZyYWcpO1xuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICBpZiAodGFnc0l0ZW1zLmxlbmd0aCAmJiBjbGVhcklucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LnNldC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuZHJvcGRvd24ucmVmaWx0ZXIoKTtcbiAgICByZXR1cm4gdGFnRWxlbXM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQWRkcyBhIG1peC1jb250ZW50IHRhZ1xyXG4gICAqIEBwYXJhbSB7U3RyaW5nL0FycmF5fSB0YWdEYXRhICAgIEEgc3RyaW5nIChzaW5nbGUgb3IgbXVsdGlwbGUgdmFsdWVzIHdpdGggYSBkZWxpbWl0ZXIpLCBvciBhbiBBcnJheSBvZiBPYmplY3RzIG9yIGp1c3QgQXJyYXkgb2YgU3RyaW5nc1xyXG4gICAqL1xuICBhZGRNaXhUYWdzKHRhZ3NEYXRhKSB7XG4gICAgdGFnc0RhdGEgPSB0aGlzLm5vcm1hbGl6ZVRhZ3ModGFnc0RhdGEpO1xuXG4gICAgaWYgKHRhZ3NEYXRhWzBdLnByZWZpeCB8fCB0aGlzLnN0YXRlLnRhZykge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZml4ZWRUZXh0VG9UYWcodGFnc0RhdGFbMF0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFnc0RhdGEgPT0gJ3N0cmluZycpIHRhZ3NEYXRhID0gW3tcbiAgICAgIHZhbHVlOiB0YWdzRGF0YVxuICAgIH1dO1xuICAgIHZhciBzZWxlY3Rpb24gPSAhIXRoaXMuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAvLyBtdXN0IGJlIGNhc3QsIG5vdCB0byB1c2UgdGhlIHJlZmVyZW5jZSB3aGljaCBpcyBjaGFuZ2luZ1xuICAgIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdGFnc0RhdGEuZm9yRWFjaCh0YWdEYXRhID0+IHtcbiAgICAgIHZhciB0YWdFbG0gPSB0aGlzLmNyZWF0ZVRhZ0VsZW0odGFnRGF0YSk7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHRhZ0VsbSk7XG4gICAgICB0aGlzLmluc2VydEFmdGVyVGFnKHRhZ0VsbSk7XG4gICAgfSk7IC8vIGlmIFwic2VsZWN0aW9uXCIgZXhpc3RzLCBhc3N1bWVzIGludGVudGlvbiBvZiBpbmVjdGluZyB0aGUgbmV3IHRhZyBhdCB0aGUgbGFzdFxuICAgIC8vIHNhdmVkIGxvY2F0aW9uIG9mIHRoZSBjYXJldCBpbnNpZGUgXCJ0aGlzLkRPTS5pbnB1dFwiXG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmluamVjdEF0Q2FyZXQoZnJhZyk7XG4gICAgfSAvLyBlbHNlLCBjcmVhdGUgYSByYW5nZSBhbmQgaW5qZWN0IHRoZSBuZXcgdGFnIGFzIHRoZSBsYXN0IGNoaWxkIG9mIFwidGhpcy5ET00uaW5wdXRcIlxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5ET00uaW5wdXQuZm9jdXMoKTtcbiAgICAgIHNlbGVjdGlvbiA9IHRoaXMuc2V0U3RhdGVTZWxlY3Rpb24oKTtcbiAgICAgIHNlbGVjdGlvbi5yYW5nZS5zZXRTdGFydCh0aGlzLkRPTS5pbnB1dCwgc2VsZWN0aW9uLnJhbmdlLmVuZE9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24ucmFuZ2Uuc2V0RW5kKHRoaXMuRE9NLmlucHV0LCBzZWxlY3Rpb24ucmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgIHRoaXMuRE9NLmlucHV0LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZUJ5RE9NVGFncygpOyAvLyB1cGRhdGVzIGludGVybmFsIFwidGhpcy52YWx1ZVwiXG5cbiAgICAgIHRoaXMudXBkYXRlKCk7IC8vIHVwZGF0ZXMgb3JpZ2luYWwgaW5wdXQvdGV4dGFyZWFcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfSxcblxuICAvKipcclxuICAgKiBBZGRzIGEgdGFnIHdoaWNoIHdhcyBhY3Rpdmx5IHR5cGVkIGJ5IHRoZSB1c2VyXHJcbiAgICogQHBhcmFtIHtTdHJpbmcvQXJyYXl9IHRhZ0l0ZW0gICBbQSBzdHJpbmcgKHNpbmdsZSBvciBtdWx0aXBsZSB2YWx1ZXMgd2l0aCBhIGRlbGltaXRlciksIG9yIGFuIEFycmF5IG9mIE9iamVjdHMgb3IganVzdCBBcnJheSBvZiBTdHJpbmdzXVxyXG4gICAqL1xuICBwcmVmaXhlZFRleHRUb1RhZyh0YWdJdGVtKSB7XG4gICAgdmFyIF9zID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgdGFnRWxtLFxuICAgICAgICBjcmVhdGVkRnJvbURlbGltaXRlcnMgPSB0aGlzLnN0YXRlLnRhZy5kZWxpbWl0ZXJzO1xuXG4gICAgX3MudHJhbnNmb3JtVGFnLmNhbGwodGhpcywgdGFnSXRlbSk7XG5cbiAgICB0YWdJdGVtLnByZWZpeCA9IHRhZ0l0ZW0ucHJlZml4IHx8IHRoaXMuc3RhdGUudGFnID8gdGhpcy5zdGF0ZS50YWcucHJlZml4IDogKF9zLnBhdHRlcm4uc291cmNlIHx8IF9zLnBhdHRlcm4pWzBdOyAvLyBUT0RPOiBzaG91bGQgY2hlY2sgaWYgdGhlIHRhZyBpcyB2YWxpZFxuXG4gICAgdGFnRWxtID0gdGhpcy5jcmVhdGVUYWdFbGVtKHRhZ0l0ZW0pOyAvLyB0cmllcyB0byByZXBsYWNlIGEgdGFnZWQgdGV4dE5vZGUgd2l0aCBhIHRhZ0VsbSwgYW5kIGlmIG5vdCBhYmxlLFxuICAgIC8vIGluc2VydCB0aGUgbmV3IHRhZyB0byB0aGUgRU5EIGlmIFwiYWRkVGFnc1wiIHdhcyBjYWxsZWQgZnJvbSBvdXRzaWRlXG5cbiAgICBpZiAoIXRoaXMucmVwbGFjZVRleHRXaXRoTm9kZSh0YWdFbG0pKSB7XG4gICAgICB0aGlzLkRPTS5pbnB1dC5hcHBlbmRDaGlsZCh0YWdFbG0pO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGFnRWxtLmNsYXNzTGlzdC5hZGQodGhpcy5zZXR0aW5ncy5jbGFzc05hbWVzLnRhZ05vQW5pbWF0aW9uKSwgMzAwKTtcbiAgICB0aGlzLnZhbHVlLnB1c2godGFnSXRlbSk7XG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIGlmICghY3JlYXRlZEZyb21EZWxpbWl0ZXJzKSB7XG4gICAgICB2YXIgZWxtID0gdGhpcy5pbnNlcnRBZnRlclRhZyh0YWdFbG0pIHx8IHRhZ0VsbTtcbiAgICAgIHRoaXMucGxhY2VDYXJldEFmdGVyTm9kZShlbG0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUudGFnID0gbnVsbDtcbiAgICB0aGlzLnRyaWdnZXIoJ2FkZCcsIGV4dGVuZCh7fSwge1xuICAgICAgdGFnOiB0YWdFbG1cbiAgICB9LCB7XG4gICAgICBkYXRhOiB0YWdJdGVtXG4gICAgfSkpO1xuICAgIHJldHVybiB0YWdFbG07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogYXBwZW5lZCAodmFsaWRhdGVkKSB0YWcgdG8gdGhlIGNvbXBvbmVudCdzIERPTSBzY29wZVxyXG4gICAqL1xuICBhcHBlbmRUYWcodGFnRWxtKSB7XG4gICAgdmFyIERPTSA9IHRoaXMuRE9NLFxuICAgICAgICBpbnNlcnRCZWZvcmVOb2RlID0gRE9NLnNjb3BlLmxhc3RFbGVtZW50Q2hpbGQ7XG4gICAgaWYgKGluc2VydEJlZm9yZU5vZGUgPT09IERPTS5pbnB1dCkgRE9NLnNjb3BlLmluc2VydEJlZm9yZSh0YWdFbG0sIGluc2VydEJlZm9yZU5vZGUpO2Vsc2UgRE9NLnNjb3BlLmFwcGVuZENoaWxkKHRhZ0VsbSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogY3JlYXRlcyBhIERPTSB0YWcgZWxlbWVudCBhbmQgaW5qZWN0cyBpdCBpbnRvIHRoZSBjb21wb25lbnQgKHRoaXMuRE9NLnNjb3BlKVxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gIHRhZ0RhdGEgW3RleHQgdmFsdWUgJiBwcm9wZXJ0aWVzIGZvciB0aGUgY3JlYXRlZCB0YWddXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgZXh0cmFEYXRhIFtwcm9wZXJ0aWVzIHdoaWNoIGFyZSBmb3IgdGhlIEhUTUwgdGVtcGxhdGUgb25seV1cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFtET00gZWxlbWVudF1cclxuICAgKi9cbiAgY3JlYXRlVGFnRWxlbSh0YWdEYXRhLCBleHRyYURhdGEpIHtcbiAgICB0YWdEYXRhLl9fdGFnSWQgPSBnZXRVSUQoKTtcbiAgICB2YXIgdGFnRWxtLFxuICAgICAgICB0ZW1wbGF0ZURhdGEgPSBleHRlbmQoe30sIHRhZ0RhdGEsIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIHZhbHVlOiBlc2NhcGVIVE1MKHRhZ0RhdGEudmFsdWUgKyBcIlwiKVxuICAgIH0sIGV4dHJhRGF0YSkpOyAvLyBpZiggdGhpcy5zZXR0aW5ncy5yZWFkb25seSApXG4gICAgLy8gICAgIHRhZ0RhdGEucmVhZG9ubHkgPSB0cnVlXG5cbiAgICB0YWdFbG0gPSB0aGlzLnBhcnNlVGVtcGxhdGUoJ3RhZycsIFt0ZW1wbGF0ZURhdGFdKTsgLy8gY3J1Y2lhbCBmb3IgcHJvcGVyIGNhcmV0IHBsYWNlbWVudCB3aGVuIGRlbGV0aW5nIGNvbnRlbnQuIGlmIHRleHROb2RlcyBhcmUgYWxsb3dlZCBhcyBjaGlsZHJlbiBvZlxuICAgIC8vIGEgdGFnIGVsZW1lbnQsIGEgYnJvd3NlciBidWcgY2FzdWVzIHRoZSBjYXJldCB0byBtaXNwbGFjZWQgaW5zaWRlIHRoZSB0YWcgZWxlbWVudCAoZXNwZWNjaWFsbHkgYWZmZWN0cyBcInJlYWRvbmx5XCIgdGFncylcblxuICAgIHJlbW92ZVRleHRDaGlsZE5vZGVzKHRhZ0VsbSk7IC8vIHdoaWxlKCB0YWdFbG0ubGFzdENoaWxkLm5vZGVUeXBlID09IDMgKVxuICAgIC8vICAgICB0YWdFbG0ubGFzdENoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnRWxtLmxhc3RDaGlsZClcblxuICAgIHRoaXMudGFnRGF0YSh0YWdFbG0sIHRhZ0RhdGEpO1xuICAgIHJldHVybiB0YWdFbG07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogcmUtY2hlY2sgYWxsIGludmFsaWQgdGFncy5cclxuICAgKiBjYWxsZWQgYWZ0ZXIgYSB0YWcgd2FzIGVkaXRlZCBvciByZW1vdmVkXHJcbiAgICovXG4gIHJlQ2hlY2tJbnZhbGlkVGFncygpIHtcbiAgICB2YXIgX3MgPSB0aGlzLnNldHRpbmdzO1xuICAgIHRoaXMuZ2V0VGFnRWxtcyhfcy5jbGFzc05hbWVzLnRhZ05vdEFsbG93ZWQpLmZvckVhY2goKHRhZ0VsbSwgaSkgPT4ge1xuICAgICAgdmFyIHRhZ0RhdGEgPSB0aGlzLnRhZ0RhdGEodGFnRWxtKSxcbiAgICAgICAgICBoYXNNYXhUYWdzID0gdGhpcy5oYXNNYXhUYWdzKCksXG4gICAgICAgICAgdGFnVmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVUYWcodGFnRGF0YSk7IC8vIGlmIHRoZSB0YWcgaGFzIGJlY29tZSB2YWxpZFxuXG4gICAgICBpZiAodGFnVmFsaWRhdGlvbiA9PT0gdHJ1ZSAmJiAhaGFzTWF4VGFncykge1xuICAgICAgICB0YWdEYXRhID0gdGFnRGF0YS5fX3ByZUludmFsaWREYXRhID8gdGFnRGF0YS5fX3ByZUludmFsaWREYXRhIDoge1xuICAgICAgICAgIHZhbHVlOiB0YWdEYXRhLnZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VUYWcodGFnRWxtLCB0YWdEYXRhKTtcbiAgICAgIH0gLy8gaWYgdGhlIHRhZyBpcyBzdGlsbCBpbnZhaWxkLCBzZXQgaXRzIHRpdGxlIGFzIHN1Y2ggKHJlc29uIG9mIGludmFsaWQgbWlnaHQgaGF2ZSBjaGFuZ2VkKVxuXG5cbiAgICAgIHRhZ0VsbS50aXRsZSA9IGhhc01heFRhZ3MgfHwgdGFnVmFsaWRhdGlvbjtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmVzIGEgdGFnXHJcbiAgICogQHBhcmFtICB7QXJyYXl8Tm9kZXxTdHJpbmd9ICB0YWdFbG1zICAgICAgICAgW0RPTSBlbGVtZW50KHMpIG9yIGEgU3RyaW5nIHZhbHVlLiBpZiB1bmRlZmluZWQgb3IgbnVsbCwgcmVtb3ZlIGxhc3QgYWRkZWQgdGFnXVxyXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICAgICAgc2lsZW50ICAgICAgICAgIFtBIGZsYWcsIHdoaWNoIHdoZW4gdHVybmVkIG9uLCBkb2VzIG5vdCByZW1vdmUgYW55IHZhbHVlIGFuZCBkb2VzIG5vdCB1cGRhdGUgdGhlIG9yaWdpbmFsIGlucHV0IHZhbHVlIGJ1dCBzaW1wbHkgcmVtb3ZlcyB0aGUgdGFnIGZyb20gdGFnaWZ5XVxyXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgdHJhbkR1cmF0aW9uICAgIFtUcmFuc2l0aW9uIGR1cmF0aW9uIGluIE1TXVxyXG4gICAqIFRPRE86IEFsbG93IG11bHRpcGxlIHRhZ3MgdG8gYmUgcmVtb3ZlZCBhdC1vbmNlXHJcbiAgICovXG4gIHJlbW92ZVRhZ3ModGFnRWxtcywgc2lsZW50LCB0cmFuRHVyYXRpb24pIHtcbiAgICB2YXIgdGFnc1RvUmVtb3ZlO1xuICAgIHRhZ0VsbXMgPSB0YWdFbG1zICYmIHRhZ0VsbXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFt0YWdFbG1zXSA6IHRhZ0VsbXMgaW5zdGFuY2VvZiBBcnJheSA/IHRhZ0VsbXMgOiB0YWdFbG1zID8gW3RhZ0VsbXNdIDogW3RoaXMuZ2V0TGFzdFRhZygpXTsgLy8gbm9ybWFsaXplIHRhZ0VsbXMgYXJyYXkgdmFsdWVzOlxuICAgIC8vIDEuIHJlbW92aW5nIGludmFsaWQgaXRlbXNcbiAgICAvLyAyLCBpZiBhbiBpdGVtIGlzIFN0cmluZyB0cnkgdG8gZ2V0IHRoZSBtYXRjaGluZyBUYWcgSFRNTCBub2RlXG4gICAgLy8gMy4gZ2V0IHRoZSB0YWcgZGF0YVxuICAgIC8vIDQuIHJldHVybiBhIGNvbGxlY3Rpb24gb2YgT2JqZWN0c1xuXG4gICAgdGFnc1RvUmVtb3ZlID0gdGFnRWxtcy5yZWR1Y2UoKGVsbXMsIHRhZ0VsbSkgPT4ge1xuICAgICAgaWYgKHRhZ0VsbSAmJiB0eXBlb2YgdGFnRWxtID09ICdzdHJpbmcnKSB0YWdFbG0gPSB0aGlzLmdldFRhZ0VsbUJ5VmFsdWUodGFnRWxtKTtcbiAgICAgIHZhciB0YWdEYXRhID0gdGhpcy50YWdEYXRhKHRhZ0VsbSk7XG4gICAgICBpZiAodGFnRWxtICYmIHRhZ0RhdGEgJiYgIXRhZ0RhdGEucmVhZG9ubHkpIC8vIG1ha2Ugc3VyZSBpdCdzIGEgdGFnIGFuZCBub3Qgc29tZSBvdGhlciBub2RlXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIERPTSBub2RlIG1pZ2h0IGJlIHJlbW92ZWQgYnkgYXN5bmMgYW5pbWF0aW9uLCB0aGUgc3RhdGUgd2lsbCBiZSB1cGRhdGVkIHdoaWxlXG4gICAgICAgIC8vIHRoZSBub2RlIG1pZ2h0IHN0aWxsIGJlIGluIHRoZSBET00sIHNvIHRoZSBcInVwZGF0ZVwiIG1ldGhvZCBzaG91bGQga25vdyB3aGljaCBub2RlcyB0byBpZ25vcmVcbiAgICAgICAgZWxtcy5wdXNoKHtcbiAgICAgICAgICBub2RlOiB0YWdFbG0sXG4gICAgICAgICAgaWR4OiB0aGlzLmdldFRhZ0lkeCh0YWdEYXRhKSxcbiAgICAgICAgICAvLyB0aGlzLmdldE5vZGVJbmRleCh0YWdFbG0pOyAvLyB0aGlzLmdldFRhZ0luZGV4QnlWYWx1ZSh0YWdFbG0udGV4dENvbnRlbnQpXG4gICAgICAgICAgZGF0YTogdGhpcy50YWdEYXRhKHRhZ0VsbSwge1xuICAgICAgICAgICAgJ19fcmVtb3ZlZCc6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBlbG1zO1xuICAgIH0sIFtdKTtcbiAgICB0cmFuRHVyYXRpb24gPSB0eXBlb2YgdHJhbkR1cmF0aW9uID09IFwibnVtYmVyXCIgPyB0cmFuRHVyYXRpb24gOiB0aGlzLkNTU1ZhcnMudGFnSGlkZVRyYW5zaXRpb247XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5tb2RlID09ICdzZWxlY3QnKSB7XG4gICAgICB0cmFuRHVyYXRpb24gPSAwO1xuICAgICAgdGhpcy5pbnB1dC5zZXQuY2FsbCh0aGlzKTtcbiAgICB9IC8vIGlmIG9ubHkgYSBzaW5nbGUgdGFnIGlzIHRvIGJlIHJlbW92ZWRcblxuXG4gICAgaWYgKHRhZ3NUb1JlbW92ZS5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKHRhZ3NUb1JlbW92ZVswXS5ub2RlLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMudGFnTm90QWxsb3dlZCkpIHNpbGVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0YWdzVG9SZW1vdmUubGVuZ3RoKSByZXR1cm47XG4gICAgdGhpcy5zZXR0aW5ncy5ob29rcy5iZWZvcmVSZW1vdmVUYWcodGFnc1RvUmVtb3ZlLCB7XG4gICAgICB0YWdpZnk6IHRoaXNcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUodGFnKSB7XG4gICAgICAgIGlmICghdGFnLm5vZGUucGFyZW50Tm9kZSkgcmV0dXJuO1xuICAgICAgICB0YWcubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZy5ub2RlKTtcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIC8vIHRoaXMucmVtb3ZlVmFsdWVCeUlkKHRhZ0RhdGEuX191aWQpXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZW1vdmUnLCB7XG4gICAgICAgICAgICB0YWc6IHRhZy5ub2RlLFxuICAgICAgICAgICAgaW5kZXg6IHRhZy5pZHgsXG4gICAgICAgICAgICBkYXRhOiB0YWcuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZHJvcGRvd24ucmVmaWx0ZXIoKTtcbiAgICAgICAgICB0aGlzLmRyb3Bkb3duLnBvc2l0aW9uKCk7XG4gICAgICAgICAgdGhpcy5ET00uaW5wdXQubm9ybWFsaXplKCk7IC8vIGJlc3QtcHJhY3RpY2Ugd2hlbiBpbiBtaXgtbW9kZSAoc2FmZSB0byBkbyBhbHdheXMgYW55d2F5cylcbiAgICAgICAgICAvLyBjaGVjayBpZiBhbnkgb2YgdGhlIGN1cnJlbnQgdGFncyB3aGljaCBtaWdodCBoYXZlIGJlZW4gbWFya2VkIGFzIFwiZHVwbGljYXRlXCIgc2hvdWxkIGJlIHVuLW1hcmtlZFxuXG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mua2VlcEludmFsaWRUYWdzKSB0aGlzLnJlQ2hlY2tJbnZhbGlkVGFncygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Mua2VlcEludmFsaWRUYWdzKSB0aGlzLnRyaWdnZXIoJ3JlbW92ZScsIHtcbiAgICAgICAgICB0YWc6IHRhZy5ub2RlLFxuICAgICAgICAgIGluZGV4OiB0YWcuaWR4XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhbmltYXRpb24odGFnKSB7XG4gICAgICAgIHRhZy5ub2RlLnN0eWxlLndpZHRoID0gcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YWcubm9kZSkud2lkdGgpICsgJ3B4JztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGllbnRUb3A7IC8vIGZvcmNlIHJlcGFpbnQgZm9yIHRoZSB3aWR0aCB0byB0YWtlIGFmZmVjdCBiZWZvcmUgdGhlIFwiaGlkZVwiIGNsYXNzIGJlbG93XG5cbiAgICAgICAgdGFnLm5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMudGFnSGlkZSk7IC8vIG1hbnVhbCB0aW1lb3V0IChoYWNrLCBzaW5jZSB0cmFuc2l0aW9uZW5kIGNhbm5vdCBiZSB1c2VkIGJlY2F1c2Ugb2YgaG92ZXIpXG5cbiAgICAgICAgc2V0VGltZW91dChyZW1vdmVOb2RlLmJpbmQodGhpcyksIHRyYW5EdXJhdGlvbiwgdGFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5EdXJhdGlvbiAmJiB0cmFuRHVyYXRpb24gPiAxMCAmJiB0YWdzVG9SZW1vdmUubGVuZ3RoID09IDEpIGFuaW1hdGlvbi5jYWxsKHRoaXMsIHRhZ3NUb1JlbW92ZVswXSk7ZWxzZSB0YWdzVG9SZW1vdmUuZm9yRWFjaChyZW1vdmVOb2RlLmJpbmQodGhpcykpOyAvLyB1cGRhdGUgc3RhdGUgcmVnYXJkbGVzcyBvZiBhbmltYXRpb25cblxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUYWdzRnJvbVZhbHVlKHRhZ3NUb1JlbW92ZS5tYXAodGFnID0+IHRhZy5ub2RlKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7IC8vIHVwZGF0ZSB0aGUgb3JpZ2luYWwgaW5wdXQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1vZGUgPT0gJ3NlbGVjdCcpIHRoaXMuc2V0Q29udGVudEVkaXRhYmxlKHRydWUpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7fSk7XG4gIH0sXG5cbiAgcmVtb3ZlVGFnc0Zyb21ET00oKSB7XG4gICAgW10uc2xpY2UuY2FsbCh0aGlzLmdldFRhZ0VsbXMoKSkuZm9yRWFjaChlbG0gPT4gZWxtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxtKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtBcnJheS9Ob2RlfSB0YWdzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgdGhpcy52YWx1ZSBhcnJheVxyXG4gICAqL1xuICByZW1vdmVUYWdzRnJvbVZhbHVlKHRhZ3MpIHtcbiAgICB0YWdzID0gQXJyYXkuaXNBcnJheSh0YWdzKSA/IHRhZ3MgOiBbdGFnc107XG4gICAgdGFncy5mb3JFYWNoKHRhZyA9PiB7XG4gICAgICB2YXIgdGFnRGF0YSA9IHRoaXMudGFnRGF0YSh0YWcpLFxuICAgICAgICAgIHRhZ0lkeCA9IHRoaXMuZ2V0VGFnSWR4KHRhZ0RhdGEpOyAvLyAgZGVsZXRlIHRhZ0RhdGEuX19yZW1vdmVkXG5cbiAgICAgIGlmICh0YWdJZHggPiAtMSkgdGhpcy52YWx1ZS5zcGxpY2UodGFnSWR4LCAxKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmVBbGxUYWdzKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnZhbHVlID0gW107XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubW9kZSA9PSAnbWl4JykgdGhpcy5ET00uaW5wdXQuaW5uZXJIVE1MID0gJyc7ZWxzZSB0aGlzLnJlbW92ZVRhZ3NGcm9tRE9NKCk7XG4gICAgdGhpcy5kcm9wZG93bi5wb3NpdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubW9kZSA9PSAnc2VsZWN0Jykge1xuICAgICAgdGhpcy5pbnB1dC5zZXQuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc2V0Q29udGVudEVkaXRhYmxlKHRydWUpO1xuICAgIH0gLy8gdGVjaG5pY2FsbHkgZm9yIG5vdyBvbmx5IFwid2l0aG91dENoYW5nZUV2ZW50XCIgZXhpc3RzIGluIHRoZSBvcHRzLlxuICAgIC8vIGlmIG1vcmUgcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIGxhdGVyLCBvbmx5IHBhc3Mgd2hhdCdzIG5lZWRlZCB0byBcInVwZGF0ZVwiXG5cblxuICAgIHRoaXMudXBkYXRlKG9wdHMpO1xuICB9LFxuXG4gIHBvc3RVcGRhdGUoKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLnNldHRpbmdzLmNsYXNzTmFtZXMsXG4gICAgICAgIGhhc1ZhbHVlID0gdGhpcy5zZXR0aW5ncy5tb2RlID09ICdtaXgnID8gdGhpcy5zZXR0aW5ncy5taXhNb2RlLmludGVncmF0ZWQgPyB0aGlzLkRPTS5pbnB1dC50ZXh0Q29udGVudCA6IHRoaXMuRE9NLm9yaWdpbmFsSW5wdXQudmFsdWUudHJpbSgpIDogdGhpcy52YWx1ZS5sZW5ndGggKyB0aGlzLmlucHV0LnJhdy5jYWxsKHRoaXMpLmxlbmd0aDtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuaGFzTWF4VGFncywgdGhpcy52YWx1ZS5sZW5ndGggPj0gdGhpcy5zZXR0aW5ncy5tYXhUYWdzKTtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuaGFzTm9UYWdzLCAhdGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3MoY2xhc3NOYW1lcy5lbXB0eSwgIWhhc1ZhbHVlKTtcbiAgfSxcblxuICBzZXRPcmlnaW5hbElucHV0VmFsdWUodikge1xuICAgIHZhciBpbnB1dEVsbSA9IHRoaXMuRE9NLm9yaWdpbmFsSW5wdXQ7XG5cbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MubWl4TW9kZS5pbnRlZ3JhdGVkKSB7XG4gICAgICBpbnB1dEVsbS52YWx1ZSA9IHY7XG4gICAgICBpbnB1dEVsbS50YWdpZnlWYWx1ZSA9IGlucHV0RWxtLnZhbHVlOyAvLyBtdXN0IHNldCB0byBcImlucHV0RWxtLnZhbHVlXCIgYW5kIG5vdCBhZ2FpbiB0byBcImlucHV0VmFsdWVcIiBiZWNhdXNlIGZvciBzb21lIHJlYXNvbiB0aGUgYnJvd3NlciBjaGFuZ2VzIHRoZSBzdHJpbmcgYWZ0ZXJ3YXJkcyBhIGJpdC5cblxuICAgICAgdGhpcy5zZXRQZXJzaXN0ZWREYXRhKHYsICd2YWx1ZScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiB1cGRhdGUgdGhlIG9yaWdpYW5sIChoaWRkZW4pIGlucHV0IGZpZWxkJ3MgdmFsdWVcclxuICAgKiBzZWUgLSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNTA5NTc4NDEvMTA0MzgwXHJcbiAgICovXG4gIHVwZGF0ZShhcmdzKSB7XG4gICAgdmFyIGlucHV0VmFsdWUgPSB0aGlzLmdldElucHV0VmFsdWUoKTtcbiAgICB0aGlzLnNldE9yaWdpbmFsSW5wdXRWYWx1ZShpbnB1dFZhbHVlKTtcbiAgICB0aGlzLnBvc3RVcGRhdGUoKTtcbiAgICBpZiAoIShhcmdzIHx8IHt9KS53aXRob3V0Q2hhbmdlRXZlbnQgJiYgdGhpcy5zdGF0ZS5sb2FkZWRPcmlnaW5hbFZhbHVlcykgdGhpcy50cmlnZ2VyQ2hhbmdlRXZlbnQoKTtcbiAgfSxcblxuICBnZXRJbnB1dFZhbHVlKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0Q2xlYW5WYWx1ZSgpO1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLm1vZGUgPT0gJ21peCcgPyB0aGlzLmdldE1peGVkVGFnc0FzU3RyaW5nKHZhbHVlKSA6IHZhbHVlLmxlbmd0aCA/IHRoaXMuc2V0dGluZ3Mub3JpZ2luYWxJbnB1dFZhbHVlRm9ybWF0ID8gdGhpcy5zZXR0aW5ncy5vcmlnaW5hbElucHV0VmFsdWVGb3JtYXQodmFsdWUpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogXCJcIjtcbiAgfSxcblxuICAvKipcclxuICAgKiByZW1vdmVzIHByb3BlcnRpZXMgZnJvbSBgdGhpcy52YWx1ZWAgd2hpY2ggYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5XHJcbiAgICovXG4gIGdldENsZWFuVmFsdWUodikge1xuICAgIHJldHVybiByZW1vdmVDb2xsZWN0aW9uUHJvcCh2IHx8IHRoaXMudmFsdWUsIHRoaXMuZGF0YVByb3BzKTtcbiAgfSxcblxuICBnZXRNaXhlZFRhZ3NBc1N0cmluZygpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgIF9pbnRlcnBvbGF0b3IgPSB0aGlzLnNldHRpbmdzLm1peFRhZ3NJbnRlcnBvbGF0b3I7XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlQ2hpbGRyZW4ocm9vdE5vZGUpIHtcbiAgICAgIHJvb3ROb2RlLmNoaWxkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSB0aGF0LnRhZ0RhdGEobm9kZSk7XG5cbiAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09ICdCUicpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcclxcblwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT0gJ0RJVicgfHwgbm9kZS50YWdOYW1lID09ICdQJykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxyXFxuXCI7IC8vICBpZiggIW5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmIG5vZGUudGV4dENvbnRlbnQgKVxuICAgICAgICAgICAgLy8gIHJlc3VsdCArPSBub2RlLnRleHRDb250ZW50O1xuXG4gICAgICAgICAgICBpdGVyYXRlQ2hpbGRyZW4obm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc05vZGVUYWcuY2FsbCh0aGF0LCBub2RlKSAmJiB0YWdEYXRhKSB7XG4gICAgICAgICAgICBpZiAodGFnRGF0YS5fX3JlbW92ZWQpIHJldHVybjtlbHNlIHJlc3VsdCArPSBfaW50ZXJwb2xhdG9yWzBdICsgSlNPTi5zdHJpbmdpZnkob21pdCh0YWdEYXRhLCB0aGF0LmRhdGFQcm9wcykpICsgX2ludGVycG9sYXRvclsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSByZXN1bHQgKz0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGl0ZXJhdGVDaGlsZHJlbih0aGlzLkRPTS5pbnB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG59OyAvLyBsZWdhY3kgc3VwcG9ydCBmb3IgY2hhbmdlZCBtZXRob2RzIG5hbWVzXG5cblRhZ2lmeS5wcm90b3R5cGUucmVtb3ZlVGFnID0gVGFnaWZ5LnByb3RvdHlwZS5yZW1vdmVUYWdzO1xuXG5leHBvcnQgeyBUYWdpZnkgYXMgZGVmYXVsdCB9O1xuIiwiLy8gRkYyNi0gYnVnOiBBcnJheUJ1ZmZlcnMgYXJlIG5vbi1leHRlbnNpYmxlLCBidXQgT2JqZWN0LmlzRXh0ZW5zaWJsZSBkb2VzIG5vdCByZXBvcnQgaXRcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZShidWZmZXIpKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVmZmVyLCAnYScsIHsgdmFsdWU6IDggfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yJyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG52YXIgQXJyYXkgPSBnbG9iYWwuQXJyYXk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgdmFyIElTX0NPTlNUUlVDVE9SID0gaXNDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0LCB2YWx1ZTtcbiAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICYmICEodGhpcyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdO1xuICAgIGZvciAoOyEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiBBcnJheShsZW5ndGgpO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1jbG9zZScpO1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJykuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgUHJvdG90eXBlKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxuICAgICAgICBmaXJzdDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IDBcbiAgICAgIH0pO1xuICAgICAgaWYgKCFERVNDUklQVE9SUykgdGhhdC5zaXplID0gMDtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDtcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZW1vdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuICAgICAgICBpZiAocHJldmlvdXMpIHByZXZpb3VzLm5leHQgPSBlbnRyeTtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplKys7XG4gICAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgLy8gZmFzdCBjYXNlXG4gICAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gICAgICB2YXIgZW50cnk7XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTtcbiAgICAgIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICAgICAgZm9yIChlbnRyeSA9IHN0YXRlLmZpcnN0OyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uZXh0KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlZGVmaW5lQWxsKFByb3RvdHlwZSwge1xuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuY2xlYXIoKWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmNsZWFyXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuY2xlYXJcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcbiAgICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLmxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSA9IDA7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5kZWxldGUoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgICAgICBpZiAoc3RhdGUuZmlyc3QgPT0gZW50cnkpIHN0YXRlLmZpcnN0ID0gbmV4dDtcbiAgICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG4gICAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplLS07XG4gICAgICAgICAgZWxzZSB0aGF0LnNpemUtLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmZvcmVhY2hcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldH0ucHJvdG90eXBlLmhhcyhrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlZGVmaW5lQWxsKFByb3RvdHlwZSwgSVNfTUFQID8ge1xuICAgICAgLy8gYE1hcC5wcm90b3R5cGUuZ2V0KGtleSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmdldFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgLy8gYFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuYWRkXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApIHtcbiAgICB2YXIgSVRFUkFUT1JfTkFNRSA9IENPTlNUUlVDVE9SX05BTUUgKyAnIEl0ZXJhdG9yJztcbiAgICB2YXIgZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuICAgIHZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKElURVJBVE9SX05BTUUpO1xuICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLnsga2V5cywgdmFsdWVzLCBlbnRyaWVzLCBAQGl0ZXJhdG9yIH0oKWAgbWV0aG9kc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5lbnRyaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmtleXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUudmFsdWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLUBAaXRlcmF0b3JcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgZGVmaW5lSXRlcmF0b3IoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXG4gICAgICAgIHRhcmdldDogaXRlcmF0ZWQsXG4gICAgICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBlbnRyeS5rZXksIGRvbmU6IGZhbHNlIH07XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IGVudHJ5LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZVtAQHNwZWNpZXNdYCBhY2Nlc3NvcnNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1tYXAtQEBzcGVjaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSwgd3JhcHBlciwgY29tbW9uKSB7XG4gIHZhciBJU19NQVAgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ01hcCcpICE9PSAtMTtcbiAgdmFyIElTX1dFQUsgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ1dlYWsnKSAhPT0gLTE7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbFtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIENvbnN0cnVjdG9yID0gTmF0aXZlQ29uc3RydWN0b3I7XG4gIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIHVuY3VycmllZE5hdGl2ZU1ldGhvZCA9IHVuY3VycnlUaGlzKE5hdGl2ZVByb3RvdHlwZVtLRVldKTtcbiAgICByZWRlZmluZShOYXRpdmVQcm90b3R5cGUsIEtFWSxcbiAgICAgIEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IHVuZGVmaW5lZCA6IHVuY3VycmllZE5hdGl2ZU1ldGhvZCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiB1bmN1cnJpZWROYXRpdmVNZXRob2QodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICB2YXIgUkVQTEFDRSA9IGlzRm9yY2VkKFxuICAgIENPTlNUUlVDVE9SX05BTUUsXG4gICAgIWlzQ2FsbGFibGUoTmF0aXZlQ29uc3RydWN0b3IpIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcbiAgICB9KSlcbiAgKTtcblxuICBpZiAoUkVQTEFDRSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5lbmFibGUoKTtcbiAgfSBlbHNlIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0cnVlKSkge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihpdGVyYWJsZSk7IH0pO1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIE5hdGl2ZVByb3RvdHlwZSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCksIGR1bW15LCBDb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE5hdGl2ZVByb3RvdHlwZTtcbiAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cblxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuXG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XG4gIH1cblxuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IENvbnN0cnVjdG9yICE9IE5hdGl2ZUNvbnN0cnVjdG9yIH0sIGV4cG9ydGVkKTtcblxuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgcGFkU3RhcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXBhZCcpLnN0YXJ0O1xuXG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbnZhciBuJERhdGVUb0lTT1N0cmluZyA9IERhdGVQcm90b3R5cGUudG9JU09TdHJpbmc7XG52YXIgZ2V0VGltZSA9IHVuY3VycnlUaGlzKERhdGVQcm90b3R5cGUuZ2V0VGltZSk7XG52YXIgZ2V0VVRDRGF0ZSA9IHVuY3VycnlUaGlzKERhdGVQcm90b3R5cGUuZ2V0VVRDRGF0ZSk7XG52YXIgZ2V0VVRDRnVsbFllYXIgPSB1bmN1cnJ5VGhpcyhEYXRlUHJvdG90eXBlLmdldFVUQ0Z1bGxZZWFyKTtcbnZhciBnZXRVVENIb3VycyA9IHVuY3VycnlUaGlzKERhdGVQcm90b3R5cGUuZ2V0VVRDSG91cnMpO1xudmFyIGdldFVUQ01pbGxpc2Vjb25kcyA9IHVuY3VycnlUaGlzKERhdGVQcm90b3R5cGUuZ2V0VVRDTWlsbGlzZWNvbmRzKTtcbnZhciBnZXRVVENNaW51dGVzID0gdW5jdXJyeVRoaXMoRGF0ZVByb3RvdHlwZS5nZXRVVENNaW51dGVzKTtcbnZhciBnZXRVVENNb250aCA9IHVuY3VycnlUaGlzKERhdGVQcm90b3R5cGUuZ2V0VVRDTW9udGgpO1xudmFyIGdldFVUQ1NlY29uZHMgPSB1bmN1cnJ5VGhpcyhEYXRlUHJvdG90eXBlLmdldFVUQ1NlY29uZHMpO1xuXG4vLyBgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1kYXRlLnByb3RvdHlwZS50b2lzb3N0cmluZ1xuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBmYWlscyBoZXJlOlxubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbiREYXRlVG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZSgtNWUxMyAtIDEpKSAhPSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJztcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIG4kRGF0ZVRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoTmFOKSk7XG59KSkgPyBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgaWYgKCFpc0Zpbml0ZShnZXRUaW1lKHRoaXMpKSkgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gIHZhciBkYXRlID0gdGhpcztcbiAgdmFyIHllYXIgPSBnZXRVVENGdWxsWWVhcihkYXRlKTtcbiAgdmFyIG1pbGxpc2Vjb25kcyA9IGdldFVUQ01pbGxpc2Vjb25kcyhkYXRlKTtcbiAgdmFyIHNpZ24gPSB5ZWFyIDwgMCA/ICctJyA6IHllYXIgPiA5OTk5ID8gJysnIDogJyc7XG4gIHJldHVybiBzaWduICsgcGFkU3RhcnQoYWJzKHllYXIpLCBzaWduID8gNiA6IDQsIDApICtcbiAgICAnLScgKyBwYWRTdGFydChnZXRVVENNb250aChkYXRlKSArIDEsIDIsIDApICtcbiAgICAnLScgKyBwYWRTdGFydChnZXRVVENEYXRlKGRhdGUpLCAyLCAwKSArXG4gICAgJ1QnICsgcGFkU3RhcnQoZ2V0VVRDSG91cnMoZGF0ZSksIDIsIDApICtcbiAgICAnOicgKyBwYWRTdGFydChnZXRVVENNaW51dGVzKGRhdGUpLCAyLCAwKSArXG4gICAgJzonICsgcGFkU3RhcnQoZ2V0VVRDU2Vjb25kcyhkYXRlKSwgMiwgMCkgK1xuICAgICcuJyArIHBhZFN0YXJ0KG1pbGxpc2Vjb25kcywgMywgMCkgK1xuICAgICdaJztcbn0gOiBuJERhdGVUb0lTT1N0cmluZztcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy9uby1vYmplY3QtcHJldmVudGV4dGVuc2lvbnMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWxNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwnKTtcbnZhciBpc0V4dGVuc2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgRlJFRVpJTkcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnJlZXppbmcnKTtcblxudmFyIFJFUVVJUkVEID0gZmFsc2U7XG52YXIgTUVUQURBVEEgPSB1aWQoJ21ldGEnKTtcbnZhciBpZCA9IDA7XG5cbnZhciBzZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHsgdmFsdWU6IHtcbiAgICBvYmplY3RJRDogJ08nICsgaWQrKywgLy8gb2JqZWN0IElEXG4gICAgd2Vha0RhdGE6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBhIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXNPd24oaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEO1xufTtcblxudmFyIGdldFdlYWtEYXRhID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXNPd24oaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiB0aGUgc3RvcmUgb2Ygd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xufTtcblxuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaSU5HICYmIFJFUVVJUkVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhc093bihpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBlbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIG1ldGEuZW5hYmxlID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuICBSRVFVSVJFRCA9IHRydWU7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mO1xuICB2YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMoW10uc3BsaWNlKTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdGVzdFtNRVRBREFUQV0gPSAxO1xuXG4gIC8vIHByZXZlbnQgZXhwb3Npbmcgb2YgbWV0YWRhdGEga2V5XG4gIGlmIChnZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QpLmxlbmd0aCkge1xuICAgIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGZ1bmN0aW9uIChpdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzdWx0W2ldID09PSBNRVRBREFUQSkge1xuICAgICAgICAgIHNwbGljZShyZXN1bHQsIGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgICQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgICAgZ2V0T3duUHJvcGVydHlOYW1lczogZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlLmZcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5hYmxlOiBlbmFibGUsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5oaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG4iLCJ2YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE9HMTBFID0gTWF0aC5MT0cxMEU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1tYXRoLWxvZzEwIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxMCB8fCBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gIHJldHVybiBsb2coeCkgKiBMT0cxMEU7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9yZWxhdGl2ZS11cmwtc3R5bGUgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIHVybCA9IG5ldyBVUkwoJ2I/YT0xJmI9MiZjPTMnLCAnaHR0cDovL2EnKTtcbiAgdmFyIHNlYXJjaFBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdXJsLnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgc2VhcmNoUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBzZWFyY2hQYXJhbXNbJ2RlbGV0ZSddKCdiJyk7XG4gICAgcmVzdWx0ICs9IGtleSArIHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIChJU19QVVJFICYmICF1cmwudG9KU09OKVxuICAgIHx8ICFzZWFyY2hQYXJhbXMuc29ydFxuICAgIHx8IHVybC5ocmVmICE9PSAnaHR0cDovL2EvYyUyMGQ/YT0xJmM9MydcbiAgICB8fCBzZWFyY2hQYXJhbXMuZ2V0KCdjJykgIT09ICczJ1xuICAgIHx8IFN0cmluZyhuZXcgVVJMU2VhcmNoUGFyYW1zKCc/YT0xJykpICE9PSAnYT0xJ1xuICAgIHx8ICFzZWFyY2hQYXJhbXNbSVRFUkFUT1JdXG4gICAgLy8gdGhyb3dzIGluIEVkZ2VcbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2FAYicpLnVzZXJuYW1lICE9PSAnYSdcbiAgICB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9YicpKS5nZXQoJ2EnKSAhPT0gJ2InXG4gICAgLy8gbm90IHB1bnljb2RlZCBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cDovL9GC0LXRgdGCJykuaG9zdCAhPT0gJ3huLS1lMWF5YmMnXG4gICAgLy8gbm90IGVzY2FwZWQgaW4gQ2hyb21lIDYyLVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnXG4gICAgLy8gZmFpbHMgaW4gQ2hyb21lIDY2LVxuICAgIHx8IHJlc3VsdCAhPT0gJ2ExYzMnXG4gICAgLy8gdGhyb3dzIGluIFNhZmFyaVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly94JywgdW5kZWZpbmVkKS5ob3N0ICE9PSAneCc7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG5cbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNSZWdFeHAoaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSAtLSBzYWZlXG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgJGlzRXh0ZW5zaWJsZSgxKTsgfSk7XG5cbi8vIGBPYmplY3QuaXNFeHRlbnNpYmxlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmlzZXh0ZW5zaWJsZVxubW9kdWxlLmV4cG9ydHMgPSAoRkFJTFNfT05fUFJJTUlUSVZFUyB8fCBBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUpID8gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChBUlJBWV9CVUZGRVJfTk9OX0VYVEVOU0lCTEUgJiYgY2xhc3NvZihpdCkgPT0gJ0FycmF5QnVmZmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZTtcbn0gOiAkaXNFeHRlbnNpYmxlO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciAkcmVwZWF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgcmVwZWF0ID0gdW5jdXJyeVRoaXMoJHJlcGVhdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBwYWRTdGFydCwgcGFkRW5kIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfRU5EKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIG1heExlbmd0aCwgZmlsbFN0cmluZykge1xuICAgIHZhciBTID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICAgIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IHRvU3RyaW5nKGZpbGxTdHJpbmcpO1xuICAgIHZhciBmaWxsTGVuLCBzdHJpbmdGaWxsZXI7XG4gICAgaWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJykgcmV0dXJuIFM7XG4gICAgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgICBzdHJpbmdGaWxsZXIgPSByZXBlYXQoZmlsbFN0ciwgY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgICBpZiAoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pIHN0cmluZ0ZpbGxlciA9IHN0cmluZ1NsaWNlKHN0cmluZ0ZpbGxlciwgMCwgZmlsbExlbik7XG4gICAgcmV0dXJuIElTX0VORCA/IFMgKyBzdHJpbmdGaWxsZXIgOiBzdHJpbmdGaWxsZXIgKyBTO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnBhZHN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5wYWRFbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucGFkZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzL2Jsb2IvbWFzdGVyL3B1bnljb2RlLmpzXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG52YXIgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx1MDA3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbnZhciByZWdleFNlcGFyYXRvcnMgPSAvWy5cXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcbnZhciBPVkVSRkxPV19FUlJPUiA9ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2Vzcyc7XG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xuXG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcyhyZWdleFNlcGFyYXRvcnMuZXhlYyk7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xudmFyIHRvTG93ZXJDYXNlID0gdW5jdXJyeVRoaXMoJycudG9Mb3dlckNhc2UpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqL1xudmFyIHVjczJkZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBjaGFyQ29kZUF0KHN0cmluZywgY291bnRlcisrKTtcbiAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuICAgICAgdmFyIGV4dHJhID0gY2hhckNvZGVBdChzdHJpbmcsIGNvdW50ZXIrKyk7XG4gICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cbiAgICAgICAgcHVzaChvdXRwdXQsICgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuICAgICAgICAvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgcHVzaChvdXRwdXQsIHZhbHVlKTtcbiAgICAgICAgY291bnRlci0tO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKG91dHB1dCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNik7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiAoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG4gIHZhciBrID0gMDtcbiAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiAgZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuICB3aGlsZSAoZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxKSB7XG4gICAgZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuICAgIGsgKz0gYmFzZTtcbiAgfVxuICByZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuXG4gIC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIGFuIGFycmF5IG9mIFVuaWNvZGUgY29kZSBwb2ludHMuXG4gIGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cbiAgLy8gQ2FjaGUgdGhlIGxlbmd0aC5cbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlLlxuICB2YXIgbiA9IGluaXRpYWxOO1xuICB2YXIgZGVsdGEgPSAwO1xuICB2YXIgYmlhcyA9IGluaXRpYWxCaWFzO1xuICB2YXIgaSwgY3VycmVudFZhbHVlO1xuXG4gIC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHMuXG4gIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgIGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG4gICAgICBwdXNoKG91dHB1dCwgZnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7IC8vIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cbiAgdmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7IC8vIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXG4gIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG4gIGlmIChiYXNpY0xlbmd0aCkge1xuICAgIHB1c2gob3V0cHV0LCBkZWxpbWl0ZXIpO1xuICB9XG5cbiAgLy8gTWFpbiBlbmNvZGluZyBsb29wOlxuICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHQgbGFyZ2VyIG9uZTpcbiAgICB2YXIgbSA9IG1heEludDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcbiAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuICAgIHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG4gICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgIHRocm93IFJhbmdlRXJyb3IoT1ZFUkZMT1dfRVJST1IpO1xuICAgIH1cblxuICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgbiA9IG07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKE9WRVJGTE9XX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgICAgdmFyIHEgPSBkZWx0YTtcbiAgICAgICAgdmFyIGsgPSBiYXNlO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcbiAgICAgICAgICBpZiAocSA8IHQpIGJyZWFrO1xuICAgICAgICAgIHZhciBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgdmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICBwdXNoKG91dHB1dCwgZnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QpKSk7XG4gICAgICAgICAgcSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcbiAgICAgICAgICBrICs9IGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoKG91dHB1dCwgZnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxKSkpO1xuICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgIGhhbmRsZWRDUENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsdGErKztcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIGpvaW4ob3V0cHV0LCAnJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgZW5jb2RlZCA9IFtdO1xuICB2YXIgbGFiZWxzID0gc3BsaXQocmVwbGFjZSh0b0xvd2VyQ2FzZShpbnB1dCksIHJlZ2V4U2VwYXJhdG9ycywgJ1xcdTAwMkUnKSwgJy4nKTtcbiAgdmFyIGksIGxhYmVsO1xuICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgcHVzaChlbmNvZGVkLCBleGVjKHJlZ2V4Tm9uQVNDSUksIGxhYmVsKSA/ICd4bi0tJyArIGVuY29kZShsYWJlbCkgOiBsYWJlbCk7XG4gIH1cbiAgcmV0dXJuIGpvaW4oZW5jb2RlZCwgJy4nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZXZlcnk7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0Jyk7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZXZlcnknKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfSwge1xuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmaWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZpbGwnKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBmaWxsOiBmaWxsXG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnZmlsbCcpO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mcm9tJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgZnJvbTogZnJvbVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmNsdWRlcztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGF0ZS10by1pc28tc3RyaW5nJyk7XG5cbi8vIGBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWRhdGUucHJvdG90eXBlLnRvaXNvc3RyaW5nXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiQoeyB0YXJnZXQ6ICdEYXRlJywgcHJvdG86IHRydWUsIGZvcmNlZDogRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nIH0sIHtcbiAgdG9JU09TdHJpbmc6IHRvSVNPU3RyaW5nXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuLy8gYGdsb2JhbFRoaXNgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nbG9iYWx0aGlzXG4kKHsgZ2xvYmFsOiB0cnVlIH0sIHtcbiAgZ2xvYmFsVGhpczogZ2xvYmFsXG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcblxuLy8gSlNPTltAQHRvU3RyaW5nVGFnXSBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbicpO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gYE1hcGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLW9iamVjdHNcbmNvbGxlY3Rpb24oJ01hcCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBsb2cxMCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYXRoLWxvZzEwJyk7XG5cbi8vIGBNYXRoLmxvZzEwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC5sb2cxMFxuJCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHtcbiAgbG9nMTA6IGxvZzEwXG59KTtcbiIsInZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG4vLyBNYXRoW0BAdG9TdHJpbmdUYWddIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbnVtYmVyLXBhcnNlLWZsb2F0Jyk7XG5cbi8vIGBOdW1iZXIucGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5wYXJzZUZsb2F0XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbnVtYmVyLXBhcnNlZmxvYXQgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE51bWJlci5wYXJzZUZsb2F0ICE9IHBhcnNlRmxvYXQgfSwge1xuICBwYXJzZUZsb2F0OiBwYXJzZUZsb2F0XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHBhcnNlSW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL251bWJlci1wYXJzZS1pbnQnKTtcblxuLy8gYE51bWJlci5wYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5wYXJzZWludFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW51bWJlci1wYXJzZWludCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuJCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUsIGZvcmNlZDogTnVtYmVyLnBhcnNlSW50ICE9IHBhcnNlSW50IH0sIHtcbiAgcGFyc2VJbnQ6IHBhcnNlSW50XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKS5mO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICE9PSBkZWZpbmVQcm9wZXJ0aWVzLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBkZWZpbmVQcm9wZXJ0aWVzOiBkZWZpbmVQcm9wZXJ0aWVzXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIEZSRUVaSU5HID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZyZWV6aW5nJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBvbkZyZWV6ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YScpLm9uRnJlZXplO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWZyZWV6ZSAtLSBzYWZlXG52YXIgJGZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgJGZyZWV6ZSgxKTsgfSk7XG5cbi8vIGBPYmplY3QuZnJlZXplYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmZyZWV6ZVxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUywgc2hhbTogIUZSRUVaSU5HIH0sIHtcbiAgZnJlZXplOiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG9uRnJlZXplKGl0KSkgOiBpdDtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBrZXksIGRlc2NyaXB0b3I7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5ID0ga2V5c1tpbmRleCsrXSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgb25GcmVlemUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKS5vbkZyZWV6ZTtcbnZhciBGUkVFWklORyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mcmVlemluZycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtcHJldmVudGV4dGVuc2lvbnMgLS0gc2FmZVxudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyAkcHJldmVudEV4dGVuc2lvbnMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByZXZlbnRleHRlbnNpb25zXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTLCBzaGFtOiAhRlJFRVpJTkcgfSwge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhvbkZyZWV6ZShpdCkpIDogaXQ7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBzZXRQcm90b3R5cGVPZjogc2V0UHJvdG90eXBlT2Zcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBhcHBseSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1hcHBseScpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZCcpO1xudmFyIGFDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNvbnN0cnVjdG9yJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgbmF0aXZlQ29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBgUmVmbGVjdC5jb25zdHJ1Y3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmNvbnN0cnVjdFxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEobmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcblxudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxudmFyIEZPUkNFRCA9IE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHO1xuXG4kKHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiBGT1JDRUQgfSwge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhQ29uc3RydWN0b3IoVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhQ29uc3RydWN0b3IoYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gbmF0aXZlQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgIGFwcGx5KHB1c2gsICRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGFwcGx5KGJpbmQsIFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdFByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IGFwcGx5KFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbicpO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gYFNldGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcbmNvbGxlY3Rpb24oJ1NldCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVIVE1MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sJyk7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctaHRtbC1mb3JjZWQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuZml4ZWRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmZpeGVkXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCgnZml4ZWQnKSB9LCB7XG4gIGZpeGVkOiBmdW5jdGlvbiBmaXhlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIG5vdEFSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYycpO1xuXG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzKCcnLmluZGV4T2YpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJykgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfnN0cmluZ0luZGV4T2YoXG4gICAgICB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKSxcbiAgICAgIHRvU3RyaW5nKG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKSksXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIG5vdEFSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc3RyaW5nLXByb3RvdHlwZS1zdGFydHN3aXRoIC0tIHNhZmVcbnZhciB1biRTdGFydHNXaXRoID0gdW5jdXJyeVRoaXMoJycuc3RhcnRzV2l0aCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgbWluID0gTWF0aC5taW47XG5cbnZhciBDT1JSRUNUX0lTX1JFR0VYUF9MT0dJQyA9IGNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdzdGFydHNXaXRoJyk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9wdWxsLzcwMlxudmFyIE1ETl9QT0xZRklMTF9CVUcgPSAhSVNfUFVSRSAmJiAhQ09SUkVDVF9JU19SRUdFWFBfTE9HSUMgJiYgISFmdW5jdGlvbiAoKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJyk7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLndyaXRhYmxlO1xufSgpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zdGFydHN3aXRoXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIU1ETl9QT0xZRklMTF9CVUcgJiYgIUNPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDIH0sIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgIG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChtaW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IHRvU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuIHVuJFN0YXJ0c1dpdGhcbiAgICAgID8gdW4kU3RhcnRzV2l0aCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiBzdHJpbmdTbGljZSh0aGF0LCBpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wudG9TdHJpbmdUYWdgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC50b3N0cmluZ3RhZ1xuZGVmaW5lV2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuIiwiLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuZ2xvYmFsLXRoaXMnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IGluIGNvcmUtanNANCwgbW92ZSAvbW9kdWxlcy8gZGVwZW5kZW5jaWVzIHRvIHB1YmxpYyBlbnRyaWVzIGZvciBiZXR0ZXIgb3B0aW1pemF0aW9uIGJ5IHRvb2xzIGxpa2UgYHByZXNldC1lbnZgXG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtdXJsJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBhcnJheVNvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc29ydCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVVJMX1NFQVJDSF9QQVJBTVMgPSAnVVJMU2VhcmNoUGFyYW1zJztcbnZhciBVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUiA9IFVSTF9TRUFSQ0hfUEFSQU1TICsgJ0l0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFVSTF9TRUFSQ0hfUEFSQU1TKTtcbnZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUik7XG5cbnZhciBuJEZldGNoID0gZ2V0QnVpbHRJbignZmV0Y2gnKTtcbnZhciBOJFJlcXVlc3QgPSBnZXRCdWlsdEluKCdSZXF1ZXN0Jyk7XG52YXIgSGVhZGVycyA9IGdldEJ1aWx0SW4oJ0hlYWRlcnMnKTtcbnZhciBSZXF1ZXN0UHJvdG90eXBlID0gTiRSZXF1ZXN0ICYmIE4kUmVxdWVzdC5wcm90b3R5cGU7XG52YXIgSGVhZGVyc1Byb3RvdHlwZSA9IEhlYWRlcnMgJiYgSGVhZGVycy5wcm90b3R5cGU7XG52YXIgUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIGRlY29kZVVSSUNvbXBvbmVudCA9IGdsb2JhbC5kZWNvZGVVUklDb21wb25lbnQ7XG52YXIgZW5jb2RlVVJJQ29tcG9uZW50ID0gZ2xvYmFsLmVuY29kZVVSSUNvbXBvbmVudDtcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIHNoaWZ0ID0gdW5jdXJyeVRoaXMoW10uc2hpZnQpO1xudmFyIHNwbGljZSA9IHVuY3VycnlUaGlzKFtdLnNwbGljZSk7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbnZhciBwbHVzID0gL1xcKy9nO1xudmFyIHNlcXVlbmNlcyA9IEFycmF5KDQpO1xuXG52YXIgcGVyY2VudFNlcXVlbmNlID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHJldHVybiBzZXF1ZW5jZXNbYnl0ZXMgLSAxXSB8fCAoc2VxdWVuY2VzW2J5dGVzIC0gMV0gPSBSZWdFeHAoJygoPzolW1xcXFxkYS1mXXsyfSl7JyArIGJ5dGVzICsgJ30pJywgJ2dpJykpO1xufTtcblxudmFyIHBlcmNlbnREZWNvZGUgPSBmdW5jdGlvbiAoc2VxdWVuY2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHNlcXVlbmNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gc2VxdWVuY2U7XG4gIH1cbn07XG5cbnZhciBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gcmVwbGFjZShpdCwgcGx1cywgJyAnKTtcbiAgdmFyIGJ5dGVzID0gNDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2hpbGUgKGJ5dGVzKSB7XG4gICAgICByZXN1bHQgPSByZXBsYWNlKHJlc3VsdCwgcGVyY2VudFNlcXVlbmNlKGJ5dGVzLS0pLCBwZXJjZW50RGVjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZpbmQgPSAvWyEnKCl+XXwlMjAvZztcblxudmFyIHJlcGxhY2VtZW50cyA9IHtcbiAgJyEnOiAnJTIxJyxcbiAgXCInXCI6ICclMjcnLFxuICAnKCc6ICclMjgnLFxuICAnKSc6ICclMjknLFxuICAnfic6ICclN0UnLFxuICAnJTIwJzogJysnXG59O1xuXG52YXIgcmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgcmV0dXJuIHJlcGxhY2VtZW50c1ttYXRjaF07XG59O1xuXG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiByZXBsYWNlKGVuY29kZVVSSUNvbXBvbmVudChpdCksIGZpbmQsIHJlcGxhY2VyKTtcbn07XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xufTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihmdW5jdGlvbiBJdGVyYXRvcihwYXJhbXMsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IsXG4gICAgaXRlcmF0b3I6IGdldEl0ZXJhdG9yKGdldEludGVybmFsUGFyYW1zU3RhdGUocGFyYW1zKS5lbnRyaWVzKSxcbiAgICBraW5kOiBraW5kXG4gIH0pO1xufSwgJ0l0ZXJhdG9yJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBzdGVwID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgIHN0ZXAudmFsdWUgPSBraW5kID09PSAna2V5cycgPyBlbnRyeS5rZXkgOiBraW5kID09PSAndmFsdWVzJyA/IGVudHJ5LnZhbHVlIDogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdO1xuICB9IHJldHVybiBzdGVwO1xufSwgdHJ1ZSk7XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNTdGF0ZSA9IGZ1bmN0aW9uIChpbml0KSB7XG4gIHRoaXMuZW50cmllcyA9IFtdO1xuICB0aGlzLnVybCA9IG51bGw7XG5cbiAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc09iamVjdChpbml0KSkgdGhpcy5wYXJzZU9iamVjdChpbml0KTtcbiAgICBlbHNlIHRoaXMucGFyc2VRdWVyeSh0eXBlb2YgaW5pdCA9PSAnc3RyaW5nJyA/IGNoYXJBdChpbml0LCAwKSA9PT0gJz8nID8gc3RyaW5nU2xpY2UoaW5pdCwgMSkgOiBpbml0IDogJHRvU3RyaW5nKGluaXQpKTtcbiAgfVxufTtcblxuVVJMU2VhcmNoUGFyYW1zU3RhdGUucHJvdG90eXBlID0ge1xuICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNUyxcbiAgYmluZFVSTDogZnVuY3Rpb24gKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH0sXG4gIHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2Qob2JqZWN0KTtcbiAgICB2YXIgaXRlcmF0b3IsIG5leHQsIHN0ZXAsIGVudHJ5SXRlcmF0b3IsIGVudHJ5TmV4dCwgZmlyc3QsIHNlY29uZDtcblxuICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihvYmplY3QsIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gICAgICAgIGVudHJ5SXRlcmF0b3IgPSBnZXRJdGVyYXRvcihhbk9iamVjdChzdGVwLnZhbHVlKSk7XG4gICAgICAgIGVudHJ5TmV4dCA9IGVudHJ5SXRlcmF0b3IubmV4dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChmaXJzdCA9IGNhbGwoZW50cnlOZXh0LCBlbnRyeUl0ZXJhdG9yKSkuZG9uZSB8fFxuICAgICAgICAgIChzZWNvbmQgPSBjYWxsKGVudHJ5TmV4dCwgZW50cnlJdGVyYXRvcikpLmRvbmUgfHxcbiAgICAgICAgICAhY2FsbChlbnRyeU5leHQsIGVudHJ5SXRlcmF0b3IpLmRvbmVcbiAgICAgICAgKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDInKTtcbiAgICAgICAgcHVzaCh0aGlzLmVudHJpZXMsIHsga2V5OiAkdG9TdHJpbmcoZmlyc3QudmFsdWUpLCB2YWx1ZTogJHRvU3RyaW5nKHNlY29uZC52YWx1ZSkgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChoYXNPd24ob2JqZWN0LCBrZXkpKSB7XG4gICAgICBwdXNoKHRoaXMuZW50cmllcywgeyBrZXk6IGtleSwgdmFsdWU6ICR0b1N0cmluZyhvYmplY3Rba2V5XSkgfSk7XG4gICAgfVxuICB9LFxuICBwYXJzZVF1ZXJ5OiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3BsaXQocXVlcnksICcmJyk7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGF0dHJpYnV0ZSwgZW50cnk7XG4gICAgICB3aGlsZSAoaW5kZXggPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2luZGV4KytdO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmxlbmd0aCkge1xuICAgICAgICAgIGVudHJ5ID0gc3BsaXQoYXR0cmlidXRlLCAnPScpO1xuICAgICAgICAgIHB1c2godGhpcy5lbnRyaWVzLCB7XG4gICAgICAgICAgICBrZXk6IGRlc2VyaWFsaXplKHNoaWZ0KGVudHJ5KSksXG4gICAgICAgICAgICB2YWx1ZTogZGVzZXJpYWxpemUoam9pbihlbnRyeSwgJz0nKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBlbnRyeSA9IGVudHJpZXNbaW5kZXgrK107XG4gICAgICBwdXNoKHJlc3VsdCwgc2VyaWFsaXplKGVudHJ5LmtleSkgKyAnPScgKyBzZXJpYWxpemUoZW50cnkudmFsdWUpKTtcbiAgICB9IHJldHVybiBqb2luKHJlc3VsdCwgJyYnKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wYXJzZVF1ZXJ5KHRoaXMudXJsLnF1ZXJ5KTtcbiAgfSxcbiAgdXBkYXRlVVJMOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudXJsKSB0aGlzLnVybC51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtc2AgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLXVybHNlYXJjaHBhcmFtc1xudmFyIFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMU2VhcmNoUGFyYW1zKC8qIGluaXQgKi8pIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUpO1xuICB2YXIgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIG5ldyBVUkxTZWFyY2hQYXJhbXNTdGF0ZShpbml0KSk7XG59O1xuXG52YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG5yZWRlZmluZUFsbChVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIHtcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuYXBwZW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWFwcGVuZFxuICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDIpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gICAgcHVzaChzdGF0ZS5lbnRyaWVzLCB7IGtleTogJHRvU3RyaW5nKG5hbWUpLCB2YWx1ZTogJHRvU3RyaW5nKHZhbHVlKSB9KTtcbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZGVsZXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWRlbGV0ZVxuICAnZGVsZXRlJzogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nKG5hbWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgc3BsaWNlKGVudHJpZXMsIGluZGV4LCAxKTtcbiAgICAgIGVsc2UgaW5kZXgrKztcbiAgICB9XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1nZXRcbiAgZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmcobmFtZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSByZXR1cm4gZW50cmllc1tpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXRBbGxgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0YWxsXG4gIGdldEFsbDogZnVuY3Rpb24gZ2V0QWxsKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nKG5hbWUpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGZvciAoOyBpbmRleCA8IGVudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoZW50cmllc1tpbmRleF0ua2V5ID09PSBrZXkpIHB1c2gocmVzdWx0LCBlbnRyaWVzW2luZGV4XS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmhhc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1oYXNcbiAgaGFzOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSAkdG9TdHJpbmcobmFtZSk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXgrK10ua2V5ID09PSBrZXkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnNldGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1zZXRcbiAgc2V0OiBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICB2YXIga2V5ID0gJHRvU3RyaW5nKG5hbWUpO1xuICAgIHZhciB2YWwgPSAkdG9TdHJpbmcodmFsdWUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIGZvciAoOyBpbmRleCA8IGVudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgaWYgKGVudHJ5LmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChmb3VuZCkgc3BsaWNlKGVudHJpZXMsIGluZGV4LS0sIDEpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgZW50cnkudmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZCkgcHVzaChlbnRyaWVzLCB7IGtleToga2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zb3J0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNvcnRcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIGFycmF5U29ydChzdGF0ZS5lbnRyaWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEua2V5ID4gYi5rZXkgPyAxIDogLTE7XG4gICAgfSk7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFjaywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBlbnRyeSA9IGVudHJpZXNbaW5kZXgrK107XG4gICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xuICAgIH1cbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAna2V5cycpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICd2YWx1ZXMnKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAnZW50cmllcycpO1xuICB9XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcbnJlZGVmaW5lKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgSVRFUkFUT1IsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5lbnRyaWVzLCB7IG5hbWU6ICdlbnRyaWVzJyB9KTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXG5yZWRlZmluZShVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5zZXJpYWxpemUoKTtcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuc2V0VG9TdHJpbmdUYWcoVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsIFVSTF9TRUFSQ0hfUEFSQU1TKTtcblxuJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiAhVVNFX05BVElWRV9VUkwgfSwge1xuICBVUkxTZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yXG59KTtcblxuLy8gV3JhcCBgZmV0Y2hgIGFuZCBgUmVxdWVzdGAgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHBvbHlmaWxsZWQgYFVSTFNlYXJjaFBhcmFtc2BcbmlmICghVVNFX05BVElWRV9VUkwgJiYgaXNDYWxsYWJsZShIZWFkZXJzKSkge1xuICB2YXIgaGVhZGVyc0hhcyA9IHVuY3VycnlUaGlzKEhlYWRlcnNQcm90b3R5cGUuaGFzKTtcbiAgdmFyIGhlYWRlcnNTZXQgPSB1bmN1cnJ5VGhpcyhIZWFkZXJzUHJvdG90eXBlLnNldCk7XG5cbiAgdmFyIHdyYXBSZXF1ZXN0T3B0aW9ucyA9IGZ1bmN0aW9uIChpbml0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB7XG4gICAgICB2YXIgYm9keSA9IGluaXQuYm9keTtcbiAgICAgIHZhciBoZWFkZXJzO1xuICAgICAgaWYgKGNsYXNzb2YoYm9keSkgPT09IFVSTF9TRUFSQ0hfUEFSQU1TKSB7XG4gICAgICAgIGhlYWRlcnMgPSBpbml0LmhlYWRlcnMgPyBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpIDogbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKCFoZWFkZXJzSGFzKGhlYWRlcnMsICdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICAgIGhlYWRlcnNTZXQoaGVhZGVycywgJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGUoaW5pdCwge1xuICAgICAgICAgIGJvZHk6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCAkdG9TdHJpbmcoYm9keSkpLFxuICAgICAgICAgIGhlYWRlcnM6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBoZWFkZXJzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IHJldHVybiBpbml0O1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlKG4kRmV0Y2gpKSB7XG4gICAgJCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaChpbnB1dCAvKiAsIGluaXQgKi8pIHtcbiAgICAgICAgcmV0dXJuIG4kRmV0Y2goaW5wdXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gd3JhcFJlcXVlc3RPcHRpb25zKGFyZ3VtZW50c1sxXSkgOiB7fSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNDYWxsYWJsZShOJFJlcXVlc3QpKSB7XG4gICAgdmFyIFJlcXVlc3RDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQgLyogLCBpbml0ICovKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsIFJlcXVlc3RQcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIG5ldyBOJFJlcXVlc3QoaW5wdXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gd3JhcFJlcXVlc3RPcHRpb25zKGFyZ3VtZW50c1sxXSkgOiB7fSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RQcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1ZXN0Q29uc3RydWN0b3I7XG4gICAgUmVxdWVzdENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFJlcXVlc3RQcm90b3R5cGU7XG5cbiAgICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgICAgUmVxdWVzdDogUmVxdWVzdENvbnN0cnVjdG9yXG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsXG4gIGdldFN0YXRlOiBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogaW4gY29yZS1qc0A0LCBtb3ZlIC9tb2R1bGVzLyBkZXBlbmRlbmNpZXMgdG8gcHVibGljIGVudHJpZXMgZm9yIGJldHRlciBvcHRpbWl6YXRpb24gYnkgdG9vbHMgbGlrZSBgcHJlc2V0LWVudmBcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yJyk7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS11cmwnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpLmY7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbicpO1xudmFyIGFycmF5RnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mcm9tJyk7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZS1zaW1wbGUnKTtcbnZhciBjb2RlQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNvZGVBdDtcbnZhciB0b0FTQ0lJID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1wdW55Y29kZS10by1hc2NpaScpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIFVSTFNlYXJjaFBhcmFtc01vZHVsZSA9IHJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsVVJMU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcignVVJMJyk7XG52YXIgVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zTW9kdWxlLlVSTFNlYXJjaFBhcmFtcztcbnZhciBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlID0gVVJMU2VhcmNoUGFyYW1zTW9kdWxlLmdldFN0YXRlO1xuXG52YXIgTmF0aXZlVVJMID0gZ2xvYmFsLlVSTDtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHBhcnNlSW50ID0gZ2xvYmFsLnBhcnNlSW50O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xudmFyIG51bWJlclRvU3RyaW5nID0gdW5jdXJyeVRoaXMoMS4wLnRvU3RyaW5nKTtcbnZhciBwb3AgPSB1bmN1cnJ5VGhpcyhbXS5wb3ApO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgc2hpZnQgPSB1bmN1cnJ5VGhpcyhbXS5zaGlmdCk7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgdG9Mb3dlckNhc2UgPSB1bmN1cnJ5VGhpcygnJy50b0xvd2VyQ2FzZSk7XG52YXIgdW5zaGlmdCA9IHVuY3VycnlUaGlzKFtdLnVuc2hpZnQpO1xuXG52YXIgSU5WQUxJRF9BVVRIT1JJVFkgPSAnSW52YWxpZCBhdXRob3JpdHknO1xudmFyIElOVkFMSURfU0NIRU1FID0gJ0ludmFsaWQgc2NoZW1lJztcbnZhciBJTlZBTElEX0hPU1QgPSAnSW52YWxpZCBob3N0JztcbnZhciBJTlZBTElEX1BPUlQgPSAnSW52YWxpZCBwb3J0JztcblxudmFyIEFMUEhBID0gL1thLXpdL2k7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLW9ic2N1cmUtcmFuZ2UgLS0gc2FmZVxudmFyIEFMUEhBTlVNRVJJQyA9IC9bXFxkKy0uYS16XS9pO1xudmFyIERJR0lUID0gL1xcZC87XG52YXIgSEVYX1NUQVJUID0gL14weC9pO1xudmFyIE9DVCA9IC9eWzAtN10rJC87XG52YXIgREVDID0gL15cXGQrJC87XG52YXIgSEVYID0gL15bXFxkYS1mXSskL2k7XG4vKiBlc2xpbnQtZGlzYWJsZSByZWdleHAvbm8tY29udHJvbC1jaGFyYWN0ZXIgLS0gc2FmZSAqL1xudmFyIEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQgPSAvW1xcMFxcdFxcblxcciAjJS86PD4/QFtcXFxcXFxdXnxdLztcbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UX0VYQ0xVRElOR19QRVJDRU5UID0gL1tcXDBcXHRcXG5cXHIgIy86PD4/QFtcXFxcXFxdXnxdLztcbnZhciBMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFID0gL15bXFx1MDAwMC1cXHUwMDIwXSt8W1xcdTAwMDAtXFx1MDAyMF0rJC9nO1xudmFyIFRBQl9BTkRfTkVXX0xJTkUgPSAvW1xcdFxcblxccl0vZztcbi8qIGVzbGludC1lbmFibGUgcmVnZXhwL25vLWNvbnRyb2wtY2hhcmFjdGVyIC0tIHNhZmUgKi9cbnZhciBFT0Y7XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaXB2NC1udW1iZXItcGFyc2VyXG52YXIgcGFyc2VJUHY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBwYXJ0cyA9IHNwbGl0KGlucHV0LCAnLicpO1xuICB2YXIgcGFydHNMZW5ndGgsIG51bWJlcnMsIGluZGV4LCBwYXJ0LCByYWRpeCwgbnVtYmVyLCBpcHY0O1xuICBpZiAocGFydHMubGVuZ3RoICYmIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdID09ICcnKSB7XG4gICAgcGFydHMubGVuZ3RoLS07XG4gIH1cbiAgcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG4gIGlmIChwYXJ0c0xlbmd0aCA+IDQpIHJldHVybiBpbnB1dDtcbiAgbnVtYmVycyA9IFtdO1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0c0xlbmd0aDsgaW5kZXgrKykge1xuICAgIHBhcnQgPSBwYXJ0c1tpbmRleF07XG4gICAgaWYgKHBhcnQgPT0gJycpIHJldHVybiBpbnB1dDtcbiAgICByYWRpeCA9IDEwO1xuICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDEgJiYgY2hhckF0KHBhcnQsIDApID09ICcwJykge1xuICAgICAgcmFkaXggPSBleGVjKEhFWF9TVEFSVCwgcGFydCkgPyAxNiA6IDg7XG4gICAgICBwYXJ0ID0gc3RyaW5nU2xpY2UocGFydCwgcmFkaXggPT0gOCA/IDEgOiAyKTtcbiAgICB9XG4gICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICBudW1iZXIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWV4ZWMocmFkaXggPT0gMTAgPyBERUMgOiByYWRpeCA9PSA4ID8gT0NUIDogSEVYLCBwYXJ0KSkgcmV0dXJuIGlucHV0O1xuICAgICAgbnVtYmVyID0gcGFyc2VJbnQocGFydCwgcmFkaXgpO1xuICAgIH1cbiAgICBwdXNoKG51bWJlcnMsIG51bWJlcik7XG4gIH1cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFydHNMZW5ndGg7IGluZGV4KyspIHtcbiAgICBudW1iZXIgPSBudW1iZXJzW2luZGV4XTtcbiAgICBpZiAoaW5kZXggPT0gcGFydHNMZW5ndGggLSAxKSB7XG4gICAgICBpZiAobnVtYmVyID49IHBvdygyNTYsIDUgLSBwYXJ0c0xlbmd0aCkpIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyID4gMjU1KSByZXR1cm4gbnVsbDtcbiAgfVxuICBpcHY0ID0gcG9wKG51bWJlcnMpO1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBudW1iZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlwdjQgKz0gbnVtYmVyc1tpbmRleF0gKiBwb3coMjU2LCAzIC0gaW5kZXgpO1xuICB9XG4gIHJldHVybiBpcHY0O1xufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWlwdjYtcGFyc2VyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHMgLS0gVE9ET1xudmFyIHBhcnNlSVB2NiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgYWRkcmVzcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgdmFyIHBpZWNlSW5kZXggPSAwO1xuICB2YXIgY29tcHJlc3MgPSBudWxsO1xuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciB2YWx1ZSwgbGVuZ3RoLCBudW1iZXJzU2VlbiwgaXB2NFBpZWNlLCBudW1iZXIsIHN3YXBzLCBzd2FwO1xuXG4gIHZhciBjaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYXJBdChpbnB1dCwgcG9pbnRlcik7XG4gIH07XG5cbiAgaWYgKGNocigpID09ICc6Jykge1xuICAgIGlmIChjaGFyQXQoaW5wdXQsIDEpICE9ICc6JykgcmV0dXJuO1xuICAgIHBvaW50ZXIgKz0gMjtcbiAgICBwaWVjZUluZGV4Kys7XG4gICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICB9XG4gIHdoaWxlIChjaHIoKSkge1xuICAgIGlmIChwaWVjZUluZGV4ID09IDgpIHJldHVybjtcbiAgICBpZiAoY2hyKCkgPT0gJzonKSB7XG4gICAgICBpZiAoY29tcHJlc3MgIT09IG51bGwpIHJldHVybjtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIHBpZWNlSW5kZXgrKztcbiAgICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IGxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKGxlbmd0aCA8IDQgJiYgZXhlYyhIRVgsIGNocigpKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgcGFyc2VJbnQoY2hyKCksIDE2KTtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIGxlbmd0aCsrO1xuICAgIH1cbiAgICBpZiAoY2hyKCkgPT0gJy4nKSB7XG4gICAgICBpZiAobGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgIHBvaW50ZXIgLT0gbGVuZ3RoO1xuICAgICAgaWYgKHBpZWNlSW5kZXggPiA2KSByZXR1cm47XG4gICAgICBudW1iZXJzU2VlbiA9IDA7XG4gICAgICB3aGlsZSAoY2hyKCkpIHtcbiAgICAgICAgaXB2NFBpZWNlID0gbnVsbDtcbiAgICAgICAgaWYgKG51bWJlcnNTZWVuID4gMCkge1xuICAgICAgICAgIGlmIChjaHIoKSA9PSAnLicgJiYgbnVtYmVyc1NlZW4gPCA0KSBwb2ludGVyKys7XG4gICAgICAgICAgZWxzZSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGVjKERJR0lULCBjaHIoKSkpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKGV4ZWMoRElHSVQsIGNocigpKSkge1xuICAgICAgICAgIG51bWJlciA9IHBhcnNlSW50KGNocigpLCAxMCk7XG4gICAgICAgICAgaWYgKGlwdjRQaWVjZSA9PT0gbnVsbCkgaXB2NFBpZWNlID0gbnVtYmVyO1xuICAgICAgICAgIGVsc2UgaWYgKGlwdjRQaWVjZSA9PSAwKSByZXR1cm47XG4gICAgICAgICAgZWxzZSBpcHY0UGllY2UgPSBpcHY0UGllY2UgKiAxMCArIG51bWJlcjtcbiAgICAgICAgICBpZiAoaXB2NFBpZWNlID4gMjU1KSByZXR1cm47XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3NbcGllY2VJbmRleF0gPSBhZGRyZXNzW3BpZWNlSW5kZXhdICogMjU2ICsgaXB2NFBpZWNlO1xuICAgICAgICBudW1iZXJzU2VlbisrO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPT0gMiB8fCBudW1iZXJzU2VlbiA9PSA0KSBwaWVjZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyc1NlZW4gIT0gNCkgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaHIoKSA9PSAnOicpIHtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIGlmICghY2hyKCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGNocigpKSByZXR1cm47XG4gICAgYWRkcmVzc1twaWVjZUluZGV4KytdID0gdmFsdWU7XG4gIH1cbiAgaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XG4gICAgc3dhcHMgPSBwaWVjZUluZGV4IC0gY29tcHJlc3M7XG4gICAgcGllY2VJbmRleCA9IDc7XG4gICAgd2hpbGUgKHBpZWNlSW5kZXggIT0gMCAmJiBzd2FwcyA+IDApIHtcbiAgICAgIHN3YXAgPSBhZGRyZXNzW3BpZWNlSW5kZXhdO1xuICAgICAgYWRkcmVzc1twaWVjZUluZGV4LS1dID0gYWRkcmVzc1tjb21wcmVzcyArIHN3YXBzIC0gMV07XG4gICAgICBhZGRyZXNzW2NvbXByZXNzICsgLS1zd2Fwc10gPSBzd2FwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwaWVjZUluZGV4ICE9IDgpIHJldHVybjtcbiAgcmV0dXJuIGFkZHJlc3M7XG59O1xuXG52YXIgZmluZExvbmdlc3RaZXJvU2VxdWVuY2UgPSBmdW5jdGlvbiAoaXB2Nikge1xuICB2YXIgbWF4SW5kZXggPSBudWxsO1xuICB2YXIgbWF4TGVuZ3RoID0gMTtcbiAgdmFyIGN1cnJTdGFydCA9IG51bGw7XG4gIHZhciBjdXJyTGVuZ3RoID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICg7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgIGlmIChpcHY2W2luZGV4XSAhPT0gMCkge1xuICAgICAgaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gICAgICB9XG4gICAgICBjdXJyU3RhcnQgPSBudWxsO1xuICAgICAgY3Vyckxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpIGN1cnJTdGFydCA9IGluZGV4O1xuICAgICAgKytjdXJyTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoY3Vyckxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIG1heEluZGV4ID0gY3VyclN0YXJ0O1xuICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufTtcblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNob3N0LXNlcmlhbGl6aW5nXG52YXIgc2VyaWFsaXplSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gIHZhciByZXN1bHQsIGluZGV4LCBjb21wcmVzcywgaWdub3JlMDtcbiAgLy8gaXB2NFxuICBpZiAodHlwZW9mIGhvc3QgPT0gJ251bWJlcicpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA0OyBpbmRleCsrKSB7XG4gICAgICB1bnNoaWZ0KHJlc3VsdCwgaG9zdCAlIDI1Nik7XG4gICAgICBob3N0ID0gZmxvb3IoaG9zdCAvIDI1Nik7XG4gICAgfSByZXR1cm4gam9pbihyZXN1bHQsICcuJyk7XG4gIC8vIGlwdjZcbiAgfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PSAnb2JqZWN0Jykge1xuICAgIHJlc3VsdCA9ICcnO1xuICAgIGNvbXByZXNzID0gZmluZExvbmdlc3RaZXJvU2VxdWVuY2UoaG9zdCk7XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgICAgaWYgKGlnbm9yZTAgJiYgaG9zdFtpbmRleF0gPT09IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKGlnbm9yZTApIGlnbm9yZTAgPSBmYWxzZTtcbiAgICAgIGlmIChjb21wcmVzcyA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGluZGV4ID8gJzonIDogJzo6JztcbiAgICAgICAgaWdub3JlMCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gbnVtYmVyVG9TdHJpbmcoaG9zdFtpbmRleF0sIDE2KTtcbiAgICAgICAgaWYgKGluZGV4IDwgNykgcmVzdWx0ICs9ICc6JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdbJyArIHJlc3VsdCArICddJztcbiAgfSByZXR1cm4gaG9zdDtcbn07XG5cbnZhciBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0ID0ge307XG52YXIgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcgJzogMSwgJ1wiJzogMSwgJzwnOiAxLCAnPic6IDEsICdgJzogMVxufSk7XG52YXIgcGF0aFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCwge1xuICAnIyc6IDEsICc/JzogMSwgJ3snOiAxLCAnfSc6IDFcbn0pO1xudmFyIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgcGF0aFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJy8nOiAxLCAnOic6IDEsICc7JzogMSwgJz0nOiAxLCAnQCc6IDEsICdbJzogMSwgJ1xcXFwnOiAxLCAnXSc6IDEsICdeJzogMSwgJ3wnOiAxXG59KTtcblxudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbiAoY2hyLCBzZXQpIHtcbiAgdmFyIGNvZGUgPSBjb2RlQXQoY2hyLCAwKTtcbiAgcmV0dXJuIGNvZGUgPiAweDIwICYmIGNvZGUgPCAweDdGICYmICFoYXNPd24oc2V0LCBjaHIpID8gY2hyIDogZW5jb2RlVVJJQ29tcG9uZW50KGNocik7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3NwZWNpYWwtc2NoZW1lXG52YXIgc3BlY2lhbFNjaGVtZXMgPSB7XG4gIGZ0cDogMjEsXG4gIGZpbGU6IG51bGwsXG4gIGh0dHA6IDgwLFxuICBodHRwczogNDQzLFxuICB3czogODAsXG4gIHdzczogNDQzXG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3dpbmRvd3MtZHJpdmUtbGV0dGVyXG52YXIgaXNXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nLCBub3JtYWxpemVkKSB7XG4gIHZhciBzZWNvbmQ7XG4gIHJldHVybiBzdHJpbmcubGVuZ3RoID09IDIgJiYgZXhlYyhBTFBIQSwgY2hhckF0KHN0cmluZywgMCkpXG4gICAgJiYgKChzZWNvbmQgPSBjaGFyQXQoc3RyaW5nLCAxKSkgPT0gJzonIHx8ICghbm9ybWFsaXplZCAmJiBzZWNvbmQgPT0gJ3wnKSk7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3N0YXJ0LXdpdGgtYS13aW5kb3dzLWRyaXZlLWxldHRlclxudmFyIHN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciB0aGlyZDtcbiAgcmV0dXJuIHN0cmluZy5sZW5ndGggPiAxICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKHN0cmluZ1NsaWNlKHN0cmluZywgMCwgMikpICYmIChcbiAgICBzdHJpbmcubGVuZ3RoID09IDIgfHxcbiAgICAoKHRoaXJkID0gY2hhckF0KHN0cmluZywgMikpID09PSAnLycgfHwgdGhpcmQgPT09ICdcXFxcJyB8fCB0aGlyZCA9PT0gJz8nIHx8IHRoaXJkID09PSAnIycpXG4gICk7XG59O1xuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3NpbmdsZS1kb3QtcGF0aC1zZWdtZW50XG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4nIHx8IHRvTG93ZXJDYXNlKHNlZ21lbnQpID09PSAnJTJlJztcbn07XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG91YmxlLWRvdC1wYXRoLXNlZ21lbnRcbnZhciBpc0RvdWJsZURvdCA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gIHNlZ21lbnQgPSB0b0xvd2VyQ2FzZShzZWdtZW50KTtcbiAgcmV0dXJuIHNlZ21lbnQgPT09ICcuLicgfHwgc2VnbWVudCA9PT0gJyUyZS4nIHx8IHNlZ21lbnQgPT09ICcuJTJlJyB8fCBzZWdtZW50ID09PSAnJTJlJTJlJztcbn07XG5cbi8vIFN0YXRlczpcbnZhciBTQ0hFTUVfU1RBUlQgPSB7fTtcbnZhciBTQ0hFTUUgPSB7fTtcbnZhciBOT19TQ0hFTUUgPSB7fTtcbnZhciBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWSA9IHt9O1xudmFyIFBBVEhfT1JfQVVUSE9SSVRZID0ge307XG52YXIgUkVMQVRJVkUgPSB7fTtcbnZhciBSRUxBVElWRV9TTEFTSCA9IHt9O1xudmFyIFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVMgPSB7fTtcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUyA9IHt9O1xudmFyIEFVVEhPUklUWSA9IHt9O1xudmFyIEhPU1QgPSB7fTtcbnZhciBIT1NUTkFNRSA9IHt9O1xudmFyIFBPUlQgPSB7fTtcbnZhciBGSUxFID0ge307XG52YXIgRklMRV9TTEFTSCA9IHt9O1xudmFyIEZJTEVfSE9TVCA9IHt9O1xudmFyIFBBVEhfU1RBUlQgPSB7fTtcbnZhciBQQVRIID0ge307XG52YXIgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSCA9IHt9O1xudmFyIFFVRVJZID0ge307XG52YXIgRlJBR01FTlQgPSB7fTtcblxudmFyIFVSTFN0YXRlID0gZnVuY3Rpb24gKHVybCwgaXNCYXNlLCBiYXNlKSB7XG4gIHZhciB1cmxTdHJpbmcgPSAkdG9TdHJpbmcodXJsKTtcbiAgdmFyIGJhc2VTdGF0ZSwgZmFpbHVyZSwgc2VhcmNoUGFyYW1zO1xuICBpZiAoaXNCYXNlKSB7XG4gICAgZmFpbHVyZSA9IHRoaXMucGFyc2UodXJsU3RyaW5nKTtcbiAgICBpZiAoZmFpbHVyZSkgdGhyb3cgVHlwZUVycm9yKGZhaWx1cmUpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSBiYXNlU3RhdGUgPSBuZXcgVVJMU3RhdGUoYmFzZSwgdHJ1ZSk7XG4gICAgZmFpbHVyZSA9IHRoaXMucGFyc2UodXJsU3RyaW5nLCBudWxsLCBiYXNlU3RhdGUpO1xuICAgIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gICAgc2VhcmNoUGFyYW1zID0gZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZShuZXcgVVJMU2VhcmNoUGFyYW1zKCkpO1xuICAgIHNlYXJjaFBhcmFtcy5iaW5kVVJMKHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1zO1xuICB9XG59O1xuXG5VUkxTdGF0ZS5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICdVUkwnLFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXG4gIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQsIHN0YXRlT3ZlcnJpZGUsIGJhc2UpIHtcbiAgICB2YXIgdXJsID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzdGF0ZU92ZXJyaWRlIHx8IFNDSEVNRV9TVEFSVDtcbiAgICB2YXIgcG9pbnRlciA9IDA7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciBzZWVuQXQgPSBmYWxzZTtcbiAgICB2YXIgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICB2YXIgc2VlblBhc3N3b3JkVG9rZW4gPSBmYWxzZTtcbiAgICB2YXIgY29kZVBvaW50cywgY2hyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xuXG4gICAgaW5wdXQgPSAkdG9TdHJpbmcoaW5wdXQpO1xuXG4gICAgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgICB1cmwudXNlcm5hbWUgPSAnJztcbiAgICAgIHVybC5wYXNzd29yZCA9ICcnO1xuICAgICAgdXJsLmhvc3QgPSBudWxsO1xuICAgICAgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgdXJsLnBhdGggPSBbXTtcbiAgICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICAgICB1cmwuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgdXJsLmNhbm5vdEJlQUJhc2VVUkwgPSBmYWxzZTtcbiAgICAgIGlucHV0ID0gcmVwbGFjZShpbnB1dCwgTEVBRElOR19BTkRfVFJBSUxJTkdfQzBfQ09OVFJPTF9PUl9TUEFDRSwgJycpO1xuICAgIH1cblxuICAgIGlucHV0ID0gcmVwbGFjZShpbnB1dCwgVEFCX0FORF9ORVdfTElORSwgJycpO1xuXG4gICAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG5cbiAgICB3aGlsZSAocG9pbnRlciA8PSBjb2RlUG9pbnRzLmxlbmd0aCkge1xuICAgICAgY2hyID0gY29kZVBvaW50c1twb2ludGVyXTtcbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTQ0hFTUVfU1RBUlQ6XG4gICAgICAgICAgaWYgKGNociAmJiBleGVjKEFMUEhBLCBjaHIpKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gdG9Mb3dlckNhc2UoY2hyKTtcbiAgICAgICAgICAgIHN0YXRlID0gU0NIRU1FO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFNDSEVNRTpcbiAgICAgICAgICBpZiAoY2hyICYmIChleGVjKEFMUEhBTlVNRVJJQywgY2hyKSB8fCBjaHIgPT0gJysnIHx8IGNociA9PSAnLScgfHwgY2hyID09ICcuJykpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSB0b0xvd2VyQ2FzZShjaHIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICc6Jykge1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgKFxuICAgICAgICAgICAgICAodXJsLmlzU3BlY2lhbCgpICE9IGhhc093bihzcGVjaWFsU2NoZW1lcywgYnVmZmVyKSkgfHxcbiAgICAgICAgICAgICAgKGJ1ZmZlciA9PSAnZmlsZScgJiYgKHVybC5pbmNsdWRlc0NyZWRlbnRpYWxzKCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKSB8fFxuICAgICAgICAgICAgICAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5ob3N0KVxuICAgICAgICAgICAgKSkgcmV0dXJuO1xuICAgICAgICAgICAgdXJsLnNjaGVtZSA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPT0gdXJsLnBvcnQpIHVybC5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSBGSUxFO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSB1cmwuc2NoZW1lKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybC5pc1NwZWNpYWwoKSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludHNbcG9pbnRlciArIDFdID09ICcvJykge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFBBVEhfT1JfQVVUSE9SSVRZO1xuICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgICAgICAgICAgIHB1c2godXJsLnBhdGgsICcnKTtcbiAgICAgICAgICAgICAgc3RhdGUgPSBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBOT19TQ0hFTUU7XG4gICAgICAgICAgICBwb2ludGVyID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gSU5WQUxJRF9TQ0hFTUU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBOT19TQ0hFTUU6XG4gICAgICAgICAgaWYgKCFiYXNlIHx8IChiYXNlLmNhbm5vdEJlQUJhc2VVUkwgJiYgY2hyICE9ICcjJykpIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgICBpZiAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgdXJsLmNhbm5vdEJlQUJhc2VVUkwgPSB0cnVlO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZSA9IGJhc2Uuc2NoZW1lID09ICdmaWxlJyA/IEZJTEUgOiBSRUxBVElWRTtcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBjYXNlIFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZOlxuICAgICAgICAgIGlmIChjaHIgPT0gJy8nICYmIGNvZGVQb2ludHNbcG9pbnRlciArIDFdID09ICcvJykge1xuICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBSRUxBVElWRTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQQVRIX09SX0FVVEhPUklUWTpcbiAgICAgICAgICBpZiAoY2hyID09ICcvJykge1xuICAgICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVMQVRJVkU6XG4gICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgICAgIGlmIChjaHIgPT0gRU9GKSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJy8nIHx8IChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUkVMQVRJVkVfU0xBU0g7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJz8nKSB7XG4gICAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGFycmF5U2xpY2UoYmFzZS5wYXRoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICB1cmwucGF0aC5sZW5ndGgtLTtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSRUxBVElWRV9TTEFTSDpcbiAgICAgICAgICBpZiAodXJsLmlzU3BlY2lhbCgpICYmIChjaHIgPT0gJy8nIHx8IGNociA9PSAnXFxcXCcpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcvJykge1xuICAgICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTOlxuICAgICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICAgICAgICAgaWYgKGNociAhPSAnLycgfHwgY2hhckF0KGJ1ZmZlciwgcG9pbnRlciArIDEpICE9ICcvJykgY29udGludWU7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XG4gICAgICAgICAgaWYgKGNociAhPSAnLycgJiYgY2hyICE9ICdcXFxcJykge1xuICAgICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQVVUSE9SSVRZOlxuICAgICAgICAgIGlmIChjaHIgPT0gJ0AnKSB7XG4gICAgICAgICAgICBpZiAoc2VlbkF0KSBidWZmZXIgPSAnJTQwJyArIGJ1ZmZlcjtcbiAgICAgICAgICAgIHNlZW5BdCA9IHRydWU7XG4gICAgICAgICAgICBidWZmZXJDb2RlUG9pbnRzID0gYXJyYXlGcm9tKGJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IGJ1ZmZlckNvZGVQb2ludHNbaV07XG4gICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT0gJzonICYmICFzZWVuUGFzc3dvcmRUb2tlbikge1xuICAgICAgICAgICAgICAgIHNlZW5QYXNzd29yZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgZW5jb2RlZENvZGVQb2ludHMgPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludCwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICAgICAgaWYgKHNlZW5QYXNzd29yZFRva2VuKSB1cmwucGFzc3dvcmQgKz0gZW5jb2RlZENvZGVQb2ludHM7XG4gICAgICAgICAgICAgIGVsc2UgdXJsLnVzZXJuYW1lICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChzZWVuQXQgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9BVVRIT1JJVFk7XG4gICAgICAgICAgICBwb2ludGVyIC09IGFycmF5RnJvbShidWZmZXIpLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gSE9TVDtcbiAgICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEhPU1Q6XG4gICAgICAgIGNhc2UgSE9TVE5BTUU6XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgdXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT0gJzonICYmICFzZWVuQnJhY2tldCkge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgICAgICAgIGZhaWx1cmUgPSB1cmwucGFyc2VIb3N0KGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUE9SVDtcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlID09IEhPU1ROQU1FKSByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh1cmwuaXNTcGVjaWFsKCkgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgYnVmZmVyID09ICcnICYmICh1cmwuaW5jbHVkZXNDcmVkZW50aWFscygpIHx8IHVybC5wb3J0ICE9PSBudWxsKSkgcmV0dXJuO1xuICAgICAgICAgICAgZmFpbHVyZSA9IHVybC5wYXJzZUhvc3QoYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hyID09ICdbJykgc2VlbkJyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09ICddJykgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFBPUlQ6XG4gICAgICAgICAgaWYgKGV4ZWMoRElHSVQsIGNocikpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHI7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGNociA9PSBFT0YgfHwgY2hyID09ICcvJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycgfHxcbiAgICAgICAgICAgIChjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSkgfHxcbiAgICAgICAgICAgIHN0YXRlT3ZlcnJpZGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIgIT0gJycpIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnQgPSBwYXJzZUludChidWZmZXIsIDEwKTtcbiAgICAgICAgICAgICAgaWYgKHBvcnQgPiAweEZGRkYpIHJldHVybiBJTlZBTElEX1BPUlQ7XG4gICAgICAgICAgICAgIHVybC5wb3J0ID0gKHVybC5pc1NwZWNpYWwoKSAmJiBwb3J0ID09PSBzcGVjaWFsU2NoZW1lc1t1cmwuc2NoZW1lXSkgPyBudWxsIDogcG9ydDtcbiAgICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1BPUlQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBGSUxFOlxuICAgICAgICAgIHVybC5zY2hlbWUgPSAnZmlsZSc7XG4gICAgICAgICAgaWYgKGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJykgc3RhdGUgPSBGSUxFX1NMQVNIO1xuICAgICAgICAgIGVsc2UgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBpZiAoY2hyID09IEVPRikge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBhcnJheVNsaWNlKGJhc2UucGF0aCk7XG4gICAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFzdGFydHNXaXRoV2luZG93c0RyaXZlTGV0dGVyKGpvaW4oYXJyYXlTbGljZShjb2RlUG9pbnRzLCBwb2ludGVyKSwgJycpKSkge1xuICAgICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgICAgIHVybC5wYXRoID0gYXJyYXlTbGljZShiYXNlLnBhdGgpO1xuICAgICAgICAgICAgICAgIHVybC5zaG9ydGVuUGF0aCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gYnJlYWs7XG5cbiAgICAgICAgY2FzZSBGSUxFX1NMQVNIOlxuICAgICAgICAgIGlmIChjaHIgPT0gJy8nIHx8IGNociA9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYXNlICYmIGJhc2Uuc2NoZW1lID09ICdmaWxlJyAmJiAhc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihqb2luKGFycmF5U2xpY2UoY29kZVBvaW50cywgcG9pbnRlciksICcnKSkpIHtcbiAgICAgICAgICAgIGlmIChpc1dpbmRvd3NEcml2ZUxldHRlcihiYXNlLnBhdGhbMF0sIHRydWUpKSBwdXNoKHVybC5wYXRoLCBiYXNlLnBhdGhbMF0pO1xuICAgICAgICAgICAgZWxzZSB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGNhc2UgRklMRV9IT1NUOlxuICAgICAgICAgIGlmIChjaHIgPT0gRU9GIHx8IGNociA9PSAnLycgfHwgY2hyID09ICdcXFxcJyB8fCBjaHIgPT0gJz8nIHx8IGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGVPdmVycmlkZSAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyID09ICcnKSB7XG4gICAgICAgICAgICAgIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUgPSB1cmwucGFyc2VIb3N0KGJ1ZmZlcik7XG4gICAgICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICAgICAgaWYgKHVybC5ob3N0ID09ICdsb2NhbGhvc3QnKSB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSkgcmV0dXJuO1xuICAgICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgICAgfSBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNocjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBBVEhfU1RBUlQ6XG4gICAgICAgICAgaWYgKHVybC5pc1NwZWNpYWwoKSkge1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgICAgaWYgKGNociAhPSAnLycgJiYgY2hyICE9ICdcXFxcJykgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSAmJiBjaHIgPT0gJz8nKSB7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSAmJiBjaHIgPT0gJyMnKSB7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgIT0gRU9GKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBpZiAoY2hyICE9ICcvJykgY29udGludWU7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIFBBVEg6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2hyID09IEVPRiB8fCBjaHIgPT0gJy8nIHx8XG4gICAgICAgICAgICAoY2hyID09ICdcXFxcJyAmJiB1cmwuaXNTcGVjaWFsKCkpIHx8XG4gICAgICAgICAgICAoIXN0YXRlT3ZlcnJpZGUgJiYgKGNociA9PSAnPycgfHwgY2hyID09ICcjJykpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoaXNEb3VibGVEb3QoYnVmZmVyKSkge1xuICAgICAgICAgICAgICB1cmwuc2hvcnRlblBhdGgoKTtcbiAgICAgICAgICAgICAgaWYgKGNociAhPSAnLycgJiYgIShjaHIgPT0gJ1xcXFwnICYmIHVybC5pc1NwZWNpYWwoKSkpIHtcbiAgICAgICAgICAgICAgICBwdXNoKHVybC5wYXRoLCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xuICAgICAgICAgICAgICBpZiAoY2hyICE9ICcvJyAmJiAhKGNociA9PSAnXFxcXCcgJiYgdXJsLmlzU3BlY2lhbCgpKSkge1xuICAgICAgICAgICAgICAgIHB1c2godXJsLnBhdGgsICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmICF1cmwucGF0aC5sZW5ndGggJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIGlmICh1cmwuaG9zdCkgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBjaGFyQXQoYnVmZmVyLCAwKSArICc6JzsgLy8gbm9ybWFsaXplIHdpbmRvd3MgZHJpdmUgbGV0dGVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHVzaCh1cmwucGF0aCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmIChjaHIgPT0gRU9GIHx8IGNociA9PSAnPycgfHwgY2hyID09ICcjJykpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHVybC5wYXRoLmxlbmd0aCA+IDEgJiYgdXJsLnBhdGhbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2hpZnQodXJsLnBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hyID09ICc/Jykge1xuICAgICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hyID09ICcjJykge1xuICAgICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBwYXRoUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg6XG4gICAgICAgICAgaWYgKGNociA9PSAnPycpIHtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIHVybC5wYXRoWzBdICs9IHBlcmNlbnRFbmNvZGUoY2hyLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgICB9IGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUVVFUlk6XG4gICAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNociA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociAhPSBFT0YpIHtcbiAgICAgICAgICAgIGlmIChjaHIgPT0gXCInXCIgJiYgdXJsLmlzU3BlY2lhbCgpKSB1cmwucXVlcnkgKz0gJyUyNyc7XG4gICAgICAgICAgICBlbHNlIGlmIChjaHIgPT0gJyMnKSB1cmwucXVlcnkgKz0gJyUyMyc7XG4gICAgICAgICAgICBlbHNlIHVybC5xdWVyeSArPSBwZXJjZW50RW5jb2RlKGNociwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgfSBicmVhaztcblxuICAgICAgICBjYXNlIEZSQUdNRU5UOlxuICAgICAgICAgIGlmIChjaHIgIT0gRU9GKSB1cmwuZnJhZ21lbnQgKz0gcGVyY2VudEVuY29kZShjaHIsIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBvaW50ZXIrKztcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaG9zdC1wYXJzaW5nXG4gIHBhcnNlSG9zdDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHJlc3VsdCwgY29kZVBvaW50cywgaW5kZXg7XG4gICAgaWYgKGNoYXJBdChpbnB1dCwgMCkgPT0gJ1snKSB7XG4gICAgICBpZiAoY2hhckF0KGlucHV0LCBpbnB1dC5sZW5ndGggLSAxKSAhPSAnXScpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICByZXN1bHQgPSBwYXJzZUlQdjYoc3RyaW5nU2xpY2UoaW5wdXQsIDEsIC0xKSk7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHRoaXMuaG9zdCA9IHJlc3VsdDtcbiAgICAvLyBvcGFxdWUgaG9zdFxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTcGVjaWFsKCkpIHtcbiAgICAgIGlmIChleGVjKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQsIGlucHV0KSkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBjb2RlUG9pbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2luZGV4XSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3QgPSByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gdG9BU0NJSShpbnB1dCk7XG4gICAgICBpZiAoZXhlYyhGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5ULCBpbnB1dCkpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICByZXN1bHQgPSBwYXJzZUlQdjQoaW5wdXQpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICAgIHRoaXMuaG9zdCA9IHJlc3VsdDtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY2Fubm90LWhhdmUtYS11c2VybmFtZS1wYXNzd29yZC1wb3J0XG4gIGNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5ob3N0IHx8IHRoaXMuY2Fubm90QmVBQmFzZVVSTCB8fCB0aGlzLnNjaGVtZSA9PSAnZmlsZSc7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaW5jbHVkZS1jcmVkZW50aWFsc1xuICBpbmNsdWRlc0NyZWRlbnRpYWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlcm5hbWUgIT0gJycgfHwgdGhpcy5wYXNzd29yZCAhPSAnJztcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpcy1zcGVjaWFsXG4gIGlzU3BlY2lhbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNPd24oc3BlY2lhbFNjaGVtZXMsIHRoaXMuc2NoZW1lKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNzaG9ydGVuLWEtdXJscy1wYXRoXG4gIHNob3J0ZW5QYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgdmFyIHBhdGhTaXplID0gcGF0aC5sZW5ndGg7XG4gICAgaWYgKHBhdGhTaXplICYmICh0aGlzLnNjaGVtZSAhPSAnZmlsZScgfHwgcGF0aFNpemUgIT0gMSB8fCAhaXNXaW5kb3dzRHJpdmVMZXR0ZXIocGF0aFswXSwgdHJ1ZSkpKSB7XG4gICAgICBwYXRoLmxlbmd0aC0tO1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1zZXJpYWxpemVyXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB1cmwgPSB0aGlzO1xuICAgIHZhciBzY2hlbWUgPSB1cmwuc2NoZW1lO1xuICAgIHZhciB1c2VybmFtZSA9IHVybC51c2VybmFtZTtcbiAgICB2YXIgcGFzc3dvcmQgPSB1cmwucGFzc3dvcmQ7XG4gICAgdmFyIGhvc3QgPSB1cmwuaG9zdDtcbiAgICB2YXIgcG9ydCA9IHVybC5wb3J0O1xuICAgIHZhciBwYXRoID0gdXJsLnBhdGg7XG4gICAgdmFyIHF1ZXJ5ID0gdXJsLnF1ZXJ5O1xuICAgIHZhciBmcmFnbWVudCA9IHVybC5mcmFnbWVudDtcbiAgICB2YXIgb3V0cHV0ID0gc2NoZW1lICsgJzonO1xuICAgIGlmIChob3N0ICE9PSBudWxsKSB7XG4gICAgICBvdXRwdXQgKz0gJy8vJztcbiAgICAgIGlmICh1cmwuaW5jbHVkZXNDcmVkZW50aWFscygpKSB7XG4gICAgICAgIG91dHB1dCArPSB1c2VybmFtZSArIChwYXNzd29yZCA/ICc6JyArIHBhc3N3b3JkIDogJycpICsgJ0AnO1xuICAgICAgfVxuICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZUhvc3QoaG9zdCk7XG4gICAgICBpZiAocG9ydCAhPT0gbnVsbCkgb3V0cHV0ICs9ICc6JyArIHBvcnQ7XG4gICAgfSBlbHNlIGlmIChzY2hlbWUgPT0gJ2ZpbGUnKSBvdXRwdXQgKz0gJy8vJztcbiAgICBvdXRwdXQgKz0gdXJsLmNhbm5vdEJlQUJhc2VVUkwgPyBwYXRoWzBdIDogcGF0aC5sZW5ndGggPyAnLycgKyBqb2luKHBhdGgsICcvJykgOiAnJztcbiAgICBpZiAocXVlcnkgIT09IG51bGwpIG91dHB1dCArPSAnPycgKyBxdWVyeTtcbiAgICBpZiAoZnJhZ21lbnQgIT09IG51bGwpIG91dHB1dCArPSAnIycgKyBmcmFnbWVudDtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaHJlZlxuICBzZXRIcmVmOiBmdW5jdGlvbiAoaHJlZikge1xuICAgIHZhciBmYWlsdXJlID0gdGhpcy5wYXJzZShocmVmKTtcbiAgICBpZiAoZmFpbHVyZSkgdGhyb3cgVHlwZUVycm9yKGZhaWx1cmUpO1xuICAgIHRoaXMuc2VhcmNoUGFyYW1zLnVwZGF0ZSgpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gIGdldE9yaWdpbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2hlbWUgPSB0aGlzLnNjaGVtZTtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICBpZiAoc2NoZW1lID09ICdibG9iJykgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgVVJMQ29uc3RydWN0b3Ioc2NoZW1lLnBhdGhbMF0pLm9yaWdpbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKHNjaGVtZSA9PSAnZmlsZScgfHwgIXRoaXMuaXNTcGVjaWFsKCkpIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHNjaGVtZSArICc6Ly8nICsgc2VyaWFsaXplSG9zdCh0aGlzLmhvc3QpICsgKHBvcnQgIT09IG51bGwgPyAnOicgKyBwb3J0IDogJycpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcHJvdG9jb2xcbiAgZ2V0UHJvdG9jb2w6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2hlbWUgKyAnOic7XG4gIH0sXG4gIHNldFByb3RvY29sOiBmdW5jdGlvbiAocHJvdG9jb2wpIHtcbiAgICB0aGlzLnBhcnNlKCR0b1N0cmluZyhwcm90b2NvbCkgKyAnOicsIFNDSEVNRV9TVEFSVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC11c2VybmFtZVxuICBnZXRVc2VybmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXJuYW1lO1xuICB9LFxuICBzZXRVc2VybmFtZTogZnVuY3Rpb24gKHVzZXJuYW1lKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oJHRvU3RyaW5nKHVzZXJuYW1lKSk7XG4gICAgaWYgKHRoaXMuY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KCkpIHJldHVybjtcbiAgICB0aGlzLnVzZXJuYW1lID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVzZXJuYW1lICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXNzd29yZFxuICBnZXRQYXNzd29yZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhc3N3b3JkO1xuICB9LFxuICBzZXRQYXNzd29yZDogZnVuY3Rpb24gKHBhc3N3b3JkKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oJHRvU3RyaW5nKHBhc3N3b3JkKSk7XG4gICAgaWYgKHRoaXMuY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KCkpIHJldHVybjtcbiAgICB0aGlzLnBhc3N3b3JkID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnBhc3N3b3JkICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICB9XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0XG4gIGdldEhvc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnXG4gICAgICA6IHBvcnQgPT09IG51bGwgPyBzZXJpYWxpemVIb3N0KGhvc3QpXG4gICAgICA6IHNlcmlhbGl6ZUhvc3QoaG9zdCkgKyAnOicgKyBwb3J0O1xuICB9LFxuICBzZXRIb3N0OiBmdW5jdGlvbiAoaG9zdCkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhcnNlKGhvc3QsIEhPU1QpO1xuICB9LFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdG5hbWVcbiAgZ2V0SG9zdG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnIDogc2VyaWFsaXplSG9zdChob3N0KTtcbiAgfSxcbiAgc2V0SG9zdG5hbWU6IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhcnNlKGhvc3RuYW1lLCBIT1NUTkFNRSk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wb3J0XG4gIGdldFBvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9ydCA9IHRoaXMucG9ydDtcbiAgICByZXR1cm4gcG9ydCA9PT0gbnVsbCA/ICcnIDogJHRvU3RyaW5nKHBvcnQpO1xuICB9LFxuICBzZXRQb3J0OiBmdW5jdGlvbiAocG9ydCkge1xuICAgIGlmICh0aGlzLmNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCgpKSByZXR1cm47XG4gICAgcG9ydCA9ICR0b1N0cmluZyhwb3J0KTtcbiAgICBpZiAocG9ydCA9PSAnJykgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICBlbHNlIHRoaXMucGFyc2UocG9ydCwgUE9SVCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXRobmFtZVxuICBnZXRQYXRobmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIHJldHVybiB0aGlzLmNhbm5vdEJlQUJhc2VVUkwgPyBwYXRoWzBdIDogcGF0aC5sZW5ndGggPyAnLycgKyBqb2luKHBhdGgsICcvJykgOiAnJztcbiAgfSxcbiAgc2V0UGF0aG5hbWU6IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgIGlmICh0aGlzLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICB0aGlzLnBhdGggPSBbXTtcbiAgICB0aGlzLnBhcnNlKHBhdGhuYW1lLCBQQVRIX1NUQVJUKTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaFxuICBnZXRTZWFyY2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgIHJldHVybiBxdWVyeSA/ICc/JyArIHF1ZXJ5IDogJyc7XG4gIH0sXG4gIHNldFNlYXJjaDogZnVuY3Rpb24gKHNlYXJjaCkge1xuICAgIHNlYXJjaCA9ICR0b1N0cmluZyhzZWFyY2gpO1xuICAgIGlmIChzZWFyY2ggPT0gJycpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJz8nID09IGNoYXJBdChzZWFyY2gsIDApKSBzZWFyY2ggPSBzdHJpbmdTbGljZShzZWFyY2gsIDEpO1xuICAgICAgdGhpcy5xdWVyeSA9ICcnO1xuICAgICAgdGhpcy5wYXJzZShzZWFyY2gsIFFVRVJZKTtcbiAgICB9XG4gICAgdGhpcy5zZWFyY2hQYXJhbXMudXBkYXRlKCk7XG4gIH0sXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1zZWFyY2hwYXJhbXNcbiAgZ2V0U2VhcmNoUGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoUGFyYW1zLmZhY2FkZTtcbiAgfSxcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhhc2hcbiAgZ2V0SGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIGZyYWdtZW50ID8gJyMnICsgZnJhZ21lbnQgOiAnJztcbiAgfSxcbiAgc2V0SGFzaDogZnVuY3Rpb24gKGhhc2gpIHtcbiAgICBoYXNoID0gJHRvU3RyaW5nKGhhc2gpO1xuICAgIGlmIChoYXNoID09ICcnKSB7XG4gICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCcjJyA9PSBjaGFyQXQoaGFzaCwgMCkpIGhhc2ggPSBzdHJpbmdTbGljZShoYXNoLCAxKTtcbiAgICB0aGlzLmZyYWdtZW50ID0gJyc7XG4gICAgdGhpcy5wYXJzZShoYXNoLCBGUkFHTUVOVCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaFBhcmFtcy5zZXJpYWxpemUoKSB8fCBudWxsO1xuICB9XG59O1xuXG4vLyBgVVJMYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtY2xhc3NcbnZhciBVUkxDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTCh1cmwgLyogLCBiYXNlICovKSB7XG4gIHZhciB0aGF0ID0gYW5JbnN0YW5jZSh0aGlzLCBVUkxQcm90b3R5cGUpO1xuICB2YXIgYmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgc3RhdGUgPSBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIG5ldyBVUkxTdGF0ZSh1cmwsIGZhbHNlLCBiYXNlKSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgICB0aGF0LmhyZWYgPSBzdGF0ZS5zZXJpYWxpemUoKTtcbiAgICB0aGF0Lm9yaWdpbiA9IHN0YXRlLmdldE9yaWdpbigpO1xuICAgIHRoYXQucHJvdG9jb2wgPSBzdGF0ZS5nZXRQcm90b2NvbCgpO1xuICAgIHRoYXQudXNlcm5hbWUgPSBzdGF0ZS5nZXRVc2VybmFtZSgpO1xuICAgIHRoYXQucGFzc3dvcmQgPSBzdGF0ZS5nZXRQYXNzd29yZCgpO1xuICAgIHRoYXQuaG9zdCA9IHN0YXRlLmdldEhvc3QoKTtcbiAgICB0aGF0Lmhvc3RuYW1lID0gc3RhdGUuZ2V0SG9zdG5hbWUoKTtcbiAgICB0aGF0LnBvcnQgPSBzdGF0ZS5nZXRQb3J0KCk7XG4gICAgdGhhdC5wYXRobmFtZSA9IHN0YXRlLmdldFBhdGhuYW1lKCk7XG4gICAgdGhhdC5zZWFyY2ggPSBzdGF0ZS5nZXRTZWFyY2goKTtcbiAgICB0aGF0LnNlYXJjaFBhcmFtcyA9IHN0YXRlLmdldFNlYXJjaFBhcmFtcygpO1xuICAgIHRoYXQuaGFzaCA9IHN0YXRlLmdldEhhc2goKTtcbiAgfVxufTtcblxudmFyIFVSTFByb3RvdHlwZSA9IFVSTENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcylbZ2V0dGVyXSgpO1xuICAgIH0sXG4gICAgc2V0OiBzZXR0ZXIgJiYgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKVtzZXR0ZXJdKHZhbHVlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG59O1xuXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgZGVmaW5lUHJvcGVydGllcyhVUkxQcm90b3R5cGUsIHtcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ocmVmYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ocmVmXG4gICAgaHJlZjogYWNjZXNzb3JEZXNjcmlwdG9yKCdzZXJpYWxpemUnLCAnc2V0SHJlZicpLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLm9yaWdpbmAgZ2V0dGVyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLW9yaWdpblxuICAgIG9yaWdpbjogYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRPcmlnaW4nKSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wcm90b2NvbGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcHJvdG9jb2xcbiAgICBwcm90b2NvbDogYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRQcm90b2NvbCcsICdzZXRQcm90b2NvbCcpLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnVzZXJuYW1lYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC11c2VybmFtZVxuICAgIHVzZXJuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFVzZXJuYW1lJywgJ3NldFVzZXJuYW1lJyksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucGFzc3dvcmRgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhc3N3b3JkXG4gICAgcGFzc3dvcmQ6IGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0UGFzc3dvcmQnLCAnc2V0UGFzc3dvcmQnKSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ob3N0YCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ob3N0XG4gICAgaG9zdDogYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRIb3N0JywgJ3NldEhvc3QnKSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ob3N0bmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdG5hbWVcbiAgICBob3N0bmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRIb3N0bmFtZScsICdzZXRIb3N0bmFtZScpLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnBvcnRgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBvcnRcbiAgICBwb3J0OiBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFBvcnQnLCAnc2V0UG9ydCcpLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnBhdGhuYW1lYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wYXRobmFtZVxuICAgIHBhdGhuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoJ2dldFBhdGhuYW1lJywgJ3NldFBhdGhuYW1lJyksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuc2VhcmNoYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1zZWFyY2hcbiAgICBzZWFyY2g6IGFjY2Vzc29yRGVzY3JpcHRvcignZ2V0U2VhcmNoJywgJ3NldFNlYXJjaCcpLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnNlYXJjaFBhcmFtc2AgZ2V0dGVyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaHBhcmFtc1xuICAgIHNlYXJjaFBhcmFtczogYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRTZWFyY2hQYXJhbXMnKSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5oYXNoYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1oYXNoXG4gICAgaGFzaDogYWNjZXNzb3JEZXNjcmlwdG9yKCdnZXRIYXNoJywgJ3NldEhhc2gnKVxuICB9KTtcbn1cblxuLy8gYFVSTC5wcm90b3R5cGUudG9KU09OYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cbnJlZGVmaW5lKFVSTFByb3RvdHlwZSwgJ3RvSlNPTicsIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykuc2VyaWFsaXplKCk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8vIGBVUkwucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jVVJMLXN0cmluZ2lmaWNhdGlvbi1iZWhhdmlvclxucmVkZWZpbmUoVVJMUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykuc2VyaWFsaXplKCk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbmlmIChOYXRpdmVVUkwpIHtcbiAgdmFyIG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5jcmVhdGVPYmplY3RVUkw7XG4gIHZhciBuYXRpdmVSZXZva2VPYmplY3RVUkwgPSBOYXRpdmVVUkwucmV2b2tlT2JqZWN0VVJMO1xuICAvLyBgVVJMLmNyZWF0ZU9iamVjdFVSTGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvY3JlYXRlT2JqZWN0VVJMXG4gIGlmIChuYXRpdmVDcmVhdGVPYmplY3RVUkwpIHJlZGVmaW5lKFVSTENvbnN0cnVjdG9yLCAnY3JlYXRlT2JqZWN0VVJMJywgYmluZChuYXRpdmVDcmVhdGVPYmplY3RVUkwsIE5hdGl2ZVVSTCkpO1xuICAvLyBgVVJMLnJldm9rZU9iamVjdFVSTGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvcmV2b2tlT2JqZWN0VVJMXG4gIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpIHJlZGVmaW5lKFVSTENvbnN0cnVjdG9yLCAncmV2b2tlT2JqZWN0VVJMJywgYmluZChuYXRpdmVSZXZva2VPYmplY3RVUkwsIE5hdGl2ZVVSTCkpO1xufVxuXG5zZXRUb1N0cmluZ1RhZyhVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xuXG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgVVJMOiBVUkxDb25zdHJ1Y3RvclxufSk7XG4iLCJ2YXIgb2JqZWN0RXh0ZW5kID0gZXh0ZW5kO1xuXG4vKlxuICB2YXIgb2JqID0ge2E6IDMsIGI6IDV9O1xuICBleHRlbmQob2JqLCB7YTogNCwgYzogOH0pOyAvLyB7YTogNCwgYjogNSwgYzogOH1cbiAgb2JqOyAvLyB7YTogNCwgYjogNSwgYzogOH1cblxuICB2YXIgb2JqID0ge2E6IDMsIGI6IDV9O1xuICBleHRlbmQoe30sIG9iaiwge2E6IDQsIGM6IDh9KTsgLy8ge2E6IDQsIGI6IDUsIGM6IDh9XG4gIG9iajsgLy8ge2E6IDMsIGI6IDV9XG5cbiAgdmFyIGFyciA9IFsxLCAyLCAzXTtcbiAgdmFyIG9iaiA9IHthOiAzLCBiOiA1fTtcbiAgZXh0ZW5kKG9iaiwge2M6IGFycn0pOyAvLyB7YTogMywgYjogNSwgYzogWzEsIDIsIDNdfVxuICBhcnIucHVzaCg0KTtcbiAgb2JqOyAvLyB7YTogMywgYjogNSwgYzogWzEsIDIsIDMsIDRdfVxuXG4gIHZhciBhcnIgPSBbMSwgMiwgM107XG4gIHZhciBvYmogPSB7YTogMywgYjogNX07XG4gIGV4dGVuZCh0cnVlLCBvYmosIHtjOiBhcnJ9KTsgLy8ge2E6IDMsIGI6IDUsIGM6IFsxLCAyLCAzXX1cbiAgYXJyLnB1c2goNCk7XG4gIG9iajsgLy8ge2E6IDMsIGI6IDUsIGM6IFsxLCAyLCAzXX1cblxuICBleHRlbmQoe2E6IDQsIGI6IDV9KTsgLy8ge2E6IDQsIGI6IDV9XG4gIGV4dGVuZCh7YTogNCwgYjogNX0sIDMpOyB7YTogNCwgYjogNX1cbiAgZXh0ZW5kKHthOiA0LCBiOiA1fSwgdHJ1ZSk7IHthOiA0LCBiOiA1fVxuICBleHRlbmQoJ2hlbGxvJywge2E6IDQsIGI6IDV9KTsgLy8gdGhyb3dzXG4gIGV4dGVuZCgzLCB7YTogNCwgYjogNX0pOyAvLyB0aHJvd3NcbiovXG5cbmZ1bmN0aW9uIGV4dGVuZCgvKiBbZGVlcF0sIG9iajEsIG9iajIsIFtvYmpuXSAqLykge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgdmFyIGRlZXAgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09ICdib29sZWFuJykge1xuICAgIGRlZXAgPSBhcmdzLnNoaWZ0KCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IGFyZ3NbMF07XG4gIGlmIChpc1VuZXh0ZW5kYWJsZShyZXN1bHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHRlbmRlZSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHZhciBleHRlbmRlcnMgPSBhcmdzLnNsaWNlKDEpO1xuICB2YXIgbGVuID0gZXh0ZW5kZXJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBleHRlbmRlciA9IGV4dGVuZGVyc1tpXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0ZW5kZXIpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXh0ZW5kZXIsIGtleSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXh0ZW5kZXJba2V5XTtcbiAgICAgICAgaWYgKGRlZXAgJiYgaXNDbG9uZWFibGUodmFsdWUpKSB7XG4gICAgICAgICAgdmFyIGJhc2UgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge307XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBleHRlbmQoXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSAmJiAhaXNVbmV4dGVuZGFibGUocmVzdWx0W2tleV0pXG4gICAgICAgICAgICAgID8gcmVzdWx0W2tleV1cbiAgICAgICAgICAgICAgOiBiYXNlLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNDbG9uZWFibGUob2JqKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHwge30udG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc1VuZXh0ZW5kYWJsZSh2YWwpIHtcbiAgcmV0dXJuICF2YWwgfHwgKHR5cGVvZiB2YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCAhPSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IHtvYmplY3RFeHRlbmQgYXMgZGVmYXVsdH07XG4iLCJpbXBvcnQgJGV3Qkt5JGp1c3RleHRlbmQgZnJvbSBcImp1c3QtZXh0ZW5kXCI7XG5cbmZ1bmN0aW9uICRwYXJjZWwkaW50ZXJvcERlZmF1bHQoYSkge1xuICByZXR1cm4gYSAmJiBhLl9fZXNNb2R1bGUgPyBhLmRlZmF1bHQgOiBhO1xufVxuXG5jbGFzcyAkNDA0MGFjZmQ4NTg0MzM4ZCRleHBvcnQkMmUyYmNkODczOWFlMDM5IHtcbiAgICAvLyBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGdpdmVuIGV2ZW50XG4gICAgb24oZXZlbnQsIGZuKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENyZWF0ZSBuYW1lc3BhY2UgZm9yIHRoaXMgZXZlbnRcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3NbZXZlbnRdKSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gW107XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSBmb3IgKGxldCBjYWxsYmFjayBvZiBjYWxsYmFja3MpY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIC8vIHRyaWdnZXIgYSBjb3JyZXNwb25kaW5nIERPTSBldmVudFxuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudCh0aGlzLm1ha2VFdmVudChcImRyb3B6b25lOlwiICsgZXZlbnQsIHtcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWFrZUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBwYXJhbXMpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElFIDExIHN1cHBvcnRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudFxuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZvciBnaXZlbiBldmVudC4gSWYgZm4gaXMgbm90IHByb3ZpZGVkLCBhbGwgZXZlbnRcbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoYXQgZXZlbnQgd2lsbCBiZSByZW1vdmVkLiBJZiBuZWl0aGVyIGlzIHByb3ZpZGVkLCBhbGxcbiAgICAvLyBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgIG9mZihldmVudCwgZm4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cblxuXG52YXIgJGZkNjAzMWY4OGRjZTJlMzIkZXhwb3J0cyA9IHt9O1xuJGZkNjAzMWY4OGRjZTJlMzIkZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiZHotcHJldmlldyBkei1maWxlLXByZXZpZXdcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotaW1hZ2VcXFwiPjxpbWcgZGF0YS1kei10aHVtYm5haWw9XFxcIlxcXCI+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1kZXRhaWxzXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZHotc2l6ZVxcXCI+PHNwYW4gZGF0YS1kei1zaXplPVxcXCJcXFwiPjwvc3Bhbj48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZHotZmlsZW5hbWVcXFwiPjxzcGFuIGRhdGEtZHotbmFtZT1cXFwiXFxcIj48L3NwYW4+PC9kaXY+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImR6LXByb2dyZXNzXFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImR6LXVwbG9hZFxcXCIgZGF0YS1kei11cGxvYWRwcm9ncmVzcz1cXFwiXFxcIj48L3NwYW4+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImR6LWVycm9yLW1lc3NhZ2VcXFwiPjxzcGFuIGRhdGEtZHotZXJyb3JtZXNzYWdlPVxcXCJcXFwiPjwvc3Bhbj48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImR6LXN1Y2Nlc3MtbWFya1xcXCI+XFxuICAgIDxzdmcgd2lkdGg9XFxcIjU0XFxcIiBoZWlnaHQ9XFxcIjU0XFxcIiB2aWV3Qm94PVxcXCIwIDAgNTQgNTRcXFwiIGZpbGw9XFxcIndoaXRlXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcbiAgICAgIDxwYXRoIGQ9XFxcIk0xMC4yMDcxIDI5Ljc5MjlMMTQuMjkyOSAyNS43MDcxQzE0LjY4MzQgMjUuMzE2NiAxNS4zMTY2IDI1LjMxNjYgMTUuNzA3MSAyNS43MDcxTDIxLjI5MjkgMzEuMjkyOUMyMS42ODM0IDMxLjY4MzQgMjIuMzE2NiAzMS42ODM0IDIyLjcwNzEgMzEuMjkyOUwzOC4yOTI5IDE1LjcwNzFDMzguNjgzNCAxNS4zMTY2IDM5LjMxNjYgMTUuMzE2NiAzOS43MDcxIDE1LjcwNzFMNDMuNzkyOSAxOS43OTI5QzQ0LjE4MzQgMjAuMTgzNCA0NC4xODM0IDIwLjgxNjYgNDMuNzkyOSAyMS4yMDcxTDIyLjcwNzEgNDIuMjkyOUMyMi4zMTY2IDQyLjY4MzQgMjEuNjgzNCA0Mi42ODM0IDIxLjI5MjkgNDIuMjkyOUwxMC4yMDcxIDMxLjIwNzFDOS44MTY1OCAzMC44MTY2IDkuODE2NTggMzAuMTgzNCAxMC4yMDcxIDI5Ljc5MjlaXFxcIj48L3BhdGg+XFxuICAgIDwvc3ZnPlxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJkei1lcnJvci1tYXJrXFxcIj5cXG4gICAgPHN2ZyB3aWR0aD1cXFwiNTRcXFwiIGhlaWdodD1cXFwiNTRcXFwiIHZpZXdCb3g9XFxcIjAgMCA1NCA1NFxcXCIgZmlsbD1cXFwid2hpdGVcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuICAgICAgPHBhdGggZD1cXFwiTTI2LjI5MjkgMjAuMjkyOUwxOS4yMDcxIDEzLjIwNzFDMTguODE2NiAxMi44MTY2IDE4LjE4MzQgMTIuODE2NiAxNy43OTI5IDEzLjIwNzFMMTMuMjA3MSAxNy43OTI5QzEyLjgxNjYgMTguMTgzNCAxMi44MTY2IDE4LjgxNjYgMTMuMjA3MSAxOS4yMDcxTDIwLjI5MjkgMjYuMjkyOUMyMC42ODM0IDI2LjY4MzQgMjAuNjgzNCAyNy4zMTY2IDIwLjI5MjkgMjcuNzA3MUwxMy4yMDcxIDM0Ljc5MjlDMTIuODE2NiAzNS4xODM0IDEyLjgxNjYgMzUuODE2NiAxMy4yMDcxIDM2LjIwNzFMMTcuNzkyOSA0MC43OTI5QzE4LjE4MzQgNDEuMTgzNCAxOC44MTY2IDQxLjE4MzQgMTkuMjA3MSA0MC43OTI5TDI2LjI5MjkgMzMuNzA3MUMyNi42ODM0IDMzLjMxNjYgMjcuMzE2NiAzMy4zMTY2IDI3LjcwNzEgMzMuNzA3MUwzNC43OTI5IDQwLjc5MjlDMzUuMTgzNCA0MS4xODM0IDM1LjgxNjYgNDEuMTgzNCAzNi4yMDcxIDQwLjc5MjlMNDAuNzkyOSAzNi4yMDcxQzQxLjE4MzQgMzUuODE2NiA0MS4xODM0IDM1LjE4MzQgNDAuNzkyOSAzNC43OTI5TDMzLjcwNzEgMjcuNzA3MUMzMy4zMTY2IDI3LjMxNjYgMzMuMzE2NiAyNi42ODM0IDMzLjcwNzEgMjYuMjkyOUw0MC43OTI5IDE5LjIwNzFDNDEuMTgzNCAxOC44MTY2IDQxLjE4MzQgMTguMTgzNCA0MC43OTI5IDE3Ljc5MjlMMzYuMjA3MSAxMy4yMDcxQzM1LjgxNjYgMTIuODE2NiAzNS4xODM0IDEyLjgxNjYgMzQuNzkyOSAxMy4yMDcxTDI3LjcwNzEgMjAuMjkyOUMyNy4zMTY2IDIwLjY4MzQgMjYuNjgzNCAyMC42ODM0IDI2LjI5MjkgMjAuMjkyOVpcXFwiPjwvcGF0aD5cXG4gICAgPC9zdmc+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcblxuXG5sZXQgJDRjYTM2NzE4Mjc3NmY4MGIkdmFyJGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8qKlxuICAgKiBIYXMgdG8gYmUgc3BlY2lmaWVkIG9uIGVsZW1lbnRzIG90aGVyIHRoYW4gZm9ybSAob3Igd2hlbiB0aGUgZm9ybSBkb2Vzbid0XG4gICAqIGhhdmUgYW4gYGFjdGlvbmAgYXR0cmlidXRlKS5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYGZpbGVzYCBhbmRcbiAgICogYGRhdGFCbG9ja3NgICBhbmQgbXVzdCByZXR1cm4gdGhlIHVybCBhcyBzdHJpbmcuXG4gICAqLyB1cmw6IG51bGwsXG4gICAgLyoqXG4gICAqIENhbiBiZSBjaGFuZ2VkIHRvIGBcInB1dFwiYCBpZiBuZWNlc3NhcnkuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgZnVuY3Rpb25cbiAgICogdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBmaWxlc2AgYW5kIG11c3QgcmV0dXJuIHRoZSBtZXRob2QgKHNpbmNlIGB2My4xMi4wYCkuXG4gICAqLyBtZXRob2Q6IFwicG9zdFwiLFxuICAgIC8qKlxuICAgKiBXaWxsIGJlIHNldCBvbiB0aGUgWEhSZXF1ZXN0LlxuICAgKi8gd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAvKipcbiAgICogVGhlIHRpbWVvdXQgZm9yIHRoZSBYSFIgcmVxdWVzdHMgaW4gbWlsbGlzZWNvbmRzIChzaW5jZSBgdjQuNC4wYCkuXG4gICAqIElmIHNldCB0byBudWxsIG9yIDAsIG5vIHRpbWVvdXQgaXMgZ29pbmcgdG8gYmUgc2V0LlxuICAgKi8gdGltZW91dDogbnVsbCxcbiAgICAvKipcbiAgICogSG93IG1hbnkgZmlsZSB1cGxvYWRzIHRvIHByb2Nlc3MgaW4gcGFyYWxsZWwgKFNlZSB0aGVcbiAgICogRW5xdWV1aW5nIGZpbGUgdXBsb2FkcyBkb2N1bWVudGF0aW9uIHNlY3Rpb24gZm9yIG1vcmUgaW5mbylcbiAgICovIHBhcmFsbGVsVXBsb2FkczogMixcbiAgICAvKipcbiAgICogV2hldGhlciB0byBzZW5kIG11bHRpcGxlIGZpbGVzIGluIG9uZSByZXF1ZXN0LiBJZlxuICAgKiB0aGlzIGl0IHNldCB0byB0cnVlLCB0aGVuIHRoZSBmYWxsYmFjayBmaWxlIGlucHV0IGVsZW1lbnQgd2lsbFxuICAgKiBoYXZlIHRoZSBgbXVsdGlwbGVgIGF0dHJpYnV0ZSBhcyB3ZWxsLiBUaGlzIG9wdGlvbiB3aWxsXG4gICAqIGFsc28gdHJpZ2dlciBhZGRpdGlvbmFsIGV2ZW50cyAobGlrZSBgcHJvY2Vzc2luZ211bHRpcGxlYCkuIFNlZSB0aGUgZXZlbnRzXG4gICAqIGRvY3VtZW50YXRpb24gc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovIHVwbG9hZE11bHRpcGxlOiBmYWxzZSxcbiAgICAvKipcbiAgICogV2hldGhlciB5b3Ugd2FudCBmaWxlcyB0byBiZSB1cGxvYWRlZCBpbiBjaHVua3MgdG8geW91ciBzZXJ2ZXIuIFRoaXMgY2FuJ3QgYmVcbiAgICogdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGB1cGxvYWRNdWx0aXBsZWAuXG4gICAqXG4gICAqIFNlZSBbY2h1bmtzVXBsb2FkZWRdKCNjb25maWctY2h1bmtzVXBsb2FkZWQpIGZvciB0aGUgY2FsbGJhY2sgdG8gZmluYWxpc2UgYW4gdXBsb2FkLlxuICAgKi8gY2h1bmtpbmc6IGZhbHNlLFxuICAgIC8qKlxuICAgKiBJZiBgY2h1bmtpbmdgIGlzIGVuYWJsZWQsIHRoaXMgZGVmaW5lcyB3aGV0aGVyICoqZXZlcnkqKiBmaWxlIHNob3VsZCBiZSBjaHVua2VkLFxuICAgKiBldmVuIGlmIHRoZSBmaWxlIHNpemUgaXMgYmVsb3cgY2h1bmtTaXplLiBUaGlzIG1lYW5zLCB0aGF0IHRoZSBhZGRpdGlvbmFsIGNodW5rXG4gICAqIGZvcm0gZGF0YSB3aWxsIGJlIHN1Ym1pdHRlZCBhbmQgdGhlIGBjaHVua3NVcGxvYWRlZGAgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkLlxuICAgKi8gZm9yY2VDaHVua2luZzogZmFsc2UsXG4gICAgLyoqXG4gICAqIElmIGBjaHVua2luZ2AgaXMgYHRydWVgLCB0aGVuIHRoaXMgZGVmaW5lcyB0aGUgY2h1bmsgc2l6ZSBpbiBieXRlcy5cbiAgICovIGNodW5rU2l6ZTogMjA5NzE1MixcbiAgICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5kaXZpZHVhbCBjaHVua3Mgb2YgYSBmaWxlIGFyZSBiZWluZyB1cGxvYWRlZCBzaW11bHRhbmVvdXNseS5cbiAgICovIHBhcmFsbGVsQ2h1bmtVcGxvYWRzOiBmYWxzZSxcbiAgICAvKipcbiAgICogV2hldGhlciBhIGNodW5rIHNob3VsZCBiZSByZXRyaWVkIGlmIGl0IGZhaWxzLlxuICAgKi8gcmV0cnlDaHVua3M6IGZhbHNlLFxuICAgIC8qKlxuICAgKiBJZiBgcmV0cnlDaHVua3NgIGlzIHRydWUsIGhvdyBtYW55IHRpbWVzIHNob3VsZCBpdCBiZSByZXRyaWVkLlxuICAgKi8gcmV0cnlDaHVua3NMaW1pdDogMyxcbiAgICAvKipcbiAgICogVGhlIG1heGltdW0gZmlsZXNpemUgKGluIE1pQikgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHVwbG9hZGVkLlxuICAgKi8gbWF4RmlsZXNpemU6IDI1NixcbiAgICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZpbGUgcGFyYW0gdGhhdCBnZXRzIHRyYW5zZmVycmVkLlxuICAgKiAqKk5PVEUqKjogSWYgeW91IGhhdmUgdGhlIG9wdGlvbiAgYHVwbG9hZE11bHRpcGxlYCBzZXQgdG8gYHRydWVgLCB0aGVuXG4gICAqIERyb3B6b25lIHdpbGwgYXBwZW5kIGBbXWAgdG8gdGhlIG5hbWUuXG4gICAqLyBwYXJhbU5hbWU6IFwiZmlsZVwiLFxuICAgIC8qKlxuICAgKiBXaGV0aGVyIHRodW1ibmFpbHMgZm9yIGltYWdlcyBzaG91bGQgYmUgZ2VuZXJhdGVkXG4gICAqLyBjcmVhdGVJbWFnZVRodW1ibmFpbHM6IHRydWUsXG4gICAgLyoqXG4gICAqIEluIE1CLiBXaGVuIHRoZSBmaWxlbmFtZSBleGNlZWRzIHRoaXMgbGltaXQsIHRoZSB0aHVtYm5haWwgd2lsbCBub3QgYmUgZ2VuZXJhdGVkLlxuICAgKi8gbWF4VGh1bWJuYWlsRmlsZXNpemU6IDEwLFxuICAgIC8qKlxuICAgKiBJZiBgbnVsbGAsIHRoZSByYXRpbyBvZiB0aGUgaW1hZ2Ugd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBpdC5cbiAgICovIHRodW1ibmFpbFdpZHRoOiAxMjAsXG4gICAgLyoqXG4gICAqIFRoZSBzYW1lIGFzIGB0aHVtYm5haWxXaWR0aGAuIElmIGJvdGggYXJlIG51bGwsIGltYWdlcyB3aWxsIG5vdCBiZSByZXNpemVkLlxuICAgKi8gdGh1bWJuYWlsSGVpZ2h0OiAxMjAsXG4gICAgLyoqXG4gICAqIEhvdyB0aGUgaW1hZ2VzIHNob3VsZCBiZSBzY2FsZWQgZG93biBpbiBjYXNlIGJvdGgsIGB0aHVtYm5haWxXaWR0aGAgYW5kIGB0aHVtYm5haWxIZWlnaHRgIGFyZSBwcm92aWRlZC5cbiAgICogQ2FuIGJlIGVpdGhlciBgY29udGFpbmAgb3IgYGNyb3BgLlxuICAgKi8gdGh1bWJuYWlsTWV0aG9kOiBcImNyb3BcIixcbiAgICAvKipcbiAgICogSWYgc2V0LCBpbWFnZXMgd2lsbCBiZSByZXNpemVkIHRvIHRoZXNlIGRpbWVuc2lvbnMgYmVmb3JlIGJlaW5nICoqdXBsb2FkZWQqKi5cbiAgICogSWYgb25seSBvbmUsIGByZXNpemVXaWR0aGAgKipvcioqIGByZXNpemVIZWlnaHRgIGlzIHByb3ZpZGVkLCB0aGUgb3JpZ2luYWwgYXNwZWN0XG4gICAqIHJhdGlvIG9mIHRoZSBmaWxlIHdpbGwgYmUgcHJlc2VydmVkLlxuICAgKlxuICAgKiBUaGUgYG9wdGlvbnMudHJhbnNmb3JtRmlsZWAgZnVuY3Rpb24gdXNlcyB0aGVzZSBvcHRpb25zLCBzbyBpZiB0aGUgYHRyYW5zZm9ybUZpbGVgIGZ1bmN0aW9uXG4gICAqIGlzIG92ZXJyaWRkZW4sIHRoZXNlIG9wdGlvbnMgZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAqLyByZXNpemVXaWR0aDogbnVsbCxcbiAgICAvKipcbiAgICogU2VlIGByZXNpemVXaWR0aGAuXG4gICAqLyByZXNpemVIZWlnaHQ6IG51bGwsXG4gICAgLyoqXG4gICAqIFRoZSBtaW1lIHR5cGUgb2YgdGhlIHJlc2l6ZWQgaW1hZ2UgKGJlZm9yZSBpdCBnZXRzIHVwbG9hZGVkIHRvIHRoZSBzZXJ2ZXIpLlxuICAgKiBJZiBgbnVsbGAgdGhlIG9yaWdpbmFsIG1pbWUgdHlwZSB3aWxsIGJlIHVzZWQuIFRvIGZvcmNlIGpwZWcsIGZvciBleGFtcGxlLCB1c2UgYGltYWdlL2pwZWdgLlxuICAgKiBTZWUgYHJlc2l6ZVdpZHRoYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovIHJlc2l6ZU1pbWVUeXBlOiBudWxsLFxuICAgIC8qKlxuICAgKiBUaGUgcXVhbGl0eSBvZiB0aGUgcmVzaXplZCBpbWFnZXMuIFNlZSBgcmVzaXplV2lkdGhgLlxuICAgKi8gcmVzaXplUXVhbGl0eTogMC44LFxuICAgIC8qKlxuICAgKiBIb3cgdGhlIGltYWdlcyBzaG91bGQgYmUgc2NhbGVkIGRvd24gaW4gY2FzZSBib3RoLCBgcmVzaXplV2lkdGhgIGFuZCBgcmVzaXplSGVpZ2h0YCBhcmUgcHJvdmlkZWQuXG4gICAqIENhbiBiZSBlaXRoZXIgYGNvbnRhaW5gIG9yIGBjcm9wYC5cbiAgICovIHJlc2l6ZU1ldGhvZDogXCJjb250YWluXCIsXG4gICAgLyoqXG4gICAqIFRoZSBiYXNlIHRoYXQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlICoqZGlzcGxheWVkKiogZmlsZXNpemUuIFlvdSBjYW5cbiAgICogY2hhbmdlIHRoaXMgdG8gMTAyNCBpZiB5b3Ugd291bGQgcmF0aGVyIGRpc3BsYXkga2liaWJ5dGVzLCBtZWJpYnl0ZXMsXG4gICAqIGV0Yy4uLiAxMDI0IGlzIHRlY2huaWNhbGx5IGluY29ycmVjdCwgYmVjYXVzZSBgMTAyNCBieXRlc2AgYXJlIGAxIGtpYmlieXRlYFxuICAgKiBub3QgYDEga2lsb2J5dGVgLiBZb3UgY2FuIGNoYW5nZSB0aGlzIHRvIGAxMDI0YCBpZiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgKiB2YWxpZGl0eS5cbiAgICovIGZpbGVzaXplQmFzZTogMTAwMCxcbiAgICAvKipcbiAgICogSWYgbm90IGBudWxsYCBkZWZpbmVzIGhvdyBtYW55IGZpbGVzIHRoaXMgRHJvcHpvbmUgaGFuZGxlcy4gSWYgaXQgZXhjZWVkcyxcbiAgICogdGhlIGV2ZW50IGBtYXhmaWxlc2V4Y2VlZGVkYCB3aWxsIGJlIGNhbGxlZC4gVGhlIGRyb3B6b25lIGVsZW1lbnQgZ2V0cyB0aGVcbiAgICogY2xhc3MgYGR6LW1heC1maWxlcy1yZWFjaGVkYCBhY2NvcmRpbmdseSBzbyB5b3UgY2FuIHByb3ZpZGUgdmlzdWFsXG4gICAqIGZlZWRiYWNrLlxuICAgKi8gbWF4RmlsZXM6IG51bGwsXG4gICAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG9iamVjdCB0byBzZW5kIGFkZGl0aW9uYWwgaGVhZGVycyB0byB0aGUgc2VydmVyLiBFZzpcbiAgICogYHsgXCJNeS1Bd2Vzb21lLUhlYWRlclwiOiBcImhlYWRlciB2YWx1ZVwiIH1gXG4gICAqLyBoZWFkZXJzOiBudWxsLFxuICAgIC8qKlxuICAgKiBTaG91bGQgdGhlIGRlZmF1bHQgaGVhZGVycyBiZSBzZXQgb3Igbm90P1xuICAgKiBBY2NlcHQ6IGFwcGxpY2F0aW9uL2pzb24gPC0gZm9yIHJlcXVlc3RpbmcganNvbiByZXNwb25zZVxuICAgKiBDYWNoZS1Db250cm9sOiBuby1jYWNoZSA8LSBSZXF1ZXN0IHNob3VsZG50IGJlIGNhY2hlZFxuICAgKiBYLVJlcXVlc3RlZC1XaXRoOiBYTUxIdHRwUmVxdWVzdCA8LSBXZSBzZW50IHRoZSByZXF1ZXN0IHZpYSBYTUxIdHRwUmVxdWVzdFxuICAgKi8gZGVmYXVsdEhlYWRlcnM6IHRydWUsXG4gICAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGRyb3B6b25lIGVsZW1lbnQgaXRzZWxmIHdpbGwgYmUgY2xpY2thYmxlLCBpZiBgZmFsc2VgXG4gICAqIG5vdGhpbmcgd2lsbCBiZSBjbGlja2FibGUuXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIEhUTUwgZWxlbWVudCwgYSBDU1Mgc2VsZWN0b3IgKGZvciBtdWx0aXBsZSBlbGVtZW50cylcbiAgICogb3IgYW4gYXJyYXkgb2YgdGhvc2UuIEluIHRoYXQgY2FzZSwgYWxsIG9mIHRob3NlIGVsZW1lbnRzIHdpbGwgdHJpZ2dlciBhblxuICAgKiB1cGxvYWQgd2hlbiBjbGlja2VkLlxuICAgKi8gY2xpY2thYmxlOiB0cnVlLFxuICAgIC8qKlxuICAgKiBXaGV0aGVyIGhpZGRlbiBmaWxlcyBpbiBkaXJlY3RvcmllcyBzaG91bGQgYmUgaWdub3JlZC5cbiAgICovIGlnbm9yZUhpZGRlbkZpbGVzOiB0cnVlLFxuICAgIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgYWNjZXB0YCBjaGVja3MgdGhlIGZpbGUncyBtaW1lIHR5cGUgb3JcbiAgICogZXh0ZW5zaW9uIGFnYWluc3QgdGhpcyBsaXN0LiBUaGlzIGlzIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbWltZVxuICAgKiB0eXBlcyBvciBmaWxlIGV4dGVuc2lvbnMuXG4gICAqXG4gICAqIEVnLjogYGltYWdlLyosYXBwbGljYXRpb24vcGRmLC5wc2RgXG4gICAqXG4gICAqIElmIHRoZSBEcm9wem9uZSBpcyBgY2xpY2thYmxlYCB0aGlzIG9wdGlvbiB3aWxsIGFsc28gYmUgdXNlZCBhc1xuICAgKiBbYGFjY2VwdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L2lucHV0I2F0dHItYWNjZXB0KVxuICAgKiBwYXJhbWV0ZXIgb24gdGhlIGhpZGRlbiBmaWxlIGlucHV0IGFzIHdlbGwuXG4gICAqLyBhY2NlcHRlZEZpbGVzOiBudWxsLFxuICAgIC8qKlxuICAgKiAqKkRlcHJlY2F0ZWQhKipcbiAgICogVXNlIGFjY2VwdGVkRmlsZXMgaW5zdGVhZC5cbiAgICovIGFjY2VwdGVkTWltZVR5cGVzOiBudWxsLFxuICAgIC8qKlxuICAgKiBJZiBmYWxzZSwgZmlsZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgcXVldWUgYnV0IHRoZSBxdWV1ZSB3aWxsIG5vdCBiZVxuICAgKiBwcm9jZXNzZWQgYXV0b21hdGljYWxseS5cbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdSBuZWVkIHNvbWUgYWRkaXRpb25hbCB1c2VyIGlucHV0IGJlZm9yZSBzZW5kaW5nXG4gICAqIGZpbGVzIChvciBpZiB5b3Ugd2FudCB3YW50IGFsbCBmaWxlcyBzZW50IGF0IG9uY2UpLlxuICAgKiBJZiB5b3UncmUgcmVhZHkgdG8gc2VuZCB0aGUgZmlsZSBzaW1wbHkgY2FsbCBgbXlEcm9wem9uZS5wcm9jZXNzUXVldWUoKWAuXG4gICAqXG4gICAqIFNlZSB0aGUgW2VucXVldWluZyBmaWxlIHVwbG9hZHNdKCNlbnF1ZXVpbmctZmlsZS11cGxvYWRzKSBkb2N1bWVudGF0aW9uXG4gICAqIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqLyBhdXRvUHJvY2Vzc1F1ZXVlOiB0cnVlLFxuICAgIC8qKlxuICAgKiBJZiBmYWxzZSwgZmlsZXMgYWRkZWQgdG8gdGhlIGRyb3B6b25lIHdpbGwgbm90IGJlIHF1ZXVlZCBieSBkZWZhdWx0LlxuICAgKiBZb3UnbGwgaGF2ZSB0byBjYWxsIGBlbnF1ZXVlRmlsZShmaWxlKWAgbWFudWFsbHkuXG4gICAqLyBhdXRvUXVldWU6IHRydWUsXG4gICAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhpcyB3aWxsIGFkZCBhIGxpbmsgdG8gZXZlcnkgZmlsZSBwcmV2aWV3IHRvIHJlbW92ZSBvciBjYW5jZWwgKGlmXG4gICAqIGFscmVhZHkgdXBsb2FkaW5nKSB0aGUgZmlsZS4gVGhlIGBkaWN0Q2FuY2VsVXBsb2FkYCwgYGRpY3RDYW5jZWxVcGxvYWRDb25maXJtYXRpb25gXG4gICAqIGFuZCBgZGljdFJlbW92ZUZpbGVgIG9wdGlvbnMgYXJlIHVzZWQgZm9yIHRoZSB3b3JkaW5nLlxuICAgKi8gYWRkUmVtb3ZlTGlua3M6IGZhbHNlLFxuICAgIC8qKlxuICAgKiBEZWZpbmVzIHdoZXJlIHRvIGRpc3BsYXkgdGhlIGZpbGUgcHJldmlld3Mg4oCTIGlmIGBudWxsYCB0aGVcbiAgICogRHJvcHpvbmUgZWxlbWVudCBpdHNlbGYgaXMgdXNlZC4gQ2FuIGJlIGEgcGxhaW4gYEhUTUxFbGVtZW50YCBvciBhIENTU1xuICAgKiBzZWxlY3Rvci4gVGhlIGVsZW1lbnQgc2hvdWxkIGhhdmUgdGhlIGBkcm9wem9uZS1wcmV2aWV3c2AgY2xhc3Mgc29cbiAgICogdGhlIHByZXZpZXdzIGFyZSBkaXNwbGF5ZWQgcHJvcGVybHkuXG4gICAqLyBwcmV2aWV3c0NvbnRhaW5lcjogbnVsbCxcbiAgICAvKipcbiAgICogU2V0IHRoaXMgdG8gYHRydWVgIGlmIHlvdSBkb24ndCB3YW50IHByZXZpZXdzIHRvIGJlIHNob3duLlxuICAgKi8gZGlzYWJsZVByZXZpZXdzOiBmYWxzZSxcbiAgICAvKipcbiAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGUgaGlkZGVuIGlucHV0IGZpZWxkICh3aGljaCBpcyB1c2VkIHdoZW4gY2xpY2tpbmcgb24gdGhlXG4gICAqIGRyb3B6b25lIHRvIHRyaWdnZXIgZmlsZSBzZWxlY3Rpb24pIHdpbGwgYmUgYXBwZW5kZWQgdG8uIFRoaXMgbWlnaHRcbiAgICogYmUgaW1wb3J0YW50IGluIGNhc2UgeW91IHVzZSBmcmFtZXdvcmtzIHRvIHN3aXRjaCB0aGUgY29udGVudCBvZiB5b3VyIHBhZ2UuXG4gICAqXG4gICAqIENhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgb3IgYW4gZWxlbWVudCBkaXJlY3RseS5cbiAgICovIGhpZGRlbklucHV0Q29udGFpbmVyOiBcImJvZHlcIixcbiAgICAvKipcbiAgICogSWYgbnVsbCwgbm8gY2FwdHVyZSB0eXBlIHdpbGwgYmUgc3BlY2lmaWVkXG4gICAqIElmIGNhbWVyYSwgbW9iaWxlIGRldmljZXMgd2lsbCBza2lwIHRoZSBmaWxlIHNlbGVjdGlvbiBhbmQgY2hvb3NlIGNhbWVyYVxuICAgKiBJZiBtaWNyb3Bob25lLCBtb2JpbGUgZGV2aWNlcyB3aWxsIHNraXAgdGhlIGZpbGUgc2VsZWN0aW9uIGFuZCBjaG9vc2UgdGhlIG1pY3JvcGhvbmVcbiAgICogSWYgY2FtY29yZGVyLCBtb2JpbGUgZGV2aWNlcyB3aWxsIHNraXAgdGhlIGZpbGUgc2VsZWN0aW9uIGFuZCBjaG9vc2UgdGhlIGNhbWVyYSBpbiB2aWRlbyBtb2RlXG4gICAqIE9uIGFwcGxlIGRldmljZXMgbXVsdGlwbGUgbXVzdCBiZSBzZXQgdG8gZmFsc2UuICBBY2NlcHRlZEZpbGVzIG1heSBuZWVkIHRvXG4gICAqIGJlIHNldCB0byBhbiBhcHByb3ByaWF0ZSBtaW1lIHR5cGUgKGUuZy4gXCJpbWFnZS8qXCIsIFwiYXVkaW8vKlwiLCBvciBcInZpZGVvLypcIikuXG4gICAqLyBjYXB0dXJlOiBudWxsLFxuICAgIC8qKlxuICAgKiAqKkRlcHJlY2F0ZWQqKi4gVXNlIGByZW5hbWVGaWxlYCBpbnN0ZWFkLlxuICAgKi8gcmVuYW1lRmlsZW5hbWU6IG51bGwsXG4gICAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGJlZm9yZSB0aGUgZmlsZSBpcyB1cGxvYWRlZCB0byB0aGUgc2VydmVyIGFuZCByZW5hbWVzIHRoZSBmaWxlLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIGBGaWxlYCBhcyBhcmd1bWVudCBhbmQgY2FuIHVzZSB0aGUgYGZpbGUubmFtZWAuIFRoZSBhY3R1YWwgbmFtZSBvZiB0aGVcbiAgICogZmlsZSB0aGF0IGdldHMgdXNlZCBkdXJpbmcgdGhlIHVwbG9hZCBjYW4gYmUgYWNjZXNzZWQgdGhyb3VnaCBgZmlsZS51cGxvYWQuZmlsZW5hbWVgLlxuICAgKi8gcmVuYW1lRmlsZTogbnVsbCxcbiAgICAvKipcbiAgICogSWYgYHRydWVgIHRoZSBmYWxsYmFjayB3aWxsIGJlIGZvcmNlZC4gVGhpcyBpcyB2ZXJ5IHVzZWZ1bCB0byB0ZXN0IHlvdXIgc2VydmVyXG4gICAqIGltcGxlbWVudGF0aW9ucyBmaXJzdCBhbmQgbWFrZSBzdXJlIHRoYXQgZXZlcnl0aGluZyB3b3JrcyBhc1xuICAgKiBleHBlY3RlZCB3aXRob3V0IGRyb3B6b25lIGlmIHlvdSBleHBlcmllbmNlIHByb2JsZW1zLCBhbmQgdG8gdGVzdFxuICAgKiBob3cgeW91ciBmYWxsYmFja3Mgd2lsbCBsb29rLlxuICAgKi8gZm9yY2VGYWxsYmFjazogZmFsc2UsXG4gICAgLyoqXG4gICAqIFRoZSB0ZXh0IHVzZWQgYmVmb3JlIGFueSBmaWxlcyBhcmUgZHJvcHBlZC5cbiAgICovIGRpY3REZWZhdWx0TWVzc2FnZTogXCJEcm9wIGZpbGVzIGhlcmUgdG8gdXBsb2FkXCIsXG4gICAgLyoqXG4gICAqIFRoZSB0ZXh0IHRoYXQgcmVwbGFjZXMgdGhlIGRlZmF1bHQgbWVzc2FnZSB0ZXh0IGl0IHRoZSBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqLyBkaWN0RmFsbGJhY2tNZXNzYWdlOiBcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGRyYWcnbidkcm9wIGZpbGUgdXBsb2Fkcy5cIixcbiAgICAvKipcbiAgICogVGhlIHRleHQgdGhhdCB3aWxsIGJlIGFkZGVkIGJlZm9yZSB0aGUgZmFsbGJhY2sgZm9ybS5cbiAgICogSWYgeW91IHByb3ZpZGUgYSAgZmFsbGJhY2sgZWxlbWVudCB5b3Vyc2VsZiwgb3IgaWYgdGhpcyBvcHRpb24gaXMgYG51bGxgIHRoaXMgd2lsbFxuICAgKiBiZSBpZ25vcmVkLlxuICAgKi8gZGljdEZhbGxiYWNrVGV4dDogXCJQbGVhc2UgdXNlIHRoZSBmYWxsYmFjayBmb3JtIGJlbG93IHRvIHVwbG9hZCB5b3VyIGZpbGVzIGxpa2UgaW4gdGhlIG9sZGVuIGRheXMuXCIsXG4gICAgLyoqXG4gICAqIElmIHRoZSBmaWxlc2l6ZSBpcyB0b28gYmlnLlxuICAgKiBge3tmaWxlc2l6ZX19YCBhbmQgYHt7bWF4RmlsZXNpemV9fWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSByZXNwZWN0aXZlIGNvbmZpZ3VyYXRpb24gdmFsdWVzLlxuICAgKi8gZGljdEZpbGVUb29CaWc6IFwiRmlsZSBpcyB0b28gYmlnICh7e2ZpbGVzaXplfX1NaUIpLiBNYXggZmlsZXNpemU6IHt7bWF4RmlsZXNpemV9fU1pQi5cIixcbiAgICAvKipcbiAgICogSWYgdGhlIGZpbGUgZG9lc24ndCBtYXRjaCB0aGUgZmlsZSB0eXBlLlxuICAgKi8gZGljdEludmFsaWRGaWxlVHlwZTogXCJZb3UgY2FuJ3QgdXBsb2FkIGZpbGVzIG9mIHRoaXMgdHlwZS5cIixcbiAgICAvKipcbiAgICogSWYgdGhlIHNlcnZlciByZXNwb25zZSB3YXMgaW52YWxpZC5cbiAgICogYHt7c3RhdHVzQ29kZX19YCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHNlcnZlcnMgc3RhdHVzIGNvZGUuXG4gICAqLyBkaWN0UmVzcG9uc2VFcnJvcjogXCJTZXJ2ZXIgcmVzcG9uZGVkIHdpdGgge3tzdGF0dXNDb2RlfX0gY29kZS5cIixcbiAgICAvKipcbiAgICogSWYgYGFkZFJlbW92ZUxpbmtzYCBpcyB0cnVlLCB0aGUgdGV4dCB0byBiZSB1c2VkIGZvciB0aGUgY2FuY2VsIHVwbG9hZCBsaW5rLlxuICAgKi8gZGljdENhbmNlbFVwbG9hZDogXCJDYW5jZWwgdXBsb2FkXCIsXG4gICAgLyoqXG4gICAqIFRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGlmIGFuIHVwbG9hZCB3YXMgbWFudWFsbHkgY2FuY2VsZWRcbiAgICovIGRpY3RVcGxvYWRDYW5jZWxlZDogXCJVcGxvYWQgY2FuY2VsZWQuXCIsXG4gICAgLyoqXG4gICAqIElmIGBhZGRSZW1vdmVMaW5rc2AgaXMgdHJ1ZSwgdGhlIHRleHQgdG8gYmUgdXNlZCBmb3IgY29uZmlybWF0aW9uIHdoZW4gY2FuY2VsbGluZyB1cGxvYWQuXG4gICAqLyBkaWN0Q2FuY2VsVXBsb2FkQ29uZmlybWF0aW9uOiBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjYW5jZWwgdGhpcyB1cGxvYWQ/XCIsXG4gICAgLyoqXG4gICAqIElmIGBhZGRSZW1vdmVMaW5rc2AgaXMgdHJ1ZSwgdGhlIHRleHQgdG8gYmUgdXNlZCB0byByZW1vdmUgYSBmaWxlLlxuICAgKi8gZGljdFJlbW92ZUZpbGU6IFwiUmVtb3ZlIGZpbGVcIixcbiAgICAvKipcbiAgICogSWYgdGhpcyBpcyBub3QgbnVsbCwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIGJlZm9yZSByZW1vdmluZyBhIGZpbGUuXG4gICAqLyBkaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbjogbnVsbCxcbiAgICAvKipcbiAgICogRGlzcGxheWVkIGlmIGBtYXhGaWxlc2AgaXMgc3QgYW5kIGV4Y2VlZGVkLlxuICAgKiBUaGUgc3RyaW5nIGB7e21heEZpbGVzfX1gIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWUuXG4gICAqLyBkaWN0TWF4RmlsZXNFeGNlZWRlZDogXCJZb3UgY2FuIG5vdCB1cGxvYWQgYW55IG1vcmUgZmlsZXMuXCIsXG4gICAgLyoqXG4gICAqIEFsbG93cyB5b3UgdG8gdHJhbnNsYXRlIHRoZSBkaWZmZXJlbnQgdW5pdHMuIFN0YXJ0aW5nIHdpdGggYHRiYCBmb3IgdGVyYWJ5dGVzIGFuZCBnb2luZyBkb3duIHRvXG4gICAqIGBiYCBmb3IgYnl0ZXMuXG4gICAqLyBkaWN0RmlsZVNpemVVbml0czoge1xuICAgICAgICB0YjogXCJUQlwiLFxuICAgICAgICBnYjogXCJHQlwiLFxuICAgICAgICBtYjogXCJNQlwiLFxuICAgICAgICBrYjogXCJLQlwiLFxuICAgICAgICBiOiBcImJcIlxuICAgIH0sXG4gICAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRyb3B6b25lIGluaXRpYWxpemVkXG4gICAqIFlvdSBjYW4gYWRkIGV2ZW50IGxpc3RlbmVycyBoZXJlXG4gICAqLyBpbml0ICgpIHtcbiAgICB9LFxuICAgIC8qKlxuICAgKiBDYW4gYmUgYW4gKipvYmplY3QqKiBvZiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gdHJhbnNmZXIgdG8gdGhlIHNlcnZlciwgKipvcioqIGEgYEZ1bmN0aW9uYFxuICAgKiB0aGF0IGdldHMgaW52b2tlZCB3aXRoIHRoZSBgZmlsZXNgLCBgeGhyYCBhbmQsIGlmIGl0J3MgYSBjaHVua2VkIHVwbG9hZCwgYGNodW5rYCBhcmd1bWVudHMuIEluIGNhc2VcbiAgICogb2YgYSBmdW5jdGlvbiwgdGhpcyBuZWVkcyB0byByZXR1cm4gYSBtYXAuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGRvZXMgbm90aGluZyBmb3Igbm9ybWFsIHVwbG9hZHMsIGJ1dCBhZGRzIHJlbGV2YW50IGluZm9ybWF0aW9uIGZvclxuICAgKiBjaHVua2VkIHVwbG9hZHMuXG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgYWRkaW5nIGhpZGRlbiBpbnB1dCBmaWVsZHMgaW4gdGhlIGZvcm0gZWxlbWVudC5cbiAgICovIHBhcmFtcyAoZmlsZXMsIHhociwgY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rKSByZXR1cm4ge1xuICAgICAgICAgICAgZHp1dWlkOiBjaHVuay5maWxlLnVwbG9hZC51dWlkLFxuICAgICAgICAgICAgZHpjaHVua2luZGV4OiBjaHVuay5pbmRleCxcbiAgICAgICAgICAgIGR6dG90YWxmaWxlc2l6ZTogY2h1bmsuZmlsZS5zaXplLFxuICAgICAgICAgICAgZHpjaHVua3NpemU6IHRoaXMub3B0aW9ucy5jaHVua1NpemUsXG4gICAgICAgICAgICBkenRvdGFsY2h1bmtjb3VudDogY2h1bmsuZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50LFxuICAgICAgICAgICAgZHpjaHVua2J5dGVvZmZzZXQ6IGNodW5rLmluZGV4ICogdGhpcy5vcHRpb25zLmNodW5rU2l6ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCBnZXRzIGEgW2ZpbGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL0ZpbGUpXG4gICAqIGFuZCBhIGBkb25lYCBmdW5jdGlvbiBhcyBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBJZiB0aGUgZG9uZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCB0aGUgZmlsZSBpcyBcImFjY2VwdGVkXCIgYW5kIHdpbGxcbiAgICogYmUgcHJvY2Vzc2VkLiBJZiB5b3UgcGFzcyBhbiBlcnJvciBtZXNzYWdlLCB0aGUgZmlsZSBpcyByZWplY3RlZCwgYW5kIHRoZSBlcnJvclxuICAgKiBtZXNzYWdlIHdpbGwgYmUgZGlzcGxheWVkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgZmlsZSBpcyB0b28gYmlnIG9yIGRvZXNuJ3QgbWF0Y2ggdGhlIG1pbWUgdHlwZXMuXG4gICAqLyBhY2NlcHQgKGZpbGUsIGRvbmUpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgKiBUaGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiBhbGwgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCBmb3IgYSBmaWxlLlxuICAgKiBJdCBnZXRzIHRoZSBmaWxlIGZvciB3aGljaCB0aGUgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLFxuICAgKiBhbmQgdGhlIGBkb25lYCBmdW5jdGlvbiBhcyBzZWNvbmQuIGBkb25lKClgIG5lZWRzIHRvIGJlIGludm9rZWQgd2hlbiBldmVyeXRoaW5nXG4gICAqIG5lZWRlZCB0byBmaW5pc2ggdGhlIHVwbG9hZCBwcm9jZXNzIGlzIGRvbmUuXG4gICAqLyBjaHVua3NVcGxvYWRlZDogZnVuY3Rpb24oZmlsZSwgZG9uZSkge1xuICAgICAgICBkb25lKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICogU2VuZHMgdGhlIGZpbGUgYXMgYmluYXJ5IGJsb2IgaW4gYm9keSBpbnN0ZWFkIG9mIGZvcm0gZGF0YS5cbiAgICogSWYgdGhpcyBpcyBzZXQsIHRoZSBgcGFyYW1zYCBvcHRpb24gd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBJdCdzIGFuIGVycm9yIHRvIHNldCB0aGlzIHRvIGB0cnVlYCBhbG9uZyB3aXRoIGB1cGxvYWRNdWx0aXBsZWAgc2luY2VcbiAgICogbXVsdGlwbGUgZmlsZXMgY2Fubm90IGJlIGluIGEgc2luZ2xlIGJpbmFyeSBib2R5LlxuICAgKi8gYmluYXJ5Qm9keTogZmFsc2UsXG4gICAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZC5cbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2hvd3MgdGhlIGZhbGxiYWNrIGlucHV0IGZpZWxkIGFuZCBhZGRzXG4gICAqIGEgdGV4dC5cbiAgICovIGZhbGxiYWNrICgpIHtcbiAgICAgICAgLy8gVGhpcyBjb2RlIHNob3VsZCBwYXNzIGluIElFNy4uLiA6KFxuICAgICAgICBsZXQgbWVzc2FnZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBgJHt0aGlzLmVsZW1lbnQuY2xhc3NOYW1lfSBkei1icm93c2VyLW5vdC1zdXBwb3J0ZWRgO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikpaWYgKC8oXnwgKWR6LW1lc3NhZ2UoJHwgKS8udGVzdChjaGlsZC5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBtZXNzYWdlRWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgY2hpbGQuY2xhc3NOYW1lID0gXCJkei1tZXNzYWdlXCI7IC8vIFJlbW92ZXMgdGhlICdkei1kZWZhdWx0JyBjbGFzc1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmNyZWF0ZUVsZW1lbnQoJzxkaXYgY2xhc3M9XCJkei1tZXNzYWdlXCI+PHNwYW4+PC9zcGFuPjwvZGl2PicpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKG1lc3NhZ2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IG1lc3NhZ2VFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3BhblwiKVswXTtcbiAgICAgICAgaWYgKHNwYW4pIHtcbiAgICAgICAgICAgIGlmIChzcGFuLnRleHRDb250ZW50ICE9IG51bGwpIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wdGlvbnMuZGljdEZhbGxiYWNrTWVzc2FnZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNwYW4uaW5uZXJUZXh0ICE9IG51bGwpIHNwYW4uaW5uZXJUZXh0ID0gdGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja01lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmdldEZhbGxiYWNrRm9ybSgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB0byBjYWxjdWxhdGUgdGhlIHRodW1ibmFpbCBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBJdCBnZXRzIGBmaWxlYCwgYHdpZHRoYCBhbmQgYGhlaWdodGAgKGJvdGggbWF5IGJlIGBudWxsYCkgYXMgcGFyYW1ldGVycyBhbmQgbXVzdCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqXG4gICAqICAtIGBzcmNXaWR0aGAgJiBgc3JjSGVpZ2h0YCAocmVxdWlyZWQpXG4gICAqICAtIGB0cmdXaWR0aGAgJiBgdHJnSGVpZ2h0YCAocmVxdWlyZWQpXG4gICAqICAtIGBzcmNYYCAmIGBzcmNZYCAob3B0aW9uYWwsIGRlZmF1bHQgYDBgKVxuICAgKiAgLSBgdHJnWGAgJiBgdHJnWWAgKG9wdGlvbmFsLCBkZWZhdWx0IGAwYClcbiAgICpcbiAgICogVGhvc2UgdmFsdWVzIGFyZSBnb2luZyB0byBiZSB1c2VkIGJ5IGBjdHguZHJhd0ltYWdlKClgLlxuICAgKi8gcmVzaXplIChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QpIHtcbiAgICAgICAgbGV0IGluZm8gPSB7XG4gICAgICAgICAgICBzcmNYOiAwLFxuICAgICAgICAgICAgc3JjWTogMCxcbiAgICAgICAgICAgIHNyY1dpZHRoOiBmaWxlLndpZHRoLFxuICAgICAgICAgICAgc3JjSGVpZ2h0OiBmaWxlLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3JjUmF0aW8gPSBmaWxlLndpZHRoIC8gZmlsZS5oZWlnaHQ7XG4gICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIGRpbWVuc2lvbnMgaWYgbm90IHNwZWNpZmllZFxuICAgICAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2lkdGggPSBpbmZvLnNyY1dpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gaW5mby5zcmNIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggPT0gbnVsbCkgd2lkdGggPSBoZWlnaHQgKiBzcmNSYXRpbztcbiAgICAgICAgZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIGhlaWdodCA9IHdpZHRoIC8gc3JjUmF0aW87XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBpbWFnZXMgYXJlbid0IHVwc2NhbGVkXG4gICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIGluZm8uc3JjV2lkdGgpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIGluZm8uc3JjSGVpZ2h0KTtcbiAgICAgICAgbGV0IHRyZ1JhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGlmIChpbmZvLnNyY1dpZHRoID4gd2lkdGggfHwgaW5mby5zcmNIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIEltYWdlIGlzIGJpZ2dlciBhbmQgbmVlZHMgcmVzY2FsaW5nXG4gICAgICAgICAgICBpZiAocmVzaXplTWV0aG9kID09PSBcImNyb3BcIikge1xuICAgICAgICAgICAgICAgIGlmIChzcmNSYXRpbyA+IHRyZ1JhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uc3JjSGVpZ2h0ID0gZmlsZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uc3JjV2lkdGggPSBpbmZvLnNyY0hlaWdodCAqIHRyZ1JhdGlvO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uc3JjV2lkdGggPSBmaWxlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNyY0hlaWdodCA9IGluZm8uc3JjV2lkdGggLyB0cmdSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc2l6ZU1ldGhvZCA9PT0gXCJjb250YWluXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNZXRob2QgJ2NvbnRhaW4nXG4gICAgICAgICAgICAgICAgaWYgKHNyY1JhdGlvID4gdHJnUmF0aW8pIGhlaWdodCA9IHdpZHRoIC8gc3JjUmF0aW87XG4gICAgICAgICAgICAgICAgZWxzZSB3aWR0aCA9IGhlaWdodCAqIHNyY1JhdGlvO1xuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biByZXNpemVNZXRob2QgJyR7cmVzaXplTWV0aG9kfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnNyY1ggPSAoZmlsZS53aWR0aCAtIGluZm8uc3JjV2lkdGgpIC8gMjtcbiAgICAgICAgaW5mby5zcmNZID0gKGZpbGUuaGVpZ2h0IC0gaW5mby5zcmNIZWlnaHQpIC8gMjtcbiAgICAgICAgaW5mby50cmdXaWR0aCA9IHdpZHRoO1xuICAgICAgICBpbmZvLnRyZ0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfSxcbiAgICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBmaWxlIChmb3IgZXhhbXBsZSwgcmVzaXplIGFuIGltYWdlIGlmIG5lY2Vzc2FyeSkuXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHVzZXMgYHJlc2l6ZVdpZHRoYCBhbmQgYHJlc2l6ZUhlaWdodGAgKGlmIHByb3ZpZGVkKSBhbmQgcmVzaXplc1xuICAgKiBpbWFnZXMgYWNjb3JkaW5nIHRvIHRob3NlIGRpbWVuc2lvbnMuXG4gICAqXG4gICAqIEdldHMgdGhlIGBmaWxlYCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLCBhbmQgYSBgZG9uZSgpYCBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kLCB0aGF0IG5lZWRzXG4gICAqIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgZmlsZSB3aGVuIHRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lLlxuICAgKi8gdHJhbnNmb3JtRmlsZSAoZmlsZSwgZG9uZSkge1xuICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5yZXNpemVXaWR0aCB8fCB0aGlzLm9wdGlvbnMucmVzaXplSGVpZ2h0KSAmJiBmaWxlLnR5cGUubWF0Y2goL2ltYWdlLiovKSkgcmV0dXJuIHRoaXMucmVzaXplSW1hZ2UoZmlsZSwgdGhpcy5vcHRpb25zLnJlc2l6ZVdpZHRoLCB0aGlzLm9wdGlvbnMucmVzaXplSGVpZ2h0LCB0aGlzLm9wdGlvbnMucmVzaXplTWV0aG9kLCBkb25lKTtcbiAgICAgICAgZWxzZSByZXR1cm4gZG9uZShmaWxlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgKiBBIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSB0ZW1wbGF0ZSB1c2VkIGZvciBlYWNoIGRyb3BwZWRcbiAgICogZmlsZS4gQ2hhbmdlIGl0IHRvIGZ1bGZpbGwgeW91ciBuZWVkcyBidXQgbWFrZSBzdXJlIHRvIHByb3Blcmx5XG4gICAqIHByb3ZpZGUgYWxsIGVsZW1lbnRzLlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byB1c2UgYW4gYWN0dWFsIEhUTUwgZWxlbWVudCBpbnN0ZWFkIG9mIHByb3ZpZGluZyBhIFN0cmluZ1xuICAgKiBhcyBhIGNvbmZpZyBvcHRpb24sIHlvdSBjb3VsZCBjcmVhdGUgYSBkaXYgd2l0aCB0aGUgaWQgYHRwbGAsXG4gICAqIHB1dCB0aGUgdGVtcGxhdGUgaW5zaWRlIGl0IGFuZCBwcm92aWRlIHRoZSBlbGVtZW50IGxpa2UgdGhpczpcbiAgICpcbiAgICogICAgIGRvY3VtZW50XG4gICAqICAgICAgIC5xdWVyeVNlbGVjdG9yKCcjdHBsJylcbiAgICogICAgICAgLmlubmVySFRNTFxuICAgKlxuICAgKi8gcHJldmlld1RlbXBsYXRlOiAoLypAX19QVVJFX18qLyRwYXJjZWwkaW50ZXJvcERlZmF1bHQoJGZkNjAzMWY4OGRjZTJlMzIkZXhwb3J0cykpLFxuICAgIC8qXG4gICBUaG9zZSBmdW5jdGlvbnMgcmVnaXN0ZXIgdGhlbXNlbHZlcyB0byB0aGUgZXZlbnRzIG9uIGluaXQgYW5kIGhhbmRsZSBhbGxcbiAgIHRoZSB1c2VyIGludGVyZmFjZSBzcGVjaWZpYyBzdHVmZi4gT3ZlcndyaXRpbmcgdGhlbSB3b24ndCBicmVhayB0aGUgdXBsb2FkXG4gICBidXQgY2FuIGJyZWFrIHRoZSB3YXkgaXQncyBkaXNwbGF5ZWQuXG4gICBZb3UgY2FuIG92ZXJ3cml0ZSB0aGVtIGlmIHlvdSBkb24ndCBsaWtlIHRoZSBkZWZhdWx0IGJlaGF2aW9yLiBJZiB5b3UganVzdFxuICAgd2FudCB0byBhZGQgYW4gYWRkaXRpb25hbCBldmVudCBoYW5kbGVyLCByZWdpc3RlciBpdCBvbiB0aGUgZHJvcHpvbmUgb2JqZWN0XG4gICBhbmQgZG9uJ3Qgb3ZlcndyaXRlIHRob3NlIG9wdGlvbnMuXG4gICAqLyAvLyBUaG9zZSBhcmUgc2VsZiBleHBsYW5hdG9yeSBhbmQgc2ltcGx5IGNvbmNlcm4gdGhlIERyYWduRHJvcC5cbiAgICBkcm9wIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWRyYWctaG92ZXJcIik7XG4gICAgfSxcbiAgICBkcmFnc3RhcnQgKGUpIHtcbiAgICB9LFxuICAgIGRyYWdlbmQgKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotZHJhZy1ob3ZlclwiKTtcbiAgICB9LFxuICAgIGRyYWdlbnRlciAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1kcmFnLWhvdmVyXCIpO1xuICAgIH0sXG4gICAgZHJhZ292ZXIgKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotZHJhZy1ob3ZlclwiKTtcbiAgICB9LFxuICAgIGRyYWdsZWF2ZSAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1kcmFnLWhvdmVyXCIpO1xuICAgIH0sXG4gICAgcGFzdGUgKGUpIHtcbiAgICB9LFxuICAgIC8vIENhbGxlZCB3aGVuZXZlciB0aGVyZSBhcmUgbm8gZmlsZXMgbGVmdCBpbiB0aGUgZHJvcHpvbmUgYW55bW9yZSwgYW5kIHRoZVxuICAgIC8vIGRyb3B6b25lIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXMgaWYgaW4gdGhlIGluaXRpYWwgc3RhdGUuXG4gICAgcmVzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1zdGFydGVkXCIpO1xuICAgIH0sXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBmaWxlIGlzIGFkZGVkIHRvIHRoZSBxdWV1ZVxuICAgIC8vIFJlY2VpdmVzIGBmaWxlYFxuICAgIGFkZGVkZmlsZSAoZmlsZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50ID09PSB0aGlzLnByZXZpZXdzQ29udGFpbmVyKSB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LXN0YXJ0ZWRcIik7XG4gICAgICAgIGlmICh0aGlzLnByZXZpZXdzQ29udGFpbmVyICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZVByZXZpZXdzKSB7XG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50ID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5wcmV2aWV3VGVtcGxhdGUudHJpbSgpKTtcbiAgICAgICAgICAgIGZpbGUucHJldmlld1RlbXBsYXRlID0gZmlsZS5wcmV2aWV3RWxlbWVudDsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIHRoaXMucHJldmlld3NDb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsZS5wcmV2aWV3RWxlbWVudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBub2RlIG9mIGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LW5hbWVdXCIpKW5vZGUudGV4dENvbnRlbnQgPSBmaWxlLm5hbWU7XG4gICAgICAgICAgICBmb3IgKG5vZGUgb2YgZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotc2l6ZV1cIikpbm9kZS5pbm5lckhUTUwgPSB0aGlzLmZpbGVzaXplKGZpbGUuc2l6ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZFJlbW92ZUxpbmtzKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5fcmVtb3ZlTGluayA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuY3JlYXRlRWxlbWVudChgPGEgY2xhc3M9XCJkei1yZW1vdmVcIiBocmVmPVwiamF2YXNjcmlwdDp1bmRlZmluZWQ7XCIgZGF0YS1kei1yZW1vdmU+JHt0aGlzLm9wdGlvbnMuZGljdFJlbW92ZUZpbGV9PC9hPmApO1xuICAgICAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZmlsZS5fcmVtb3ZlTGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVtb3ZlRmlsZUV2ZW50ID0gKGUpPT57XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORykgcmV0dXJuICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuY29uZmlybSh0aGlzLm9wdGlvbnMuZGljdENhbmNlbFVwbG9hZENvbmZpcm1hdGlvbiwgKCk9PnRoaXMucmVtb3ZlRmlsZShmaWxlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGljdFJlbW92ZUZpbGVDb25maXJtYXRpb24pIHJldHVybiAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmNvbmZpcm0odGhpcy5vcHRpb25zLmRpY3RSZW1vdmVGaWxlQ29uZmlybWF0aW9uLCAoKT0+dGhpcy5yZW1vdmVGaWxlKGZpbGUpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIHRoaXMucmVtb3ZlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQgcmVtb3ZlTGluayBvZiBmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1yZW1vdmVdXCIpKXJlbW92ZUxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHJlbW92ZUZpbGVFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIENhbGxlZCB3aGVuZXZlciBhIGZpbGUgaXMgcmVtb3ZlZC5cbiAgICByZW1vdmVkZmlsZSAoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCAhPSBudWxsICYmIGZpbGUucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZSAhPSBudWxsKSBmaWxlLnByZXZpZXdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmlsZS5wcmV2aWV3RWxlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNYXhGaWxlc1JlYWNoZWRDbGFzcygpO1xuICAgIH0sXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSB0aHVtYm5haWwgaGFzIGJlZW4gZ2VuZXJhdGVkXG4gICAgLy8gUmVjZWl2ZXMgYGZpbGVgIGFuZCBgZGF0YVVybGBcbiAgICB0aHVtYm5haWwgKGZpbGUsIGRhdGFVcmwpIHtcbiAgICAgICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWZpbGUtcHJldmlld1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRodW1ibmFpbEVsZW1lbnQgb2YgZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotdGh1bWJuYWlsXVwiKSl7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsRWxlbWVudC5hbHQgPSBmaWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsRWxlbWVudC5zcmMgPSBkYXRhVXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCk9PmZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWltYWdlLXByZXZpZXdcIilcbiAgICAgICAgICAgICwgMSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIENhbGxlZCB3aGVuZXZlciBhbiBlcnJvciBvY2N1cnNcbiAgICAvLyBSZWNlaXZlcyBgZmlsZWAgYW5kIGBtZXNzYWdlYFxuICAgIGVycm9yIChmaWxlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1lcnJvclwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIiAmJiBtZXNzYWdlLmVycm9yKSBtZXNzYWdlID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotZXJyb3JtZXNzYWdlXVwiKSlub2RlLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXJyb3JtdWx0aXBsZSAoKSB7XG4gICAgfSxcbiAgICAvLyBDYWxsZWQgd2hlbiBhIGZpbGUgZ2V0cyBwcm9jZXNzZWQuIFNpbmNlIHRoZXJlIGlzIGEgY3VlLCBub3QgYWxsIGFkZGVkXG4gICAgLy8gZmlsZXMgYXJlIHByb2Nlc3NlZCBpbW1lZGlhdGVseS5cbiAgICAvLyBSZWNlaXZlcyBgZmlsZWBcbiAgICBwcm9jZXNzaW5nIChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1wcm9jZXNzaW5nXCIpO1xuICAgICAgICAgICAgaWYgKGZpbGUuX3JlbW92ZUxpbmspIHJldHVybiBmaWxlLl9yZW1vdmVMaW5rLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5kaWN0Q2FuY2VsVXBsb2FkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm9jZXNzaW5nbXVsdGlwbGUgKCkge1xuICAgIH0sXG4gICAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSB1cGxvYWQgcHJvZ3Jlc3MgZ2V0cyB1cGRhdGVkLlxuICAgIC8vIFJlY2VpdmVzIGBmaWxlYCwgYHByb2dyZXNzYCAocGVyY2VudGFnZSAwLTEwMCkgYW5kIGBieXRlc1NlbnRgLlxuICAgIC8vIFRvIGdldCB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBmaWxlLCB1c2UgYGZpbGUuc2l6ZWBcbiAgICB1cGxvYWRwcm9ncmVzcyAoZmlsZSwgcHJvZ3Jlc3MsIGJ5dGVzU2VudCkge1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkgZm9yIChsZXQgbm9kZSBvZiBmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei11cGxvYWRwcm9ncmVzc11cIikpbm9kZS5ub2RlTmFtZSA9PT0gXCJQUk9HUkVTU1wiID8gbm9kZS52YWx1ZSA9IHByb2dyZXNzIDogbm9kZS5zdHlsZS53aWR0aCA9IGAke3Byb2dyZXNzfSVgO1xuICAgIH0sXG4gICAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSB0b3RhbCB1cGxvYWQgcHJvZ3Jlc3MgZ2V0cyB1cGRhdGVkLlxuICAgIC8vIENhbGxlZCB3aXRoIHRvdGFsVXBsb2FkUHJvZ3Jlc3MgKDAtMTAwKSwgdG90YWxCeXRlcyBhbmQgdG90YWxCeXRlc1NlbnRcbiAgICB0b3RhbHVwbG9hZHByb2dyZXNzICgpIHtcbiAgICB9LFxuICAgIC8vIENhbGxlZCBqdXN0IGJlZm9yZSB0aGUgZmlsZSBpcyBzZW50LiBHZXRzIHRoZSBgeGhyYCBvYmplY3QgYXMgc2Vjb25kXG4gICAgLy8gcGFyYW1ldGVyLCBzbyB5b3UgY2FuIG1vZGlmeSBpdCAoZm9yIGV4YW1wbGUgdG8gYWRkIGEgQ1NSRiB0b2tlbikgYW5kIGFcbiAgICAvLyBgZm9ybURhdGFgIG9iamVjdCB0byBhZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAgICBzZW5kaW5nICgpIHtcbiAgICB9LFxuICAgIHNlbmRpbmdtdWx0aXBsZSAoKSB7XG4gICAgfSxcbiAgICAvLyBXaGVuIHRoZSBjb21wbGV0ZSB1cGxvYWQgaXMgZmluaXNoZWQgYW5kIHN1Y2Nlc3NmdWxcbiAgICAvLyBSZWNlaXZlcyBgZmlsZWBcbiAgICBzdWNjZXNzIChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSByZXR1cm4gZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotc3VjY2Vzc1wiKTtcbiAgICB9LFxuICAgIHN1Y2Nlc3NtdWx0aXBsZSAoKSB7XG4gICAgfSxcbiAgICAvLyBXaGVuIHRoZSB1cGxvYWQgaXMgY2FuY2VsZWQuXG4gICAgY2FuY2VsZWQgKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsIGZpbGUsIHRoaXMub3B0aW9ucy5kaWN0VXBsb2FkQ2FuY2VsZWQpO1xuICAgIH0sXG4gICAgY2FuY2VsZWRtdWx0aXBsZSAoKSB7XG4gICAgfSxcbiAgICAvLyBXaGVuIHRoZSB1cGxvYWQgaXMgZmluaXNoZWQsIGVpdGhlciB3aXRoIHN1Y2Nlc3Mgb3IgYW4gZXJyb3IuXG4gICAgLy8gUmVjZWl2ZXMgYGZpbGVgXG4gICAgY29tcGxldGUgKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuX3JlbW92ZUxpbmspIGZpbGUuX3JlbW92ZUxpbmsuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmRpY3RSZW1vdmVGaWxlO1xuICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkgcmV0dXJuIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWNvbXBsZXRlXCIpO1xuICAgIH0sXG4gICAgY29tcGxldGVtdWx0aXBsZSAoKSB7XG4gICAgfSxcbiAgICBtYXhmaWxlc2V4Y2VlZGVkICgpIHtcbiAgICB9LFxuICAgIG1heGZpbGVzcmVhY2hlZCAoKSB7XG4gICAgfSxcbiAgICBxdWV1ZWNvbXBsZXRlICgpIHtcbiAgICB9LFxuICAgIGFkZGVkZmlsZXMgKCkge1xuICAgIH1cbn07XG52YXIgJDRjYTM2NzE4Mjc3NmY4MGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSA9ICQ0Y2EzNjcxODI3NzZmODBiJHZhciRkZWZhdWx0T3B0aW9ucztcblxuXG5jbGFzcyAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5IGV4dGVuZHMgJDQwNDBhY2ZkODU4NDMzOGQkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSB7XG4gICAgc3RhdGljIGluaXRDbGFzcygpIHtcbiAgICAgICAgLy8gRXhwb3NpbmcgdGhlIGVtaXR0ZXIgY2xhc3MsIG1haW5seSBmb3IgdGVzdHNcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuRW1pdHRlciA9ICQ0MDQwYWNmZDg1ODQzMzhkJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzk7XG4gICAgICAgIC8qXG4gICAgIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgZXZlbnRzIHlvdSBjYW4gcmVnaXN0ZXIgb24gYSBkcm9wem9uZSBvYmplY3QuXG5cbiAgICAgWW91IGNhbiByZWdpc3RlciBhbiBldmVudCBoYW5kbGVyIGxpa2UgdGhpczpcblxuICAgICBkcm9wem9uZS5vbihcImRyYWdFbnRlclwiLCBmdW5jdGlvbigpIHsgfSk7XG5cbiAgICAgKi8gdGhpcy5wcm90b3R5cGUuZXZlbnRzID0gW1xuICAgICAgICAgICAgXCJkcm9wXCIsXG4gICAgICAgICAgICBcImRyYWdzdGFydFwiLFxuICAgICAgICAgICAgXCJkcmFnZW5kXCIsXG4gICAgICAgICAgICBcImRyYWdlbnRlclwiLFxuICAgICAgICAgICAgXCJkcmFnb3ZlclwiLFxuICAgICAgICAgICAgXCJkcmFnbGVhdmVcIixcbiAgICAgICAgICAgIFwiYWRkZWRmaWxlXCIsXG4gICAgICAgICAgICBcImFkZGVkZmlsZXNcIixcbiAgICAgICAgICAgIFwicmVtb3ZlZGZpbGVcIixcbiAgICAgICAgICAgIFwidGh1bWJuYWlsXCIsXG4gICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICBcImVycm9ybXVsdGlwbGVcIixcbiAgICAgICAgICAgIFwicHJvY2Vzc2luZ1wiLFxuICAgICAgICAgICAgXCJwcm9jZXNzaW5nbXVsdGlwbGVcIixcbiAgICAgICAgICAgIFwidXBsb2FkcHJvZ3Jlc3NcIixcbiAgICAgICAgICAgIFwidG90YWx1cGxvYWRwcm9ncmVzc1wiLFxuICAgICAgICAgICAgXCJzZW5kaW5nXCIsXG4gICAgICAgICAgICBcInNlbmRpbmdtdWx0aXBsZVwiLFxuICAgICAgICAgICAgXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICBcInN1Y2Nlc3NtdWx0aXBsZVwiLFxuICAgICAgICAgICAgXCJjYW5jZWxlZFwiLFxuICAgICAgICAgICAgXCJjYW5jZWxlZG11bHRpcGxlXCIsXG4gICAgICAgICAgICBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgICBcImNvbXBsZXRlbXVsdGlwbGVcIixcbiAgICAgICAgICAgIFwicmVzZXRcIixcbiAgICAgICAgICAgIFwibWF4ZmlsZXNleGNlZWRlZFwiLFxuICAgICAgICAgICAgXCJtYXhmaWxlc3JlYWNoZWRcIixcbiAgICAgICAgICAgIFwicXVldWVjb21wbGV0ZVwiLCBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX3RodW1ibmFpbFF1ZXVlID0gW107XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9wcm9jZXNzaW5nVGh1bWJuYWlsID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYWxsIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIGFjY2VwdGVkXG4gICAgZ2V0QWNjZXB0ZWRGaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKChmaWxlKT0+ZmlsZS5hY2NlcHRlZFxuICAgICAgICApLm1hcCgoZmlsZSk9PmZpbGVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbGwgZmlsZXMgdGhhdCBoYXZlIGJlZW4gcmVqZWN0ZWRcbiAgICAvLyBOb3Qgc3VyZSB3aGVuIHRoYXQncyBnb2luZyB0byBiZSB1c2VmdWwsIGJ1dCBhZGRlZCBmb3IgY29tcGxldGVuZXNzLlxuICAgIGdldFJlamVjdGVkRmlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzLmZpbHRlcigoZmlsZSk9PiFmaWxlLmFjY2VwdGVkXG4gICAgICAgICkubWFwKChmaWxlKT0+ZmlsZVxuICAgICAgICApO1xuICAgIH1cbiAgICBnZXRGaWxlc1dpdGhTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzLmZpbHRlcigoZmlsZSk9PmZpbGUuc3RhdHVzID09PSBzdGF0dXNcbiAgICAgICAgKS5tYXAoKGZpbGUpPT5maWxlXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYWxsIGZpbGVzIHRoYXQgYXJlIGluIHRoZSBxdWV1ZVxuICAgIGdldFF1ZXVlZEZpbGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWxlc1dpdGhTdGF0dXMoJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5RVUVVRUQpO1xuICAgIH1cbiAgICBnZXRVcGxvYWRpbmdGaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKCQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuVVBMT0FESU5HKTtcbiAgICB9XG4gICAgZ2V0QWRkZWRGaWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKCQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuQURERUQpO1xuICAgIH1cbiAgICAvLyBGaWxlcyB0aGF0IGFyZSBlaXRoZXIgcXVldWVkIG9yIHVwbG9hZGluZ1xuICAgIGdldEFjdGl2ZUZpbGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoKGZpbGUpPT5maWxlLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5VUExPQURJTkcgfHwgZmlsZS5zdGF0dXMgPT09ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuUVVFVUVEXG4gICAgICAgICkubWFwKChmaWxlKT0+ZmlsZVxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIERyb3B6b25lIGlzIGluaXRpYWxpemVkLiBZb3VcbiAgICAvLyBjYW4gKGFuZCBzaG91bGQpIHNldHVwIGV2ZW50IGxpc3RlbmVycyBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBJbiBjYXNlIGl0IGlzbid0IHNldCBhbHJlYWR5XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQudGFnTmFtZSA9PT0gXCJmb3JtXCIpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJkcm9wem9uZVwiKSAmJiAhdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZHotbWVzc2FnZVwiKSkgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKCQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuY3JlYXRlRWxlbWVudChgPGRpdiBjbGFzcz1cImR6LWRlZmF1bHQgZHotbWVzc2FnZVwiPjxidXR0b24gY2xhc3M9XCJkei1idXR0b25cIiB0eXBlPVwiYnV0dG9uXCI+JHt0aGlzLm9wdGlvbnMuZGljdERlZmF1bHRNZXNzYWdlfTwvYnV0dG9uPjwvZGl2PmApKTtcbiAgICAgICAgaWYgKHRoaXMuY2xpY2thYmxlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgc2V0dXBIaWRkZW5GaWxlSW5wdXQgPSAoKT0+e1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpZGRlbkZpbGVJbnB1dCkgdGhpcy5oaWRkZW5GaWxlSW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmhpZGRlbkZpbGVJbnB1dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRkZW5GaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImZpbGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhGaWxlcyA9PT0gbnVsbCB8fCB0aGlzLm9wdGlvbnMubWF4RmlsZXMgPiAxKSB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBcIm11bHRpcGxlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LmNsYXNzTmFtZSA9IFwiZHotaGlkZGVuLWlucHV0XCI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY2NlcHRlZEZpbGVzICE9PSBudWxsKSB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJhY2NlcHRcIiwgdGhpcy5vcHRpb25zLmFjY2VwdGVkRmlsZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2FwdHVyZSAhPT0gbnVsbCkgdGhpcy5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwiY2FwdHVyZVwiLCB0aGlzLm9wdGlvbnMuY2FwdHVyZSk7XG4gICAgICAgICAgICAgICAgLy8gTWFraW5nIHN1cmUgdGhhdCBubyBvbmUgY2FuIFwidGFiXCIgaW50byB0aGlzIGZpZWxkLlxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgICAgICAgICAgICAgLy8gTm90IHNldHRpbmcgYGRpc3BsYXk9XCJub25lXCJgIGJlY2F1c2Ugc29tZSBicm93c2VycyBkb24ndCBhY2NlcHQgY2xpY2tzXG4gICAgICAgICAgICAgICAgLy8gb24gZWxlbWVudHMgdGhhdCBhcmVuJ3QgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS53aWR0aCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZ2V0RWxlbWVudCh0aGlzLm9wdGlvbnMuaGlkZGVuSW5wdXRDb250YWluZXIsIFwiaGlkZGVuSW5wdXRDb250YWluZXJcIikuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5GaWxlSW5wdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZmlsZXM6IGZpbGVzICB9ID0gdGhpcy5oaWRkZW5GaWxlSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGgpIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpdGhpcy5hZGRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJhZGRlZGZpbGVzXCIsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBIaWRkZW5GaWxlSW5wdXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXR1cEhpZGRlbkZpbGVJbnB1dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuVVJMID0gd2luZG93LlVSTCAhPT0gbnVsbCA/IHdpbmRvdy5VUkwgOiB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgICAvLyBTZXR1cCBhbGwgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBEcm9wem9uZSBvYmplY3QgaXRzZWxmLlxuICAgICAgICAvLyBUaGV5J3JlIG5vdCBpbiBAc2V0dXBFdmVudExpc3RlbmVycygpIGJlY2F1c2UgdGhleSBzaG91bGRuJ3QgYmUgcmVtb3ZlZFxuICAgICAgICAvLyBhZ2FpbiB3aGVuIHRoZSBkcm9wem9uZSBnZXRzIGRpc2FibGVkLlxuICAgICAgICBmb3IgKGxldCBldmVudE5hbWUgb2YgdGhpcy5ldmVudHMpdGhpcy5vbihldmVudE5hbWUsIHRoaXMub3B0aW9uc1tldmVudE5hbWVdKTtcbiAgICAgICAgdGhpcy5vbihcInVwbG9hZHByb2dyZXNzXCIsICgpPT50aGlzLnVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3MoKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLm9uKFwicmVtb3ZlZGZpbGVcIiwgKCk9PnRoaXMudXBkYXRlVG90YWxVcGxvYWRQcm9ncmVzcygpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMub24oXCJjYW5jZWxlZFwiLCAoZmlsZSk9PnRoaXMuZW1pdChcImNvbXBsZXRlXCIsIGZpbGUpXG4gICAgICAgICk7XG4gICAgICAgIC8vIEVtaXQgYSBgcXVldWVjb21wbGV0ZWAgZXZlbnQgaWYgYWxsIGZpbGVzIGZpbmlzaGVkIHVwbG9hZGluZy5cbiAgICAgICAgdGhpcy5vbihcImNvbXBsZXRlXCIsIChmaWxlKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QWRkZWRGaWxlcygpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmdldFVwbG9hZGluZ0ZpbGVzKCkubGVuZ3RoID09PSAwICYmIHRoaXMuZ2V0UXVldWVkRmlsZXMoKS5sZW5ndGggPT09IDApIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVmZXJyZWQgc28gdGhhdCBgcXVldWVjb21wbGV0ZWAgcmVhbGx5IHRyaWdnZXJzIGFmdGVyIGBjb21wbGV0ZWBcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpPT50aGlzLmVtaXQoXCJxdWV1ZWNvbXBsZXRlXCIpXG4gICAgICAgICAgICAsIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29udGFpbnNGaWxlcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci50eXBlcykgLy8gQmVjYXVzZSBlLmRhdGFUcmFuc2Zlci50eXBlcyBpcyBhbiBPYmplY3QgaW5cbiAgICAgICAgICAgIC8vIElFLCB3ZSBuZWVkIHRvIGl0ZXJhdGUgbGlrZSB0aGlzIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vIHVzaW5nIGUuZGF0YVRyYW5zZmVyLnR5cGVzLnNvbWUoKVxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGUuZGF0YVRyYW5zZmVyLnR5cGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIudHlwZXNbaV0gPT09IFwiRmlsZXNcIikgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBub1Byb3BhZ2F0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGZpbGVzLCB3ZSBkb24ndCB3YW50IHRvIHN0b3BcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0aW9uIHNvIHdlIGRvbid0IGludGVyZmVyZSB3aXRoIG90aGVyXG4gICAgICAgICAgICAvLyBkcmFnIGFuZCBkcm9wIGJlaGF2aW91ci5cbiAgICAgICAgICAgIGlmICghY29udGFpbnNGaWxlcyhlKSkgcmV0dXJuO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdzdGFydDogKGUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KFwiZHJhZ3N0YXJ0XCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkcmFnZW50ZXI6IChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJkcmFnZW50ZXJcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRyYWdvdmVyOiAoZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2VzIGl0IHBvc3NpYmxlIHRvIGRyYWcgZmlsZXMgZnJvbSBjaHJvbWUncyBkb3dubG9hZCBiYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk1MjY0MzAvZHJhZy1hbmQtZHJvcC1maWxlLXVwbG9hZHMtZnJvbS1jaHJvbWUtZG93bmxvYWRzLWJhclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGlzIHJlcXVpcmVkIHRvIHByZXZlbnQgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDExIChTQ1JJUFQ2NTUzNSBleGNlcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWZjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZjdCA9IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiID09PSBlZmN0IHx8IFwibGlua01vdmVcIiA9PT0gZWZjdCA/IFwibW92ZVwiIDogXCJjb3B5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBub1Byb3BhZ2F0aW9uKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImRyYWdvdmVyXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkcmFnbGVhdmU6IChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImRyYWdsZWF2ZVwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZHJvcDogKGUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBub1Byb3BhZ2F0aW9uKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcChlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2VuZDogKGUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KFwiZHJhZ2VuZFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmNsaWNrYWJsZUVsZW1lbnRzLmZvckVhY2goKGNsaWNrYWJsZUVsZW1lbnQpPT57XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogY2xpY2thYmxlRWxlbWVudCxcbiAgICAgICAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IChldnQpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHRoZSBhY3R1YWwgZHJvcHpvbmUgb3IgdGhlIG1lc3NhZ2UgZWxlbWVudCBzaG91bGQgdHJpZ2dlciBmaWxlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWNrYWJsZUVsZW1lbnQgIT09IHRoaXMuZWxlbWVudCB8fCBldnQudGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQgfHwgJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5lbGVtZW50SW5zaWRlKGV2dC50YXJnZXQsIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmR6LW1lc3NhZ2VcIikpKSB0aGlzLmhpZGRlbkZpbGVJbnB1dC5jbGljaygpOyAvLyBGb3J3YXJkIHRoZSBjbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5pdC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvLyBOb3QgZnVsbHkgdGVzdGVkIHlldFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbEZpbGVzKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5oaWRkZW5GaWxlSW5wdXQgIT0gbnVsbCA/IHRoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5GaWxlSW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5oaWRkZW5GaWxlSW5wdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnQuZHJvcHpvbmU7XG4gICAgICAgIHJldHVybiAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lmluc3RhbmNlcy5zcGxpY2UoJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgfVxuICAgIHVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGxldCB0b3RhbFVwbG9hZFByb2dyZXNzO1xuICAgICAgICBsZXQgdG90YWxCeXRlc1NlbnQgPSAwO1xuICAgICAgICBsZXQgdG90YWxCeXRlcyA9IDA7XG4gICAgICAgIGxldCBhY3RpdmVGaWxlcyA9IHRoaXMuZ2V0QWN0aXZlRmlsZXMoKTtcbiAgICAgICAgaWYgKGFjdGl2ZUZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZmlsZSBvZiB0aGlzLmdldEFjdGl2ZUZpbGVzKCkpe1xuICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXNTZW50ICs9IGZpbGUudXBsb2FkLmJ5dGVzU2VudDtcbiAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzICs9IGZpbGUudXBsb2FkLnRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxVcGxvYWRQcm9ncmVzcyA9IDEwMCAqIHRvdGFsQnl0ZXNTZW50IC8gdG90YWxCeXRlcztcbiAgICAgICAgfSBlbHNlIHRvdGFsVXBsb2FkUHJvZ3Jlc3MgPSAxMDA7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJ0b3RhbHVwbG9hZHByb2dyZXNzXCIsIHRvdGFsVXBsb2FkUHJvZ3Jlc3MsIHRvdGFsQnl0ZXMsIHRvdGFsQnl0ZXNTZW50KTtcbiAgICB9XG4gICAgLy8gQG9wdGlvbnMucGFyYW1OYW1lIGNhbiBiZSBhIGZ1bmN0aW9uIHRha2luZyBvbmUgcGFyYW1ldGVyIHJhdGhlciB0aGFuIGEgc3RyaW5nLlxuICAgIC8vIEEgcGFyYW1ldGVyIG5hbWUgZm9yIGEgZmlsZSBpcyBvYnRhaW5lZCBzaW1wbHkgYnkgY2FsbGluZyB0aGlzIHdpdGggYW4gaW5kZXggbnVtYmVyLlxuICAgIF9nZXRQYXJhbU5hbWUobikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbU5hbWUgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXMub3B0aW9ucy5wYXJhbU5hbWUobik7XG4gICAgICAgIGVsc2UgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5wYXJhbU5hbWV9JHt0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUgPyBgWyR7bn1dYCA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gSWYgQG9wdGlvbnMucmVuYW1lRmlsZSBpcyBhIGZ1bmN0aW9uLFxuICAgIC8vIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgdG8gcmVuYW1lIHRoZSBmaWxlLm5hbWUgYmVmb3JlIGFwcGVuZGluZyBpdCB0byB0aGUgZm9ybURhdGFcbiAgICBfcmVuYW1lRmlsZShmaWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlbmFtZUZpbGUgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZpbGUubmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlKGZpbGUpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgZm9ybSB0aGF0IGNhbiBiZSB1c2VkIGFzIGZhbGxiYWNrIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgRHJhZ25Ecm9wXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgZHJvcHpvbmUgaXMgYWxyZWFkeSBhIGZvcm0sIG9ubHkgdGhlIGlucHV0IGZpZWxkIGFuZCBidXR0b24gYXJlIHJldHVybmVkLiBPdGhlcndpc2UgYSBjb21wbGV0ZSBmb3JtIGVsZW1lbnQgaXMgcHJvdmlkZWQuXG4gICAgLy8gVGhpcyBjb2RlIGhhcyB0byBwYXNzIGluIElFNyA6KFxuICAgIGdldEZhbGxiYWNrRm9ybSgpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nRmFsbGJhY2ssIGZvcm07XG4gICAgICAgIGlmIChleGlzdGluZ0ZhbGxiYWNrID0gdGhpcy5nZXRFeGlzdGluZ0ZhbGxiYWNrKCkpIHJldHVybiBleGlzdGluZ0ZhbGxiYWNrO1xuICAgICAgICBsZXQgZmllbGRzU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJkei1mYWxsYmFja1wiPic7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGljdEZhbGxiYWNrVGV4dCkgZmllbGRzU3RyaW5nICs9IGA8cD4ke3RoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tUZXh0fTwvcD5gO1xuICAgICAgICBmaWVsZHNTdHJpbmcgKz0gYDxpbnB1dCB0eXBlPVwiZmlsZVwiIG5hbWU9XCIke3RoaXMuX2dldFBhcmFtTmFtZSgwKX1cIiAke3RoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSA/ICdtdWx0aXBsZT1cIm11bHRpcGxlXCInIDogdW5kZWZpbmVkfSAvPjxpbnB1dCB0eXBlPVwic3VibWl0XCIgdmFsdWU9XCJVcGxvYWQhXCI+PC9kaXY+YDtcbiAgICAgICAgbGV0IGZpZWxkcyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuY3JlYXRlRWxlbWVudChmaWVsZHNTdHJpbmcpO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgIT09IFwiRk9STVwiKSB7XG4gICAgICAgICAgICBmb3JtID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5jcmVhdGVFbGVtZW50KGA8Zm9ybSBhY3Rpb249XCIke3RoaXMub3B0aW9ucy51cmx9XCIgZW5jdHlwZT1cIm11bHRpcGFydC9mb3JtLWRhdGFcIiBtZXRob2Q9XCIke3RoaXMub3B0aW9ucy5tZXRob2R9XCI+PC9mb3JtPmApO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChmaWVsZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGVuY3R5cGUgYW5kIG1ldGhvZCBhdHRyaWJ1dGVzIGFyZSBzZXQgcHJvcGVybHlcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZXRob2RcIiwgdGhpcy5vcHRpb25zLm1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm0gIT0gbnVsbCA/IGZvcm0gOiBmaWVsZHM7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGZhbGxiYWNrIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QgYWxyZWFkeVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGhhcyB0byBwYXNzIGluIElFNyA6KFxuICAgIGdldEV4aXN0aW5nRmFsbGJhY2soKSB7XG4gICAgICAgIGxldCBnZXRGYWxsYmFjayA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBlbCBvZiBlbGVtZW50cyl7XG4gICAgICAgICAgICAgICAgaWYgKC8oXnwgKWZhbGxiYWNrKCR8ICkvLnRlc3QoZWwuY2xhc3NOYW1lKSkgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCB0YWdOYW1lIG9mIFtcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICBcImZvcm1cIlxuICAgICAgICBdKXtcbiAgICAgICAgICAgIHZhciBmYWxsYmFjaztcbiAgICAgICAgICAgIGlmIChmYWxsYmFjayA9IGdldEZhbGxiYWNrKHRoaXMuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKSkpIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBY3RpdmF0ZXMgYWxsIGxpc3RlbmVycyBzdG9yZWQgaW4gQGxpc3RlbmVyc1xuICAgIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5tYXAoKGVsZW1lbnRMaXN0ZW5lcnMpPT4oKCk9PntcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yKGxldCBldmVudCBpbiBlbGVtZW50TGlzdGVuZXJzLmV2ZW50cyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IGVsZW1lbnRMaXN0ZW5lcnMuZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudExpc3RlbmVycy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyBEZWFjdGl2YXRlcyBhbGwgbGlzdGVuZXJzIHN0b3JlZCBpbiBAbGlzdGVuZXJzXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5tYXAoKGVsZW1lbnRMaXN0ZW5lcnMpPT4oKCk9PntcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yKGxldCBldmVudCBpbiBlbGVtZW50TGlzdGVuZXJzLmV2ZW50cyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IGVsZW1lbnRMaXN0ZW5lcnMuZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudExpc3RlbmVycy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIGNhbmNlbHMgYWxsIGZpbGVzIGluIHRoZSBxdWV1ZSBvciBiZWluZyBwcm9jZXNzZWQuXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5jbGlja2FibGVFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KT0+ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotY2xpY2thYmxlXCIpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzLm1hcCgoZmlsZSk9PnRoaXMuY2FuY2VsVXBsb2FkKGZpbGUpXG4gICAgICAgICk7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCk9PmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWNsaWNrYWJsZVwiKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBuaWNlbHkgZm9ybWF0dGVkIGZpbGVzaXplXG4gICAgZmlsZXNpemUoc2l6ZSkge1xuICAgICAgICBsZXQgc2VsZWN0ZWRTaXplID0gMDtcbiAgICAgICAgbGV0IHNlbGVjdGVkVW5pdCA9IFwiYlwiO1xuICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGxldCB1bml0cyA9IFtcbiAgICAgICAgICAgICAgICBcInRiXCIsXG4gICAgICAgICAgICAgICAgXCJnYlwiLFxuICAgICAgICAgICAgICAgIFwibWJcIixcbiAgICAgICAgICAgICAgICBcImtiXCIsXG4gICAgICAgICAgICAgICAgXCJiXCJcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdW5pdHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGxldCB1bml0ID0gdW5pdHNbaV07XG4gICAgICAgICAgICAgICAgbGV0IGN1dG9mZiA9IE1hdGgucG93KHRoaXMub3B0aW9ucy5maWxlc2l6ZUJhc2UsIDQgLSBpKSAvIDEwO1xuICAgICAgICAgICAgICAgIGlmIChzaXplID49IGN1dG9mZikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFNpemUgPSBzaXplIC8gTWF0aC5wb3codGhpcy5vcHRpb25zLmZpbGVzaXplQmFzZSwgNCAtIGkpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFVuaXQgPSB1bml0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZFNpemUgPSBNYXRoLnJvdW5kKDEwICogc2VsZWN0ZWRTaXplKSAvIDEwOyAvLyBDdXR0aW5nIG9mIGRpZ2l0c1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPHN0cm9uZz4ke3NlbGVjdGVkU2l6ZX08L3N0cm9uZz4gJHt0aGlzLm9wdGlvbnMuZGljdEZpbGVTaXplVW5pdHNbc2VsZWN0ZWRVbml0XX1gO1xuICAgIH1cbiAgICAvLyBBZGRzIG9yIHJlbW92ZXMgdGhlIGBkei1tYXgtZmlsZXMtcmVhY2hlZGAgY2xhc3MgZnJvbSB0aGUgZm9ybS5cbiAgICBfdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXMgIT0gbnVsbCAmJiB0aGlzLmdldEFjY2VwdGVkRmlsZXMoKS5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heEZpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBY2NlcHRlZEZpbGVzKCkubGVuZ3RoID09PSB0aGlzLm9wdGlvbnMubWF4RmlsZXMpIHRoaXMuZW1pdChcIm1heGZpbGVzcmVhY2hlZFwiLCB0aGlzLmZpbGVzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LW1heC1maWxlcy1yZWFjaGVkXCIpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotbWF4LWZpbGVzLXJlYWNoZWRcIik7XG4gICAgfVxuICAgIGRyb3AoZSkge1xuICAgICAgICBpZiAoIWUuZGF0YVRyYW5zZmVyKSByZXR1cm47XG4gICAgICAgIHRoaXMuZW1pdChcImRyb3BcIiwgZSk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIEZpbGVMaXN0IHRvIGFuIEFycmF5XG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBJRTExXG4gICAgICAgIGxldCBmaWxlcyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoOyBpKyspZmlsZXNbaV0gPSBlLmRhdGFUcmFuc2Zlci5maWxlc1tpXTtcbiAgICAgICAgLy8gRXZlbiBpZiBpdCdzIGEgZm9sZGVyLCBmaWxlcy5sZW5ndGggd2lsbCBjb250YWluIHRoZSBmb2xkZXJzLlxuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBpdGVtczogaXRlbXMgIH0gPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGggJiYgaXRlbXNbMF0ud2Via2l0R2V0QXNFbnRyeSAhPSBudWxsKSAvLyBUaGUgYnJvd3NlciBzdXBwb3J0cyBkcm9wcGluZyBvZiBmb2xkZXJzLCBzbyBoYW5kbGUgaXRlbXMgaW5zdGVhZCBvZiBmaWxlc1xuICAgICAgICAgICAgdGhpcy5fYWRkRmlsZXNGcm9tSXRlbXMoaXRlbXMpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmhhbmRsZUZpbGVzKGZpbGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJhZGRlZGZpbGVzXCIsIGZpbGVzKTtcbiAgICB9XG4gICAgcGFzdGUoZSkge1xuICAgICAgICBpZiAoJDNlZDI2OWYyZjBmYjIyNGIkdmFyJF9fZ3VhcmRfXyhlICE9IG51bGwgPyBlLmNsaXBib2FyZERhdGEgOiB1bmRlZmluZWQsICh4KT0+eC5pdGVtc1xuICAgICAgICApID09IG51bGwpIHJldHVybjtcbiAgICAgICAgdGhpcy5lbWl0KFwicGFzdGVcIiwgZSk7XG4gICAgICAgIGxldCB7IGl0ZW1zOiBpdGVtcyAgfSA9IGUuY2xpcGJvYXJkRGF0YTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKTtcbiAgICB9XG4gICAgaGFuZGxlRmlsZXMoZmlsZXMpIHtcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcyl0aGlzLmFkZEZpbGUoZmlsZSk7XG4gICAgfVxuICAgIC8vIFdoZW4gYSBmb2xkZXIgaXMgZHJvcHBlZCAob3IgZmlsZXMgYXJlIHBhc3RlZCksIGl0ZW1zIG11c3QgYmUgaGFuZGxlZFxuICAgIC8vIGluc3RlYWQgb2YgZmlsZXMuXG4gICAgX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiAoKCk9PntcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgaXRlbXMpe1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS53ZWJraXRHZXRBc0VudHJ5ICE9IG51bGwgJiYgKGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHJlc3VsdC5wdXNoKHRoaXMuYWRkRmlsZShpdGVtLmdldEFzRmlsZSgpKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSAvLyBBcHBlbmQgYWxsIGZpbGVzIGZyb20gdGhhdCBkaXJlY3RvcnkgdG8gZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fYWRkRmlsZXNGcm9tRGlyZWN0b3J5KGVudHJ5LCBlbnRyeS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uZ2V0QXNGaWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ua2luZCA9PSBudWxsIHx8IGl0ZW0ua2luZCA9PT0gXCJmaWxlXCIpIHJlc3VsdC5wdXNoKHRoaXMuYWRkRmlsZShpdGVtLmdldEFzRmlsZSgpKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8vIEdvZXMgdGhyb3VnaCB0aGUgZGlyZWN0b3J5LCBhbmQgYWRkcyBlYWNoIGZpbGUgaXQgZmluZHMgcmVjdXJzaXZlbHlcbiAgICBfYWRkRmlsZXNGcm9tRGlyZWN0b3J5KGRpcmVjdG9yeSwgcGF0aCkge1xuICAgICAgICBsZXQgZGlyUmVhZGVyID0gZGlyZWN0b3J5LmNyZWF0ZVJlYWRlcigpO1xuICAgICAgICBsZXQgZXJyb3JIYW5kbGVyID0gKGVycm9yKT0+JDNlZDI2OWYyZjBmYjIyNGIkdmFyJF9fZ3VhcmRNZXRob2RfXyhjb25zb2xlLCBcImxvZ1wiLCAobyk9Pm8ubG9nKGVycm9yKVxuICAgICAgICAgICAgKVxuICAgICAgICA7XG4gICAgICAgIHZhciByZWFkRW50cmllcyA9ICgpPT57XG4gICAgICAgICAgICByZXR1cm4gZGlyUmVhZGVyLnJlYWRFbnRyaWVzKChlbnRyaWVzKT0+e1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNGaWxlKSBlbnRyeS5maWxlKChmaWxlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuRmlsZXMgJiYgZmlsZS5uYW1lLnN1YnN0cmluZygwLCAxKSA9PT0gXCIuXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZ1bGxQYXRoID0gYCR7cGF0aH0vJHtmaWxlLm5hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkgdGhpcy5fYWRkRmlsZXNGcm9tRGlyZWN0b3J5KGVudHJ5LCBgJHtwYXRofS8ke2VudHJ5Lm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2FsbCByZWFkRW50cmllcygpIGFnYWluLCBzaW5jZSBicm93c2VyIG9ubHkgaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCAxMDAgZW50cmllcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRGlyZWN0b3J5UmVhZGVyI3JlYWRFbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlYWRFbnRyaWVzKCk7XG4gICAgfVxuICAgIC8vIElmIGBkb25lKClgIGlzIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50IHRoZSBmaWxlIGlzIGFjY2VwdGVkXG4gICAgLy8gSWYgeW91IGNhbGwgaXQgd2l0aCBhbiBlcnJvciBtZXNzYWdlLCB0aGUgZmlsZSBpcyByZWplY3RlZFxuICAgIC8vIChUaGlzIGFsbG93cyBmb3IgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24pXG4gICAgLy9cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGNoZWNrcyB0aGUgZmlsZXNpemUsIGFuZCBpZiB0aGUgZmlsZS50eXBlIHBhc3NlcyB0aGVcbiAgICAvLyBgYWNjZXB0ZWRGaWxlc2AgY2hlY2suXG4gICAgYWNjZXB0KGZpbGUsIGRvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhGaWxlc2l6ZSAmJiBmaWxlLnNpemUgPiB0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUgKiAxMDQ4NTc2KSBkb25lKHRoaXMub3B0aW9ucy5kaWN0RmlsZVRvb0JpZy5yZXBsYWNlKFwie3tmaWxlc2l6ZX19XCIsIE1hdGgucm91bmQoZmlsZS5zaXplIC8gMTAyNCAvIDEwLjI0KSAvIDEwMCkucmVwbGFjZShcInt7bWF4RmlsZXNpemV9fVwiLCB0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUpKTtcbiAgICAgICAgZWxzZSBpZiAoISQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuaXNWYWxpZEZpbGUoZmlsZSwgdGhpcy5vcHRpb25zLmFjY2VwdGVkRmlsZXMpKSBkb25lKHRoaXMub3B0aW9ucy5kaWN0SW52YWxpZEZpbGVUeXBlKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heEZpbGVzICE9IG51bGwgJiYgdGhpcy5nZXRBY2NlcHRlZEZpbGVzKCkubGVuZ3RoID49IHRoaXMub3B0aW9ucy5tYXhGaWxlcykge1xuICAgICAgICAgICAgZG9uZSh0aGlzLm9wdGlvbnMuZGljdE1heEZpbGVzRXhjZWVkZWQucmVwbGFjZShcInt7bWF4RmlsZXN9fVwiLCB0aGlzLm9wdGlvbnMubWF4RmlsZXMpKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm1heGZpbGVzZXhjZWVkZWRcIiwgZmlsZSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLm9wdGlvbnMuYWNjZXB0LmNhbGwodGhpcywgZmlsZSwgZG9uZSk7XG4gICAgfVxuICAgIGFkZEZpbGUoZmlsZSkge1xuICAgICAgICBmaWxlLnVwbG9hZCA9IHtcbiAgICAgICAgICAgIHV1aWQ6ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkudXVpZHY0KCksXG4gICAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIHRvdGFsIHVwbG9hZCBzaXplIHRvIGZpbGUuc2l6ZSBmb3IgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgLy8gSXQncyBhY3R1YWwgZGlmZmVyZW50IHRoYW4gdGhlIHNpemUgdG8gYmUgdHJhbnNtaXR0ZWQuXG4gICAgICAgICAgICB0b3RhbDogZmlsZS5zaXplLFxuICAgICAgICAgICAgYnl0ZXNTZW50OiAwLFxuICAgICAgICAgICAgZmlsZW5hbWU6IHRoaXMuX3JlbmFtZUZpbGUoZmlsZSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICBmaWxlLnN0YXR1cyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuQURERUQ7XG4gICAgICAgIHRoaXMuZW1pdChcImFkZGVkZmlsZVwiLCBmaWxlKTtcbiAgICAgICAgdGhpcy5fZW5xdWV1ZVRodW1ibmFpbChmaWxlKTtcbiAgICAgICAgdGhpcy5hY2NlcHQoZmlsZSwgKGVycm9yKT0+e1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5hY2NlcHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yUHJvY2Vzc2luZyhbXG4gICAgICAgICAgICAgICAgICAgIGZpbGVcbiAgICAgICAgICAgICAgICBdLCBlcnJvcik7IC8vIFdpbGwgc2V0IHRoZSBmaWxlLnN0YXR1c1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlLmFjY2VwdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9RdWV1ZSkgdGhpcy5lbnF1ZXVlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgLy8gV2lsbCBzZXQgLmFjY2VwdGVkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFdyYXBwZXIgZm9yIGVucXVldWVGaWxlXG4gICAgZW5xdWV1ZUZpbGVzKGZpbGVzKSB7XG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpdGhpcy5lbnF1ZXVlRmlsZShmaWxlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVucXVldWVGaWxlKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkFEREVEICYmIGZpbGUuYWNjZXB0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5RVUVVRUQ7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpIHJldHVybiBzZXRUaW1lb3V0KCgpPT50aGlzLnByb2Nlc3NRdWV1ZSgpXG4gICAgICAgICAgICAsIDApOyAvLyBEZWZlcnJpbmcgdGhlIGNhbGxcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZmlsZSBjYW4ndCBiZSBxdWV1ZWQgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBvciB3YXMgcmVqZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBfZW5xdWV1ZVRodW1ibmFpbChmaWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3JlYXRlSW1hZ2VUaHVtYm5haWxzICYmIGZpbGUudHlwZS5tYXRjaCgvaW1hZ2UuKi8pICYmIGZpbGUuc2l6ZSA8PSB0aGlzLm9wdGlvbnMubWF4VGh1bWJuYWlsRmlsZXNpemUgKiAxMDQ4NTc2KSB7XG4gICAgICAgICAgICB0aGlzLl90aHVtYm5haWxRdWV1ZS5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCk9PnRoaXMuX3Byb2Nlc3NUaHVtYm5haWxRdWV1ZSgpXG4gICAgICAgICAgICAsIDApOyAvLyBEZWZlcnJpbmcgdGhlIGNhbGxcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1RodW1ibmFpbCB8fCB0aGlzLl90aHVtYm5haWxRdWV1ZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ1RodW1ibmFpbCA9IHRydWU7XG4gICAgICAgIGxldCBmaWxlID0gdGhpcy5fdGh1bWJuYWlsUXVldWUuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGh1bWJuYWlsKGZpbGUsIHRoaXMub3B0aW9ucy50aHVtYm5haWxXaWR0aCwgdGhpcy5vcHRpb25zLnRodW1ibmFpbEhlaWdodCwgdGhpcy5vcHRpb25zLnRodW1ibmFpbE1ldGhvZCwgdHJ1ZSwgKGRhdGFVcmwpPT57XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ0aHVtYm5haWxcIiwgZmlsZSwgZGF0YVVybCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzaW5nVGh1bWJuYWlsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDYW4gYmUgY2FsbGVkIGJ5IHRoZSB1c2VyIHRvIHJlbW92ZSBhIGZpbGVcbiAgICByZW1vdmVGaWxlKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORykgdGhpcy5jYW5jZWxVcGxvYWQoZmlsZSk7XG4gICAgICAgIHRoaXMuZmlsZXMgPSAkM2VkMjY5ZjJmMGZiMjI0YiR2YXIkd2l0aG91dCh0aGlzLmZpbGVzLCBmaWxlKTtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlZGZpbGVcIiwgZmlsZSk7XG4gICAgICAgIGlmICh0aGlzLmZpbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuZW1pdChcInJlc2V0XCIpO1xuICAgIH1cbiAgICAvLyBSZW1vdmVzIGFsbCBmaWxlcyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgcHJvY2Vzc2VkIGZyb20gdGhlIGxpc3RcbiAgICByZW1vdmVBbGxGaWxlcyhjYW5jZWxJZk5lY2Vzc2FyeSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIGZpbGVzIHNpbmNlIHJlbW92ZUZpbGUoKSBjaGFuZ2VzIHRoZSBAZmlsZXMgYXJyYXkuXG4gICAgICAgIGlmIChjYW5jZWxJZk5lY2Vzc2FyeSA9PSBudWxsKSBjYW5jZWxJZk5lY2Vzc2FyeSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIHRoaXMuZmlsZXMuc2xpY2UoKSlpZiAoZmlsZS5zdGF0dXMgIT09ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuVVBMT0FESU5HIHx8IGNhbmNlbElmTmVjZXNzYXJ5KSB0aGlzLnJlbW92ZUZpbGUoZmlsZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXNpemVzIGFuIGltYWdlIGJlZm9yZSBpdCBnZXRzIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhpcyBmdW5jdGlvbiBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxuICAgIC8vIGBvcHRpb25zLnRyYW5zZm9ybUZpbGVgIGlmIGByZXNpemVXaWR0aGAgb3IgYHJlc2l6ZUhlaWdodGAgYXJlIHNldC4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWQgd2l0aFxuICAgIC8vIHRoZSByZXNpemVkIGJsb2IuXG4gICAgcmVzaXplSW1hZ2UoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUaHVtYm5haWwoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kLCB0cnVlLCAoZGF0YVVybCwgY2FudmFzKT0+e1xuICAgICAgICAgICAgaWYgKGNhbnZhcyA9PSBudWxsKSAvLyBUaGUgaW1hZ2UgaGFzIG5vdCBiZWVuIHJlc2l6ZWRcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhmaWxlKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IHJlc2l6ZU1pbWVUeXBlOiByZXNpemVNaW1lVHlwZSAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplTWltZVR5cGUgPT0gbnVsbCkgcmVzaXplTWltZVR5cGUgPSBmaWxlLnR5cGU7XG4gICAgICAgICAgICAgICAgbGV0IHJlc2l6ZWREYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTChyZXNpemVNaW1lVHlwZSwgdGhpcy5vcHRpb25zLnJlc2l6ZVF1YWxpdHkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVNaW1lVHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIgfHwgcmVzaXplTWltZVR5cGUgPT09IFwiaW1hZ2UvanBnXCIpIC8vIE5vdyBhZGQgdGhlIG9yaWdpbmFsIEVYSUYgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICByZXNpemVkRGF0YVVSTCA9ICQzZWQyNjlmMmYwZmIyMjRiJHZhciRFeGlmUmVzdG9yZS5yZXN0b3JlKGZpbGUuZGF0YVVSTCwgcmVzaXplZERhdGFVUkwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmRhdGFVUkl0b0Jsb2IocmVzaXplZERhdGFVUkwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVRodW1ibmFpbChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QsIGZpeE9yaWVudGF0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCk9PntcbiAgICAgICAgICAgIGZpbGUuZGF0YVVSTCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNyZWF0aW5nIGEgdGh1bWJuYWlsIGZvciBTVkcgaW1hZ2VzIHNpbmNlIHRoZXkncmUgdmVjdG9yXG4gICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSBjYWxsYmFjayhmaWxlUmVhZGVyLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUaHVtYm5haWxGcm9tVXJsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgZml4T3JpZW50YXRpb24sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgIH1cbiAgICAvLyBgbW9ja0ZpbGVgIG5lZWRzIHRvIGhhdmUgdGhlc2UgYXR0cmlidXRlczpcbiAgICAvL1xuICAgIC8vICAgICB7IG5hbWU6ICduYW1lJywgc2l6ZTogMTIzNDUsIGltYWdlVXJsOiAnJyB9XG4gICAgLy9cbiAgICAvLyBgY2FsbGJhY2tgIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBpbWFnZSBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCBkaXNwbGF5ZWQuXG4gICAgLy8gYGNyb3NzT3JpZ2luYCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBgaW1nYCB0YWcgd2hlbiBhY2Nlc3NpbmcgdGhlIGZpbGUuXG4gICAgZGlzcGxheUV4aXN0aW5nRmlsZShtb2NrRmlsZSwgaW1hZ2VVcmwsIGNhbGxiYWNrLCBjcm9zc09yaWdpbiwgcmVzaXplVGh1bWJuYWlsID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJhZGRlZGZpbGVcIiwgbW9ja0ZpbGUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCBtb2NrRmlsZSk7XG4gICAgICAgIGlmICghcmVzaXplVGh1bWJuYWlsKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ0aHVtYm5haWxcIiwgbW9ja0ZpbGUsIGltYWdlVXJsKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvbkRvbmUgPSAodGh1bWJuYWlsKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInRodW1ibmFpbFwiLCBtb2NrRmlsZSwgdGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW9ja0ZpbGUuZGF0YVVSTCA9IGltYWdlVXJsO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUaHVtYm5haWxGcm9tVXJsKG1vY2tGaWxlLCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsV2lkdGgsIHRoaXMub3B0aW9ucy50aHVtYm5haWxIZWlnaHQsIHRoaXMub3B0aW9ucy50aHVtYm5haWxNZXRob2QsIHRoaXMub3B0aW9ucy5maXhPcmllbnRhdGlvbiwgb25Eb25lLCBjcm9zc09yaWdpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlVGh1bWJuYWlsRnJvbVVybChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QsIGZpeE9yaWVudGF0aW9uLCBjYWxsYmFjaywgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgLy8gTm90IHVzaW5nIGBuZXcgSW1hZ2VgIGhlcmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBsYXRlc3QgQ2hyb21lIHZlcnNpb25zLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VueW8vZHJvcHpvbmUvcHVsbC8yMjZcbiAgICAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGlmIChjcm9zc09yaWdpbikgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICAgIC8vIGZpeE9yaWVudGF0aW9uIGlzIG5vdCBuZWVkZWQgYW55bW9yZSB3aXRoIGJyb3dzZXJzIGhhbmRsaW5nIGltYWdlT3JpZW50YXRpb25cbiAgICAgICAgZml4T3JpZW50YXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpW1wiaW1hZ2VPcmllbnRhdGlvblwiXSA9PSBcImZyb20taW1hZ2VcIiA/IGZhbHNlIDogZml4T3JpZW50YXRpb247XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKT0+e1xuICAgICAgICAgICAgbGV0IGxvYWRFeGlmID0gKGNhbGxiYWNrKT0+Y2FsbGJhY2soMSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRVhJRiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFWElGICE9PSBudWxsICYmIGZpeE9yaWVudGF0aW9uKSBsb2FkRXhpZiA9IChjYWxsYmFjayk9PkVYSUYuZ2V0RGF0YShpbWcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRVhJRi5nZXRUYWcodGhpcywgXCJPcmllbnRhdGlvblwiKSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJldHVybiBsb2FkRXhpZigob3JpZW50YXRpb24pPT57XG4gICAgICAgICAgICAgICAgZmlsZS53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgICAgICBmaWxlLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlc2l6ZUluZm8gPSB0aGlzLm9wdGlvbnMucmVzaXplLmNhbGwodGhpcywgZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kKTtcbiAgICAgICAgICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSByZXNpemVJbmZvLnRyZ1dpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZXNpemVJbmZvLnRyZ0hlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHJlc2l6ZUluZm8udHJnSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVzaXplSW5mby50cmdXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoKG9yaWVudGF0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy53aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE4MMKwIHJvdGF0ZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsIGZsaXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlcnRpY2FsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDkwwrAgcm90YXRlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAtY2FudmFzLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBob3Jpem9udGFsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy5oZWlnaHQsIC1jYW52YXMud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA5MMKwIHJvdGF0ZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC0wLjUgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWNhbnZhcy5oZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBidWdmaXggZm9yIGlPUycgc2NhbGluZyBidWcuXG4gICAgICAgICAgICAgICAgJDNlZDI2OWYyZjBmYjIyNGIkdmFyJGRyYXdJbWFnZUlPU0ZpeChjdHgsIGltZywgcmVzaXplSW5mby5zcmNYICE9IG51bGwgPyByZXNpemVJbmZvLnNyY1ggOiAwLCByZXNpemVJbmZvLnNyY1kgIT0gbnVsbCA/IHJlc2l6ZUluZm8uc3JjWSA6IDAsIHJlc2l6ZUluZm8uc3JjV2lkdGgsIHJlc2l6ZUluZm8uc3JjSGVpZ2h0LCByZXNpemVJbmZvLnRyZ1ggIT0gbnVsbCA/IHJlc2l6ZUluZm8udHJnWCA6IDAsIHJlc2l6ZUluZm8udHJnWSAhPSBudWxsID8gcmVzaXplSW5mby50cmdZIDogMCwgcmVzaXplSW5mby50cmdXaWR0aCwgcmVzaXplSW5mby50cmdIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxldCB0aHVtYm5haWwgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSByZXR1cm4gY2FsbGJhY2sodGh1bWJuYWlsLCBjYW52YXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSBpbWcub25lcnJvciA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gaW1nLnNyYyA9IGZpbGUuZGF0YVVSTDtcbiAgICB9XG4gICAgLy8gR29lcyB0aHJvdWdoIHRoZSBxdWV1ZSBhbmQgcHJvY2Vzc2VzIGZpbGVzIGlmIHRoZXJlIGFyZW4ndCB0b28gbWFueSBhbHJlYWR5LlxuICAgIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgbGV0IHsgcGFyYWxsZWxVcGxvYWRzOiBwYXJhbGxlbFVwbG9hZHMgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGxldCBwcm9jZXNzaW5nTGVuZ3RoID0gdGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpLmxlbmd0aDtcbiAgICAgICAgbGV0IGkgPSBwcm9jZXNzaW5nTGVuZ3RoO1xuICAgICAgICAvLyBUaGVyZSBhcmUgYWxyZWFkeSBhdCBsZWFzdCBhcyBtYW55IGZpbGVzIHVwbG9hZGluZyB0aGFuIHNob3VsZCBiZVxuICAgICAgICBpZiAocHJvY2Vzc2luZ0xlbmd0aCA+PSBwYXJhbGxlbFVwbG9hZHMpIHJldHVybjtcbiAgICAgICAgbGV0IHF1ZXVlZEZpbGVzID0gdGhpcy5nZXRRdWV1ZWRGaWxlcygpO1xuICAgICAgICBpZiAoIShxdWV1ZWRGaWxlcy5sZW5ndGggPiAwKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSAvLyBUaGUgZmlsZXMgc2hvdWxkIGJlIHVwbG9hZGVkIGluIG9uZSByZXF1ZXN0XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaWxlcyhxdWV1ZWRGaWxlcy5zbGljZSgwLCBwYXJhbGxlbFVwbG9hZHMgLSBwcm9jZXNzaW5nTGVuZ3RoKSk7XG4gICAgICAgIGVsc2Ugd2hpbGUoaSA8IHBhcmFsbGVsVXBsb2Fkcyl7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlZEZpbGVzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgIC8vIE5vdGhpbmcgbGVmdCB0byBwcm9jZXNzXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NGaWxlKHF1ZXVlZEZpbGVzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdyYXBwZXIgZm9yIGBwcm9jZXNzRmlsZXNgXG4gICAgcHJvY2Vzc0ZpbGUoZmlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRmlsZXMoW1xuICAgICAgICAgICAgZmlsZVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gTG9hZHMgdGhlIGZpbGUsIHRoZW4gY2FsbHMgZmluaXNoZWRMb2FkaW5nKClcbiAgICBwcm9jZXNzRmlsZXMoZmlsZXMpIHtcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcyl7XG4gICAgICAgICAgICBmaWxlLnByb2Nlc3NpbmcgPSB0cnVlOyAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgZmlsZS5zdGF0dXMgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInByb2Nlc3NpbmdcIiwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkgdGhpcy5lbWl0KFwicHJvY2Vzc2luZ211bHRpcGxlXCIsIGZpbGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkRmlsZXMoZmlsZXMpO1xuICAgIH1cbiAgICBfZ2V0RmlsZXNXaXRoWGhyKHhocikge1xuICAgICAgICBsZXQgZmlsZXM7XG4gICAgICAgIHJldHVybiBmaWxlcyA9IHRoaXMuZmlsZXMuZmlsdGVyKChmaWxlKT0+ZmlsZS54aHIgPT09IHhoclxuICAgICAgICApLm1hcCgoZmlsZSk9PmZpbGVcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gQ2FuY2VscyB0aGUgZmlsZSB1cGxvYWQgYW5kIHNldHMgdGhlIHN0YXR1cyB0byBDQU5DRUxFRFxuICAgIC8vICoqaWYqKiB0aGUgZmlsZSBpcyBhY3R1YWxseSBiZWluZyB1cGxvYWRlZC5cbiAgICAvLyBJZiBpdCdzIHN0aWxsIGluIHRoZSBxdWV1ZSwgdGhlIGZpbGUgaXMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0IGFuZCB0aGUgc3RhdHVzXG4gICAgLy8gc2V0IHRvIENBTkNFTEVELlxuICAgIGNhbmNlbFVwbG9hZChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5VUExPQURJTkcpIHtcbiAgICAgICAgICAgIGxldCBncm91cGVkRmlsZXMgPSB0aGlzLl9nZXRGaWxlc1dpdGhYaHIoZmlsZS54aHIpO1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBlZEZpbGUgb2YgZ3JvdXBlZEZpbGVzKWdyb3VwZWRGaWxlLnN0YXR1cyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuQ0FOQ0VMRUQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGUueGhyICE9PSBcInVuZGVmaW5lZFwiKSBmaWxlLnhoci5hYm9ydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBlZEZpbGUxIG9mIGdyb3VwZWRGaWxlcyl0aGlzLmVtaXQoXCJjYW5jZWxlZFwiLCBncm91cGVkRmlsZTEpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkgdGhpcy5lbWl0KFwiY2FuY2VsZWRtdWx0aXBsZVwiLCBncm91cGVkRmlsZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUuc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkFEREVEIHx8IGZpbGUuc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlFVRVVFRCkge1xuICAgICAgICAgICAgZmlsZS5zdGF0dXMgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkNBTkNFTEVEO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2FuY2VsZWRcIiwgZmlsZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB0aGlzLmVtaXQoXCJjYW5jZWxlZG11bHRpcGxlXCIsIFtcbiAgICAgICAgICAgICAgICBmaWxlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpIHJldHVybiB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICByZXNvbHZlT3B0aW9uKG9wdGlvbiwgLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gb3B0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cbiAgICB1cGxvYWRGaWxlKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkRmlsZXMoW1xuICAgICAgICAgICAgZmlsZVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgdXBsb2FkRmlsZXMoZmlsZXMpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtRmlsZXMoZmlsZXMsICh0cmFuc2Zvcm1lZEZpbGVzKT0+e1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jaHVua2luZykge1xuICAgICAgICAgICAgICAgIC8vIENodW5raW5nIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgd2l0aCBgdXBsb2FkTXVsdGlwbGVgIHNvIHdlIGtub3dcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZXJlIGlzIG9ubHkgX19vbmVfX2ZpbGUuXG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkRmlsZSA9IHRyYW5zZm9ybWVkRmlsZXNbMF07XG4gICAgICAgICAgICAgICAgZmlsZXNbMF0udXBsb2FkLmNodW5rZWQgPSB0aGlzLm9wdGlvbnMuY2h1bmtpbmcgJiYgKHRoaXMub3B0aW9ucy5mb3JjZUNodW5raW5nIHx8IHRyYW5zZm9ybWVkRmlsZS5zaXplID4gdGhpcy5vcHRpb25zLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgZmlsZXNbMF0udXBsb2FkLnRvdGFsQ2h1bmtDb3VudCA9IE1hdGguY2VpbCh0cmFuc2Zvcm1lZEZpbGUuc2l6ZSAvIHRoaXMub3B0aW9ucy5jaHVua1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmaWxlIHNob3VsZCBiZSBzZW50IGluIGNodW5rcyFcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2h1bmtpbmcgb3B0aW9uIGlzIHNldCwgd2UgKiprbm93KiogdGhhdCB0aGVyZSBjYW4gb25seSBiZSAqKm9uZSoqIGZpbGUsIHNpbmNlXG4gICAgICAgICAgICAgICAgLy8gdXBsb2FkTXVsdGlwbGUgaXMgbm90IGFsbG93ZWQgd2l0aCB0aGlzIG9wdGlvbi5cbiAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGZpbGVzWzBdO1xuICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZEZpbGUgPSB0cmFuc2Zvcm1lZEZpbGVzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydGVkQ2h1bmtDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQuY2h1bmtzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZU5leHRDaHVuayA9ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCBpdGVtIGluIGZpbGUudXBsb2FkLmNodW5rcyB0aGF0IGlzIG5vdCBkZWZpbmVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoZmlsZS51cGxvYWQuY2h1bmtzW2NodW5rSW5kZXhdICE9PSB1bmRlZmluZWQpY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zLCB0aGF0IGFsbCBjaHVua3MgaGF2ZSBhbHJlYWR5IGJlZW4gc3RhcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rSW5kZXggPj0gZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWRDaHVua0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGNodW5rSW5kZXggKiB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4oc3RhcnQgKyB0aGlzLm9wdGlvbnMuY2h1bmtTaXplLCB0cmFuc2Zvcm1lZEZpbGUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhQmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9nZXRQYXJhbU5hbWUoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0cmFuc2Zvcm1lZEZpbGUud2Via2l0U2xpY2UgPyB0cmFuc2Zvcm1lZEZpbGUud2Via2l0U2xpY2Uoc3RhcnQsIGVuZCkgOiB0cmFuc2Zvcm1lZEZpbGUuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZS51cGxvYWQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua0luZGV4OiBjaHVua0luZGV4XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkLmNodW5rc1tjaHVua0luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY2h1bmtJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jazogZGF0YUJsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlVQTE9BRElORyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmllczogMFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhKGZpbGVzLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmxvY2tcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5maW5pc2hlZENodW5rVXBsb2FkID0gKGNodW5rLCByZXNwb25zZSk9PntcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbEZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5TVUNDRVNTO1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgZGF0YSBmcm9tIHRoZSBjaHVua1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5kYXRhQmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5yZXNwb25zZSA9IGNodW5rLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnJlc3BvbnNlSGVhZGVycyA9IGNodW5rLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVhdmluZyB0aGlzIHJlZmVyZW5jZSB0byB4aHIgd2lsbCBjYXVzZSBtZW1vcnkgbGVha3MuXG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnhociA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS51cGxvYWQuY2h1bmtzW2ldID09PSB1bmRlZmluZWQpIHJldHVybiBoYW5kbGVOZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0uc3RhdHVzICE9PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlNVQ0NFU1MpIGFsbEZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbEZpbmlzaGVkKSB0aGlzLm9wdGlvbnMuY2h1bmtzVXBsb2FkZWQoZmlsZSwgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkKGZpbGVzLCByZXNwb25zZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbGxlbENodW5rVXBsb2FkcykgZm9yKGxldCBpID0gMDsgaSA8IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDsgaSsrKWhhbmRsZU5leHRDaHVuaygpO1xuICAgICAgICAgICAgICAgIGVsc2UgaGFuZGxlTmV4dENodW5rKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhQmxvY2tzID0gW107XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKWRhdGFCbG9ja3NbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX2dldFBhcmFtTmFtZShpKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdHJhbnNmb3JtZWRGaWxlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVzW2ldLnVwbG9hZC5maWxlbmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YShmaWxlcywgZGF0YUJsb2Nrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgcmlnaHQgY2h1bmsgZm9yIGdpdmVuIGZpbGUgYW5kIHhoclxuICAgIF9nZXRDaHVuayhmaWxlLCB4aHIpIHtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDsgaSsrKXtcbiAgICAgICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0gIT09IHVuZGVmaW5lZCAmJiBmaWxlLnVwbG9hZC5jaHVua3NbaV0ueGhyID09PSB4aHIpIHJldHVybiBmaWxlLnVwbG9hZC5jaHVua3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY3R1YWxseSB1cGxvYWRzIHRoZSBmaWxlKHMpIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy9cbiAgICAvLyAgSWYgZGF0YUJsb2NrcyBjb250YWlucyB0aGUgYWN0dWFsIGRhdGEgdG8gdXBsb2FkIChtZWFuaW5nLCB0aGF0IHRoaXMgY291bGRcbiAgICAvLyBlaXRoZXIgYmUgdHJhbnNmb3JtZWQgZmlsZXMsIG9yIGluZGl2aWR1YWwgY2h1bmtzIGZvciBjaHVua2VkIHVwbG9hZCkgdGhlblxuICAgIC8vIHRoZXkgd2lsbCBiZSB1c2VkIGZvciB0aGUgYWN0dWFsIGRhdGEgdG8gdXBsb2FkLlxuICAgIF91cGxvYWREYXRhKGZpbGVzLCBkYXRhQmxvY2tzKSB7XG4gICAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgLy8gUHV0IHRoZSB4aHIgb2JqZWN0IGluIHRoZSBmaWxlIG9iamVjdHMgdG8gYmUgYWJsZSB0byByZWZlcmVuY2UgaXQgbGF0ZXIuXG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpZmlsZS54aHIgPSB4aHI7XG4gICAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCkgLy8gUHV0IHRoZSB4aHIgb2JqZWN0IGluIHRoZSByaWdodCBjaHVuayBvYmplY3QsIHNvIGl0IGNhbiBiZSBhc3NvY2lhdGVkXG4gICAgICAgIC8vIGxhdGVyLCBhbmQgZm91bmQgd2l0aCBfZ2V0Q2h1bmsuXG4gICAgICAgIGZpbGVzWzBdLnVwbG9hZC5jaHVua3NbZGF0YUJsb2Nrc1swXS5jaHVua0luZGV4XS54aHIgPSB4aHI7XG4gICAgICAgIGxldCBtZXRob2QgPSB0aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLm1ldGhvZCwgZmlsZXMsIGRhdGFCbG9ja3MpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy5yZXNvbHZlT3B0aW9uKHRoaXMub3B0aW9ucy51cmwsIGZpbGVzLCBkYXRhQmxvY2tzKTtcbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICAvLyBTZXR0aW5nIHRoZSB0aW1lb3V0IGFmdGVyIG9wZW4gYmVjYXVzZSBvZiBJRTExIGlzc3VlOiBodHRwczovL2dpdGxhYi5jb20vbWVuby9kcm9wem9uZS9pc3N1ZXMvOFxuICAgICAgICBsZXQgdGltZW91dCA9IHRoaXMucmVzb2x2ZU9wdGlvbih0aGlzLm9wdGlvbnMudGltZW91dCwgZmlsZXMpO1xuICAgICAgICBpZiAodGltZW91dCkgeGhyLnRpbWVvdXQgPSB0aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLnRpbWVvdXQsIGZpbGVzKTtcbiAgICAgICAgLy8gSGFzIHRvIGJlIGFmdGVyIGAub3BlbigpYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbnlvL2Ryb3B6b25lL2lzc3Vlcy8xNzlcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhdGhpcy5vcHRpb25zLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgeGhyLm9ubG9hZCA9IChlKT0+e1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWRVcGxvYWRpbmcoZmlsZXMsIHhociwgZSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSAoKT0+e1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhociwgYFJlcXVlc3QgdGltZWRvdXQgYWZ0ZXIgJHt0aGlzLm9wdGlvbnMudGltZW91dCAvIDEwMDB9IHNlY29uZHNgKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSAoKT0+e1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhocik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IGhhdmUgdGhlIC51cGxvYWQgcHJvcGVydHlcbiAgICAgICAgbGV0IHByb2dyZXNzT2JqID0geGhyLnVwbG9hZCAhPSBudWxsID8geGhyLnVwbG9hZCA6IHhocjtcbiAgICAgICAgcHJvZ3Jlc3NPYmoub25wcm9ncmVzcyA9IChlKT0+dGhpcy5fdXBkYXRlRmlsZXNVcGxvYWRQcm9ncmVzcyhmaWxlcywgeGhyLCBlKVxuICAgICAgICA7XG4gICAgICAgIGxldCBoZWFkZXJzID0gdGhpcy5vcHRpb25zLmRlZmF1bHRIZWFkZXJzID8ge1xuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIFwiQ2FjaGUtQ29udHJvbFwiOiBcIm5vLWNhY2hlXCIsXG4gICAgICAgICAgICBcIlgtUmVxdWVzdGVkLVdpdGhcIjogXCJYTUxIdHRwUmVxdWVzdFwiXG4gICAgICAgIH0gOiB7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmluYXJ5Qm9keSkgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IGZpbGVzWzBdLnR5cGU7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycykgJGV3Qkt5JGp1c3RleHRlbmQoaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBmb3IobGV0IGhlYWRlck5hbWUgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBoZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgICAgICAgaWYgKGhlYWRlclZhbHVlKSB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iaW5hcnlCb2R5KSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgZmlsZSBpcyBnb2luZyB0byBiZSBzZW50IGFzIGJpbmFyeSBib2R5LCBpdCBkb2Vzbid0IG1ha2VcbiAgICAgICAgICAgIC8vIGFueSBzZW5zZSB0byBnZW5lcmF0ZSBgRm9ybURhdGFgIGZvciBpdC5cbiAgICAgICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpdGhpcy5lbWl0KFwic2VuZGluZ1wiLCBmaWxlLCB4aHIpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkgdGhpcy5lbWl0KFwic2VuZGluZ211bHRpcGxlXCIsIGZpbGVzLCB4aHIpO1xuICAgICAgICAgICAgdGhpcy5zdWJtaXRSZXF1ZXN0KHhociwgbnVsbCwgZmlsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAvLyBBZGRpbmcgYWxsIEBvcHRpb25zIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZGl0aW9uYWxQYXJhbXMgPSB0aGlzLm9wdGlvbnMucGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbFBhcmFtcyA9PT0gXCJmdW5jdGlvblwiKSBhZGRpdGlvbmFsUGFyYW1zID0gYWRkaXRpb25hbFBhcmFtcy5jYWxsKHRoaXMsIGZpbGVzLCB4aHIsIGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkID8gdGhpcy5fZ2V0Q2h1bmsoZmlsZXNbMF0sIHhocikgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGtleSBpbiBhZGRpdGlvbmFsUGFyYW1zKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYWRkaXRpb25hbFBhcmFtc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIC8vIFRoZSBhZGRpdGlvbmFsIHBhcmFtZXRlciBjb250YWlucyBhbiBhcnJheSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbGV0cyBpdGVyYXRlIG92ZXIgaXQgdG8gYXR0YWNoIGVhY2ggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kaXZpZHVhbGx5LlxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZXQgdGhlIHVzZXIgYWRkIGFkZGl0aW9uYWwgZGF0YSBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpdGhpcy5lbWl0KFwic2VuZGluZ1wiLCBmaWxlLCB4aHIsIGZvcm1EYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHRoaXMuZW1pdChcInNlbmRpbmdtdWx0aXBsZVwiLCBmaWxlcywgeGhyLCBmb3JtRGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRGb3JtRWxlbWVudERhdGEoZm9ybURhdGEpO1xuICAgICAgICAgICAgLy8gRmluYWxseSBhZGQgdGhlIGZpbGVzXG4gICAgICAgICAgICAvLyBIYXMgdG8gYmUgbGFzdCBiZWNhdXNlIHNvbWUgc2VydmVycyAoZWc6IFMzKSBleHBlY3QgdGhlIGZpbGUgdG8gYmUgdGhlIGxhc3QgcGFyYW1ldGVyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGF0YUJsb2Nrcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFCbG9jayA9IGRhdGFCbG9ja3NbaV07XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGRhdGFCbG9jay5uYW1lLCBkYXRhQmxvY2suZGF0YSwgZGF0YUJsb2NrLmZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3VibWl0UmVxdWVzdCh4aHIsIGZvcm1EYXRhLCBmaWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJhbnNmb3JtcyBhbGwgZmlsZXMgd2l0aCB0aGlzLm9wdGlvbnMudHJhbnNmb3JtRmlsZSBhbmQgaW52b2tlcyBkb25lIHdpdGggdGhlIHRyYW5zZm9ybWVkIGZpbGVzIHdoZW4gZG9uZS5cbiAgICBfdHJhbnNmb3JtRmlsZXMoZmlsZXMsIGRvbmUpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkRmlsZXMgPSBbXTtcbiAgICAgICAgLy8gQ2x1bXN5IHdheSBvZiBoYW5kbGluZyBhc3luY2hyb25vdXMgY2FsbHMsIHVudGlsIEkgZ2V0IHRvIGFkZCBhIHByb3BlciBGdXR1cmUgbGlicmFyeS5cbiAgICAgICAgbGV0IGRvbmVDb3VudGVyID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKXRoaXMub3B0aW9ucy50cmFuc2Zvcm1GaWxlLmNhbGwodGhpcywgZmlsZXNbaV0sICh0cmFuc2Zvcm1lZEZpbGUpPT57XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZEZpbGVzW2ldID0gdHJhbnNmb3JtZWRGaWxlO1xuICAgICAgICAgICAgaWYgKCsrZG9uZUNvdW50ZXIgPT09IGZpbGVzLmxlbmd0aCkgZG9uZSh0cmFuc2Zvcm1lZEZpbGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRha2VzIGNhcmUgb2YgYWRkaW5nIG90aGVyIGlucHV0IGVsZW1lbnRzIG9mIHRoZSBmb3JtIHRvIHRoZSBBSkFYIHJlcXVlc3RcbiAgICBfYWRkRm9ybUVsZW1lbnREYXRhKGZvcm1EYXRhKSB7XG4gICAgICAgIC8vIFRha2UgY2FyZSBvZiBvdGhlciBpbnB1dCBlbGVtZW50c1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgPT09IFwiRk9STVwiKSBmb3IgKGxldCBpbnB1dCBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBidXR0b25cIikpe1xuICAgICAgICAgICAgbGV0IGlucHV0TmFtZSA9IGlucHV0LmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBsZXQgaW5wdXRUeXBlID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgICAgIGlmIChpbnB1dFR5cGUpIGlucHV0VHlwZSA9IGlucHV0VHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIG5hbWUsIHdlIGNhbid0IHVzZSBpdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXROYW1lID09PSBcInVuZGVmaW5lZFwiIHx8IGlucHV0TmFtZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoaW5wdXQudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIiAmJiBpbnB1dC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSkge1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmx5IG11bHRpcGxlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBpbnB1dC5vcHRpb25zKWlmIChvcHRpb24uc2VsZWN0ZWQpIGZvcm1EYXRhLmFwcGVuZChpbnB1dE5hbWUsIG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dFR5cGUgfHwgaW5wdXRUeXBlICE9PSBcImNoZWNrYm94XCIgJiYgaW5wdXRUeXBlICE9PSBcInJhZGlvXCIgfHwgaW5wdXQuY2hlY2tlZCkgZm9ybURhdGEuYXBwZW5kKGlucHV0TmFtZSwgaW5wdXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEludm9rZWQgd2hlbiB0aGVyZSBpcyBuZXcgcHJvZ3Jlc3MgaW5mb3JtYXRpb24gYWJvdXQgZ2l2ZW4gZmlsZXMuXG4gICAgLy8gSWYgZSBpcyBub3QgcHJvdmlkZWQsIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdXBsb2FkIGlzIGZpbmlzaGVkLlxuICAgIF91cGRhdGVGaWxlc1VwbG9hZFByb2dyZXNzKGZpbGVzLCB4aHIsIGUpIHtcbiAgICAgICAgaWYgKCFmaWxlc1swXS51cGxvYWQuY2h1bmtlZCkgLy8gSGFuZGxlIGZpbGUgdXBsb2FkcyB3aXRob3V0IGNodW5raW5nXG4gICAgICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpe1xuICAgICAgICAgICAgaWYgKGZpbGUudXBsb2FkLnRvdGFsICYmIGZpbGUudXBsb2FkLmJ5dGVzU2VudCAmJiBmaWxlLnVwbG9hZC5ieXRlc1NlbnQgPT0gZmlsZS51cGxvYWQudG90YWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyA9IDEwMCAqIGUubG9hZGVkIC8gZS50b3RhbDtcbiAgICAgICAgICAgICAgICBmaWxlLnVwbG9hZC50b3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQuYnl0ZXNTZW50ID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIGV2ZW50LCBzbyB3ZSdyZSBhdCAxMDAlXG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQucHJvZ3Jlc3MgPSAxMDA7XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQuYnl0ZXNTZW50ID0gZmlsZS51cGxvYWQudG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGxvYWRwcm9ncmVzc1wiLCBmaWxlLCBmaWxlLnVwbG9hZC5wcm9ncmVzcywgZmlsZS51cGxvYWQuYnl0ZXNTZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBjaHVua2VkIGZpbGUgdXBsb2Fkc1xuICAgICAgICAgICAgLy8gQ2h1bmtlZCB1cGxvYWQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB1cGxvYWRpbmcgbXVsdGlwbGUgZmlsZXMgaW4gb25lXG4gICAgICAgICAgICAvLyByZXF1ZXN0LCBzbyB3ZSBrbm93IHRoZXJlJ3Mgb25seSBvbmUgZmlsZS5cbiAgICAgICAgICAgIGxldCBmaWxlID0gZmlsZXNbMF07XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgY2h1bmtlZCB1cGxvYWQsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBhcHByb3ByaWF0ZSBjaHVua1xuICAgICAgICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLl9nZXRDaHVuayhmaWxlLCB4aHIpO1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5wcm9ncmVzcyA9IDEwMCAqIGUubG9hZGVkIC8gZS50b3RhbDtcbiAgICAgICAgICAgICAgICBjaHVuay50b3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICAgICAgY2h1bmsuYnl0ZXNTZW50ID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIGV2ZW50LCBzbyB3ZSdyZSBhdCAxMDAlXG4gICAgICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSAxMDA7XG4gICAgICAgICAgICAgICAgY2h1bmsuYnl0ZXNTZW50ID0gY2h1bmsudG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgdGFsbHkgdGhlICpmaWxlKiB1cGxvYWQgcHJvZ3Jlc3MgZnJvbSBpdHMgaW5kaXZpZHVhbCBjaHVua3NcbiAgICAgICAgICAgIGZpbGUudXBsb2FkLnByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIGZpbGUudXBsb2FkLnRvdGFsID0gMDtcbiAgICAgICAgICAgIGZpbGUudXBsb2FkLmJ5dGVzU2VudCA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50OyBpKyspaWYgKGZpbGUudXBsb2FkLmNodW5rc1tpXSAmJiB0eXBlb2YgZmlsZS51cGxvYWQuY2h1bmtzW2ldLnByb2dyZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgZmlsZS51cGxvYWQucHJvZ3Jlc3MgKz0gZmlsZS51cGxvYWQuY2h1bmtzW2ldLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGZpbGUudXBsb2FkLnRvdGFsICs9IGZpbGUudXBsb2FkLmNodW5rc1tpXS50b3RhbDtcbiAgICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5ieXRlc1NlbnQgKz0gZmlsZS51cGxvYWQuY2h1bmtzW2ldLmJ5dGVzU2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBwcm9jZXNzIGlzIGEgcGVyY2VudGFnZSwgd2UgbmVlZCB0byBkaXZpZGUgYnkgdGhlIGFtb3VudCBvZlxuICAgICAgICAgICAgLy8gY2h1bmtzIHdlJ3ZlIHVzZWQuXG4gICAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyA9IGZpbGUudXBsb2FkLnByb2dyZXNzIC8gZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50O1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBsb2FkcHJvZ3Jlc3NcIiwgZmlsZSwgZmlsZS51cGxvYWQucHJvZ3Jlc3MsIGZpbGUudXBsb2FkLmJ5dGVzU2VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2ZpbmlzaGVkVXBsb2FkaW5nKGZpbGVzLCB4aHIsIGUpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBpZiAoZmlsZXNbMF0uc3RhdHVzID09PSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LkNBTkNFTEVEKSByZXR1cm47XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkgcmV0dXJuO1xuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSAhPT0gXCJhcnJheWJ1ZmZlclwiICYmIHhoci5yZXNwb25zZVR5cGUgIT09IFwiYmxvYlwiKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpICYmIH54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikpIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gXCJJbnZhbGlkIEpTT04gcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlRmlsZXNVcGxvYWRQcm9ncmVzcyhmaWxlcywgeGhyKTtcbiAgICAgICAgaWYgKCEoMjAwIDw9IHhoci5zdGF0dXMgJiYgeGhyLnN0YXR1cyA8IDMwMCkpIHRoaXMuX2hhbmRsZVVwbG9hZEVycm9yKGZpbGVzLCB4aHIsIHJlc3BvbnNlKTtcbiAgICAgICAgZWxzZSBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIGZpbGVzWzBdLnVwbG9hZC5maW5pc2hlZENodW5rVXBsb2FkKHRoaXMuX2dldENodW5rKGZpbGVzWzBdLCB4aHIpLCByZXNwb25zZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fZmluaXNoZWQoZmlsZXMsIHJlc3BvbnNlLCBlKTtcbiAgICB9XG4gICAgX2hhbmRsZVVwbG9hZEVycm9yKGZpbGVzLCB4aHIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChmaWxlc1swXS5zdGF0dXMgPT09ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuQ0FOQ0VMRUQpIHJldHVybjtcbiAgICAgICAgaWYgKGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkICYmIHRoaXMub3B0aW9ucy5yZXRyeUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGNodW5rID0gdGhpcy5fZ2V0Q2h1bmsoZmlsZXNbMF0sIHhocik7XG4gICAgICAgICAgICBpZiAoKGNodW5rLnJldHJpZXMrKykgPCB0aGlzLm9wdGlvbnMucmV0cnlDaHVua3NMaW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEoZmlsZXMsIFtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuZGF0YUJsb2NrXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGNvbnNvbGUud2FybihcIlJldHJpZWQgdGhpcyBjaHVuayB0b28gb2Z0ZW4uIEdpdmluZyB1cC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXJyb3JQcm9jZXNzaW5nKGZpbGVzLCByZXNwb25zZSB8fCB0aGlzLm9wdGlvbnMuZGljdFJlc3BvbnNlRXJyb3IucmVwbGFjZShcInt7c3RhdHVzQ29kZX19XCIsIHhoci5zdGF0dXMpLCB4aHIpO1xuICAgIH1cbiAgICBzdWJtaXRSZXF1ZXN0KHhociwgZm9ybURhdGEsIGZpbGVzKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPSAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW5ub3Qgc2VuZCB0aGlzIHJlcXVlc3QgYmVjYXVzZSB0aGUgWE1MSHR0cFJlcXVlc3QucmVhZHlTdGF0ZSBpcyBub3QgT1BFTkVELlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJpbmFyeUJvZHkpIHtcbiAgICAgICAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fZ2V0Q2h1bmsoZmlsZXNbMF0sIHhocik7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQoY2h1bmsuZGF0YUJsb2NrLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHhoci5zZW5kKGZpbGVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHhoci5zZW5kKGZvcm1EYXRhKTtcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiBwcm9jZXNzaW5nIGlzIGZpbmlzaGVkLlxuICAgIC8vIEluZGl2aWR1YWwgY2FsbGJhY2tzIGhhdmUgdG8gYmUgY2FsbGVkIGluIHRoZSBhcHByb3ByaWF0ZSBzZWN0aW9ucy5cbiAgICBfZmluaXNoZWQoZmlsZXMsIHJlc3BvbnNlVGV4dCwgZSkge1xuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKXtcbiAgICAgICAgICAgIGZpbGUuc3RhdHVzID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5TVUNDRVNTO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiLCBmaWxlLCByZXNwb25zZVRleHQsIGUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc211bHRpcGxlXCIsIGZpbGVzLCByZXNwb25zZVRleHQsIGUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVtdWx0aXBsZVwiLCBmaWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSByZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiBwcm9jZXNzaW5nIGlzIGZpbmlzaGVkLlxuICAgIC8vIEluZGl2aWR1YWwgY2FsbGJhY2tzIGhhdmUgdG8gYmUgY2FsbGVkIGluIHRoZSBhcHByb3ByaWF0ZSBzZWN0aW9ucy5cbiAgICBfZXJyb3JQcm9jZXNzaW5nKGZpbGVzLCBtZXNzYWdlLCB4aHIpIHtcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcyl7XG4gICAgICAgICAgICBmaWxlLnN0YXR1cyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuRVJST1I7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBmaWxlLCBtZXNzYWdlLCB4aHIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JtdWx0aXBsZVwiLCBmaWxlcywgbWVzc2FnZSwgeGhyKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlbXVsdGlwbGVcIiwgZmlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Byb2Nlc3NRdWV1ZSkgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIHN0YXRpYyB1dWlkdjQoKSB7XG4gICAgICAgIHJldHVybiBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PT0gXCJ4XCIgPyByIDogciAmIDMgfCA4O1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZWwsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBsZXQgZmFsbGJhY2ssIGxlZnQ7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsO1xuICAgICAgICB0aGlzLmNsaWNrYWJsZUVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZmlsZXMgPSBbXTsgLy8gQWxsIGZpbGVzXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5lbGVtZW50ID09PSBcInN0cmluZ1wiKSB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIC8vIE5vdCBjaGVja2luZyBpZiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudCBvciBFbGVtZW50IHNpbmNlIElFOSBpcyBleHRyZW1lbHkgd2VpcmQuXG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50IHx8IHRoaXMuZWxlbWVudC5ub2RlVHlwZSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRyb3B6b25lIGVsZW1lbnQuXCIpO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50LmRyb3B6b25lKSB0aHJvdyBuZXcgRXJyb3IoXCJEcm9wem9uZSBhbHJlYWR5IGF0dGFjaGVkLlwiKTtcbiAgICAgICAgLy8gTm93IGFkZCB0aGlzIGRyb3B6b25lIHRvIHRoZSBpbnN0YW5jZXMuXG4gICAgICAgICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgICAgIC8vIFB1dCB0aGUgZHJvcHpvbmUgaW5zaWRlIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgICAgdGhpcy5lbGVtZW50LmRyb3B6b25lID0gdGhpcztcbiAgICAgICAgbGV0IGVsZW1lbnRPcHRpb25zID0gKGxlZnQgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lm9wdGlvbnNGb3JFbGVtZW50KHRoaXMuZWxlbWVudCkpICE9IG51bGwgPyBsZWZ0IDoge1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkZXdCS3kkanVzdGV4dGVuZCh0cnVlLCB7XG4gICAgICAgIH0sICQ0Y2EzNjcxODI3NzZmODBiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzksIGVsZW1lbnRPcHRpb25zLCBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnByZXZpZXdUZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy5wcmV2aWV3VGVtcGxhdGUucmVwbGFjZSgvXFxuKi9nLCBcIlwiKTtcbiAgICAgICAgLy8gSWYgdGhlIGJyb3dzZXIgZmFpbGVkLCBqdXN0IGNhbGwgdGhlIGZhbGxiYWNrIGFuZCBsZWF2ZVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlRmFsbGJhY2sgfHwgISQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuaXNCcm93c2VyU3VwcG9ydGVkKCkpIHJldHVybiB0aGlzLm9wdGlvbnMuZmFsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gQG9wdGlvbnMudXJsID0gQGVsZW1lbnQuZ2V0QXR0cmlidXRlIFwiYWN0aW9uXCIgdW5sZXNzIEBvcHRpb25zLnVybD9cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cmwgPT0gbnVsbCkgdGhpcy5vcHRpb25zLnVybCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVybCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gVVJMIHByb3ZpZGVkLlwiKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY2NlcHRlZEZpbGVzICYmIHRoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcykgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IHByb3ZpZGUgYm90aCAnYWNjZXB0ZWRGaWxlcycgYW5kICdhY2NlcHRlZE1pbWVUeXBlcycuICdhY2NlcHRlZE1pbWVUeXBlcycgaXMgZGVwcmVjYXRlZC5cIik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUgJiYgdGhpcy5vcHRpb25zLmNodW5raW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHNldCBib3RoOiB1cGxvYWRNdWx0aXBsZSBhbmQgY2h1bmtpbmcuXCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJpbmFyeUJvZHkgJiYgdGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHNldCBib3RoOiBiaW5hcnlCb2R5IGFuZCB1cGxvYWRNdWx0aXBsZS5cIik7XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hY2NlcHRlZEZpbGVzID0gdGhpcy5vcHRpb25zLmFjY2VwdGVkTWltZVR5cGVzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlbmFtZUZpbGVuYW1lICE9IG51bGwpIHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlID0gKGZpbGUpPT50aGlzLm9wdGlvbnMucmVuYW1lRmlsZW5hbWUuY2FsbCh0aGlzLCBmaWxlLm5hbWUsIGZpbGUpXG4gICAgICAgIDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubWV0aG9kID09PSBcInN0cmluZ1wiKSB0aGlzLm9wdGlvbnMubWV0aG9kID0gdGhpcy5vcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoKGZhbGxiYWNrID0gdGhpcy5nZXRFeGlzdGluZ0ZhbGxiYWNrKCkpICYmIGZhbGxiYWNrLnBhcmVudE5vZGUpIC8vIFJlbW92ZSB0aGUgZmFsbGJhY2tcbiAgICAgICAgZmFsbGJhY2sucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmYWxsYmFjayk7XG4gICAgICAgIC8vIERpc3BsYXkgcHJldmlld3MgaW4gdGhlIHByZXZpZXdzQ29udGFpbmVyIGVsZW1lbnQgb3IgdGhlIERyb3B6b25lIGVsZW1lbnQgdW5sZXNzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmlld3NDb250YWluZXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZpZXdzQ29udGFpbmVyKSB0aGlzLnByZXZpZXdzQ29udGFpbmVyID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5nZXRFbGVtZW50KHRoaXMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lciwgXCJwcmV2aWV3c0NvbnRhaW5lclwiKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5wcmV2aWV3c0NvbnRhaW5lciA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUgPT09IHRydWUpIHRoaXMuY2xpY2thYmxlRWxlbWVudHMgPSBbXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmNsaWNrYWJsZUVsZW1lbnRzID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5nZXRFbGVtZW50cyh0aGlzLm9wdGlvbnMuY2xpY2thYmxlLCBcImNsaWNrYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG59XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmluaXRDbGFzcygpO1xuLy8gVGhpcyBpcyBhIG1hcCBvZiBvcHRpb25zIGZvciB5b3VyIGRpZmZlcmVudCBkcm9wem9uZXMuIEFkZCBjb25maWd1cmF0aW9uc1xuLy8gdG8gdGhpcyBvYmplY3QgZm9yIHlvdXIgZGlmZmVyZW50IGRyb3B6b25lIGVsZW1lbnMuXG4vL1xuLy8gRXhhbXBsZTpcbi8vXG4vLyAgICAgRHJvcHpvbmUub3B0aW9ucy5teURyb3B6b25lRWxlbWVudElkID0geyBtYXhGaWxlc2l6ZTogMSB9O1xuLy9cbi8vIEFuZCBpbiBodG1sOlxuLy9cbi8vICAgICA8Zm9ybSBhY3Rpb249XCIvdXBsb2FkXCIgaWQ9XCJteS1kcm9wem9uZS1lbGVtZW50LWlkXCIgY2xhc3M9XCJkcm9wem9uZVwiPjwvZm9ybT5cbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkub3B0aW9ucyA9IHtcbn07XG4vLyBSZXR1cm5zIHRoZSBvcHRpb25zIGZvciBhbiBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiBub25lIGF2YWlsYWJsZS5cbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkub3B0aW9uc0ZvckVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgLy8gR2V0IHRoZSBgRHJvcHpvbmUub3B0aW9ucy5lbGVtZW50SWRgIGZvciB0aGlzIGVsZW1lbnQgaWYgaXQgZXhpc3RzXG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIikpIHJldHVybiAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5Lm9wdGlvbnNbJDNlZDI2OWYyZjBmYjIyNGIkdmFyJGNhbWVsaXplKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIikpXTtcbiAgICBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLy8gSG9sZHMgYSBsaXN0IG9mIGFsbCBkcm9wem9uZSBpbnN0YW5jZXNcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuaW5zdGFuY2VzID0gW107XG4vLyBSZXR1cm5zIHRoZSBkcm9wem9uZSBmb3IgZ2l2ZW4gZWxlbWVudCBpZiBhbnlcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZm9yRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpO1xuICAgIGlmICgoZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5kcm9wem9uZSA6IHVuZGVmaW5lZCkgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gRHJvcHpvbmUgZm91bmQgZm9yIGdpdmVuIGVsZW1lbnQuIFRoaXMgaXMgcHJvYmFibHkgYmVjYXVzZSB5b3UncmUgdHJ5aW5nIHRvIGFjY2VzcyBpdCBiZWZvcmUgRHJvcHpvbmUgaGFkIHRoZSB0aW1lIHRvIGluaXRpYWxpemUuIFVzZSB0aGUgYGluaXRgIG9wdGlvbiB0byBzZXR1cCBhbnkgYWRkaXRpb25hbCBvYnNlcnZlcnMgb24geW91ciBEcm9wem9uZS5cIik7XG4gICAgcmV0dXJuIGVsZW1lbnQuZHJvcHpvbmU7XG59O1xuLy8gTG9va3MgZm9yIGFsbCAuZHJvcHpvbmUgZWxlbWVudHMgYW5kIGNyZWF0ZXMgYSBkcm9wem9uZSBmb3IgdGhlbVxuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5kaXNjb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBkcm9wem9uZXM7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIGRyb3B6b25lcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZHJvcHpvbmVcIik7XG4gICAgZWxzZSB7XG4gICAgICAgIGRyb3B6b25lcyA9IFtdO1xuICAgICAgICAvLyBJRSA6KFxuICAgICAgICBsZXQgY2hlY2tFbGVtZW50cyA9IChlbGVtZW50cyk9PigoKT0+e1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlbCBvZiBlbGVtZW50cylpZiAoLyhefCApZHJvcHpvbmUoJHwgKS8udGVzdChlbC5jbGFzc05hbWUpKSByZXN1bHQucHVzaChkcm9wem9uZXMucHVzaChlbCkpO1xuICAgICAgICAgICAgICAgIGVsc2UgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICA7XG4gICAgICAgIGNoZWNrRWxlbWVudHMoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikpO1xuICAgICAgICBjaGVja0VsZW1lbnRzKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZm9ybVwiKSk7XG4gICAgfVxuICAgIHJldHVybiAoKCk9PntcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkcm9wem9uZSBvZiBkcm9wem9uZXMpLy8gQ3JlYXRlIGEgZHJvcHpvbmUgdW5sZXNzIGF1dG8gZGlzY292ZXIgaGFzIGJlZW4gZGlzYWJsZWQgZm9yIHNwZWNpZmljIGVsZW1lbnRcbiAgICAgICAgaWYgKCQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkub3B0aW9uc0ZvckVsZW1lbnQoZHJvcHpvbmUpICE9PSBmYWxzZSkgcmVzdWx0LnB1c2gobmV3ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkoZHJvcHpvbmUpKTtcbiAgICAgICAgZWxzZSByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKCk7XG59O1xuLy8gU29tZSBicm93c2VycyBzdXBwb3J0IGRyYWcgYW5kIGRyb2cgZnVuY3Rpb25hbGl0eSwgYnV0IG5vdCBjb3JyZWN0bHkuXG4vL1xuLy8gU28gSSBjcmVhdGVkIGEgYmxvY2tsaXN0IG9mIHVzZXJBZ2VudHMuIFllcywgeWVzLiBCcm93c2VyIHNuaWZmaW5nLCBJIGtub3cuXG4vLyBCdXQgd2hhdCB0byBkbyB3aGVuIGJyb3dzZXJzICp0aGVvcmV0aWNhbGx5KiBzdXBwb3J0IGFuIEFQSSwgYnV0IGNyYXNoXG4vLyB3aGVuIHVzaW5nIGl0LlxuLy9cbi8vIFRoaXMgaXMgYSBsaXN0IG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGVzdGVkIGFnYWluc3QgbmF2aWdhdG9yLnVzZXJBZ2VudFxuLy9cbi8vICoqIEl0IHNob3VsZCBvbmx5IGJlIHVzZWQgb24gYnJvd3NlciB0aGF0ICpkbyogc3VwcG9ydCB0aGUgQVBJLCBidXRcbi8vIGluY29ycmVjdGx5ICoqXG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmJsb2NrZWRCcm93c2VycyA9IFtcbiAgICAvLyBUaGUgbWFjIG9zIGFuZCB3aW5kb3dzIHBob25lIHZlcnNpb24gb2Ygb3BlcmEgMTIgc2VlbXMgdG8gaGF2ZSBhIHByb2JsZW0gd2l0aCB0aGUgRmlsZSBkcmFnJ24nZHJvcCBBUEkuXG4gICAgL29wZXJhLiooTWFjaW50b3NofFdpbmRvd3MgUGhvbmUpLip2ZXJzaW9uXFwvMTIvaSwgXG5dO1xuLy8gQ2hlY2tzIGlmIHRoZSBicm93c2VyIGlzIHN1cHBvcnRlZFxuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5pc0Jyb3dzZXJTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgY2FwYWJsZUJyb3dzZXIgPSB0cnVlO1xuICAgIGlmICh3aW5kb3cuRmlsZSAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZUxpc3QgJiYgd2luZG93LkJsb2IgJiYgd2luZG93LkZvcm1EYXRhICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSkpIGNhcGFibGVCcm93c2VyID0gZmFsc2U7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuYmxhY2tsaXN0ZWRCcm93c2VycyAhPT0gdW5kZWZpbmVkKSAvLyBTaW5jZSB0aGlzIGhhcyBiZWVuIHJlbmFtZWQsIHRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndCBicmVhayBvbGRlclxuICAgICAgICAgICAgLy8gY29uZmlndXJhdGlvbi5cbiAgICAgICAgICAgICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuYmxvY2tlZEJyb3dzZXJzID0gJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5ibGFja2xpc3RlZEJyb3dzZXJzO1xuICAgICAgICAgICAgLy8gVGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSSwgYnV0IG1heSBiZSBibG9ja2VkLlxuICAgICAgICAgICAgZm9yIChsZXQgcmVnZXggb2YgJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5ibG9ja2VkQnJvd3NlcnMpaWYgKHJlZ2V4LnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICBjYXBhYmxlQnJvd3NlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGNhcGFibGVCcm93c2VyID0gZmFsc2U7XG4gICAgcmV0dXJuIGNhcGFibGVCcm93c2VyO1xufTtcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuZGF0YVVSSXRvQmxvYiA9IGZ1bmN0aW9uKGRhdGFVUkkpIHtcbiAgICAvLyBjb252ZXJ0IGJhc2U2NCB0byByYXcgYmluYXJ5IGRhdGEgaGVsZCBpbiBhIHN0cmluZ1xuICAgIC8vIGRvZXNuJ3QgaGFuZGxlIFVSTEVuY29kZWQgRGF0YVVSSXMgLSBzZWUgU08gYW5zd2VyICM2ODUwMjc2IGZvciBjb2RlIHRoYXQgZG9lcyB0aGlzXG4gICAgbGV0IGJ5dGVTdHJpbmcgPSBhdG9iKGRhdGFVUkkuc3BsaXQoXCIsXCIpWzFdKTtcbiAgICAvLyBzZXBhcmF0ZSBvdXQgdGhlIG1pbWUgY29tcG9uZW50XG4gICAgbGV0IG1pbWVTdHJpbmcgPSBkYXRhVVJJLnNwbGl0KFwiLFwiKVswXS5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdO1xuICAgIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyXG4gICAgbGV0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgICBsZXQgaWEgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgZm9yKGxldCBpID0gMCwgZW5kID0gYnl0ZVN0cmluZy5sZW5ndGgsIGFzYyA9IDAgPD0gZW5kOyBhc2MgPyBpIDw9IGVuZCA6IGkgPj0gZW5kOyBhc2MgPyBpKysgOiBpLS0paWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgLy8gd3JpdGUgdGhlIEFycmF5QnVmZmVyIHRvIGEgYmxvYlxuICAgIHJldHVybiBuZXcgQmxvYihbXG4gICAgICAgIGFiXG4gICAgXSwge1xuICAgICAgICB0eXBlOiBtaW1lU3RyaW5nXG4gICAgfSk7XG59O1xuLy8gUmV0dXJucyBhbiBhcnJheSB3aXRob3V0IHRoZSByZWplY3RlZCBpdGVtXG5jb25zdCAkM2VkMjY5ZjJmMGZiMjI0YiR2YXIkd2l0aG91dCA9IChsaXN0LCByZWplY3RlZEl0ZW0pPT5saXN0LmZpbHRlcigoaXRlbSk9Pml0ZW0gIT09IHJlamVjdGVkSXRlbVxuICAgICkubWFwKChpdGVtKT0+aXRlbVxuICAgIClcbjtcbi8vIGFiYy1kZWZfZ2hpIC0+IGFiY0RlZkdoaVxuY29uc3QgJDNlZDI2OWYyZjBmYjIyNGIkdmFyJGNhbWVsaXplID0gKHN0cik9PnN0ci5yZXBsYWNlKC9bXFwtX10oXFx3KS9nLCAobWF0Y2gpPT5tYXRjaC5jaGFyQXQoMSkudG9VcHBlckNhc2UoKVxuICAgIClcbjtcbi8vIENyZWF0ZXMgYW4gZWxlbWVudCBmcm9tIHN0cmluZ1xuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmlubmVySFRNTCA9IHN0cmluZztcbiAgICByZXR1cm4gZGl2LmNoaWxkTm9kZXNbMF07XG59O1xuLy8gVGVzdHMgaWYgZ2l2ZW4gZWxlbWVudCBpcyBpbnNpZGUgKG9yIHNpbXBseSBpcykgdGhlIGNvbnRhaW5lclxuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5lbGVtZW50SW5zaWRlID0gZnVuY3Rpb24oZWxlbWVudCwgY29udGFpbmVyKSB7XG4gICAgaWYgKGVsZW1lbnQgPT09IGNvbnRhaW5lcikgcmV0dXJuIHRydWU7XG4gICAgIC8vIENvZmZlZXNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgZG8vd2hpbGUgbG9vcHNcbiAgICB3aGlsZShlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlKXtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IGNvbnRhaW5lcikgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmdldEVsZW1lbnQgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgIGxldCBlbGVtZW50O1xuICAgIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBlbHNlIGlmIChlbC5ub2RlVHlwZSAhPSBudWxsKSBlbGVtZW50ID0gZWw7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFxcYCR7bmFtZX1cXGAgb3B0aW9uIHByb3ZpZGVkLiBQbGVhc2UgcHJvdmlkZSBhIENTUyBzZWxlY3RvciBvciBhIHBsYWluIEhUTUwgZWxlbWVudC5gKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbn07XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmdldEVsZW1lbnRzID0gZnVuY3Rpb24oZWxzLCBuYW1lKSB7XG4gICAgbGV0IGVsLCBlbGVtZW50cztcbiAgICBpZiAoZWxzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoZWwgb2YgZWxzKWVsZW1lbnRzLnB1c2godGhpcy5nZXRFbGVtZW50KGVsLCBuYW1lKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVscyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGVsIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxzKSllbGVtZW50cy5wdXNoKGVsKTtcbiAgICB9IGVsc2UgaWYgKGVscy5ub2RlVHlwZSAhPSBudWxsKSBlbGVtZW50cyA9IFtcbiAgICAgICAgZWxzXG4gICAgXTtcbiAgICBpZiAoZWxlbWVudHMgPT0gbnVsbCB8fCAhZWxlbWVudHMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXFxgJHtuYW1lfVxcYCBvcHRpb24gcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIGEgQ1NTIHNlbGVjdG9yLCBhIHBsYWluIEhUTUwgZWxlbWVudCBvciBhIGxpc3Qgb2YgdGhvc2UuYCk7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbi8vIEFza3MgdGhlIHVzZXIgdGhlIHF1ZXN0aW9uIGFuZCBjYWxscyBhY2NlcHRlZCBvciByZWplY3RlZCBhY2NvcmRpbmdseVxuLy9cbi8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3QgdXNlcyBgd2luZG93LmNvbmZpcm1gIGFuZCB0aGVuIGNhbGxzIHRoZVxuLy8gYXBwcm9wcmlhdGUgY2FsbGJhY2suXG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmNvbmZpcm0gPSBmdW5jdGlvbihxdWVzdGlvbiwgYWNjZXB0ZWQsIHJlamVjdGVkKSB7XG4gICAgaWYgKHdpbmRvdy5jb25maXJtKHF1ZXN0aW9uKSkgcmV0dXJuIGFjY2VwdGVkKCk7XG4gICAgZWxzZSBpZiAocmVqZWN0ZWQgIT0gbnVsbCkgcmV0dXJuIHJlamVjdGVkKCk7XG59O1xuLy8gVmFsaWRhdGVzIHRoZSBtaW1lIHR5cGUgbGlrZSB0aGlzOlxuLy9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L2lucHV0I2F0dHItYWNjZXB0XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LmlzVmFsaWRGaWxlID0gZnVuY3Rpb24oZmlsZSwgYWNjZXB0ZWRGaWxlcykge1xuICAgIGlmICghYWNjZXB0ZWRGaWxlcykgcmV0dXJuIHRydWU7XG4gICAgIC8vIElmIHRoZXJlIGFyZSBubyBhY2NlcHRlZCBtaW1lIHR5cGVzLCBpdCdzIE9LXG4gICAgYWNjZXB0ZWRGaWxlcyA9IGFjY2VwdGVkRmlsZXMuc3BsaXQoXCIsXCIpO1xuICAgIGxldCBtaW1lVHlwZSA9IGZpbGUudHlwZTtcbiAgICBsZXQgYmFzZU1pbWVUeXBlID0gbWltZVR5cGUucmVwbGFjZSgvXFwvLiokLywgXCJcIik7XG4gICAgZm9yIChsZXQgdmFsaWRUeXBlIG9mIGFjY2VwdGVkRmlsZXMpe1xuICAgICAgICB2YWxpZFR5cGUgPSB2YWxpZFR5cGUudHJpbSgpO1xuICAgICAgICBpZiAodmFsaWRUeXBlLmNoYXJBdCgwKSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIGlmIChmaWxlLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbGlkVHlwZS50b0xvd2VyQ2FzZSgpLCBmaWxlLm5hbWUubGVuZ3RoIC0gdmFsaWRUeXBlLmxlbmd0aCkgIT09IC0xKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICgvXFwvXFwqJC8udGVzdCh2YWxpZFR5cGUpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNvbWV0aGluZyBsaWtlIGEgaW1hZ2UvKiBtaW1lIHR5cGVcbiAgICAgICAgICAgIGlmIChiYXNlTWltZVR5cGUgPT09IHZhbGlkVHlwZS5yZXBsYWNlKC9cXC8uKiQvLCBcIlwiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWltZVR5cGUgPT09IHZhbGlkVHlwZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8vIEF1Z21lbnQgalF1ZXJ5XG5pZiAodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkgIT09IG51bGwpIGpRdWVyeS5mbi5kcm9wem9uZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkodGhpcywgb3B0aW9ucyk7XG4gICAgfSk7XG59O1xuLy8gRHJvcHpvbmUgZmlsZSBzdGF0dXMgY29kZXNcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuQURERUQgPSBcImFkZGVkXCI7XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlFVRVVFRCA9IFwicXVldWVkXCI7XG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIE5vdywgaWYgYSBmaWxlIGlzIGFjY2VwdGVkLCBpdCdzIGVpdGhlciBxdWV1ZWRcbi8vIG9yIHVwbG9hZGluZy5cbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuQUNDRVBURUQgPSAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlFVRVVFRDtcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuVVBMT0FESU5HID0gXCJ1cGxvYWRpbmdcIjtcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuUFJPQ0VTU0lORyA9ICQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuVVBMT0FESU5HOyAvLyBhbGlhc1xuJDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOS5DQU5DRUxFRCA9IFwiY2FuY2VsZWRcIjtcbiQzZWQyNjlmMmYwZmIyMjRiJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkuRVJST1IgPSBcImVycm9yXCI7XG4kM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5LlNVQ0NFU1MgPSBcInN1Y2Nlc3NcIjtcbi8qXG5cbiBCdWdmaXggZm9yIGlPUyA2IGFuZCA3XG4gU291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExOTI5MDk5L2h0bWw1LWNhbnZhcy1kcmF3aW1hZ2UtcmF0aW8tYnVnLWlvc1xuIGJhc2VkIG9uIHRoZSB3b3JrIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9zdG9taXRhL2lvcy1pbWFnZWZpbGUtbWVnYXBpeGVsXG5cbiAqLyAvLyBEZXRlY3RpbmcgdmVydGljYWwgc3F1YXNoIGluIGxvYWRlZCBpbWFnZS5cbi8vIEZpeGVzIGEgYnVnIHdoaWNoIHNxdWFzaCBpbWFnZSB2ZXJ0aWNhbGx5IHdoaWxlIGRyYXdpbmcgaW50byBjYW52YXMgZm9yIHNvbWUgaW1hZ2VzLlxuLy8gVGhpcyBpcyBhIGJ1ZyBpbiBpT1M2IGRldmljZXMuIFRoaXMgZnVuY3Rpb24gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3RvbWl0YS9pb3MtaW1hZ2VmaWxlLW1lZ2FwaXhlbFxubGV0ICQzZWQyNjlmMmYwZmIyMjRiJHZhciRkZXRlY3RWZXJ0aWNhbFNxdWFzaCA9IGZ1bmN0aW9uKGltZykge1xuICAgIGxldCBpdyA9IGltZy5uYXR1cmFsV2lkdGg7XG4gICAgbGV0IGloID0gaW1nLm5hdHVyYWxIZWlnaHQ7XG4gICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaWg7XG4gICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgIGxldCB7IGRhdGE6IGRhdGEgIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKDEsIDAsIDEsIGloKTtcbiAgICAvLyBzZWFyY2ggaW1hZ2UgZWRnZSBwaXhlbCBwb3NpdGlvbiBpbiBjYXNlIGl0IGlzIHNxdWFzaGVkIHZlcnRpY2FsbHkuXG4gICAgbGV0IHN5ID0gMDtcbiAgICBsZXQgZXkgPSBpaDtcbiAgICBsZXQgcHkgPSBpaDtcbiAgICB3aGlsZShweSA+IHN5KXtcbiAgICAgICAgbGV0IGFscGhhID0gZGF0YVsocHkgLSAxKSAqIDQgKyAzXTtcbiAgICAgICAgaWYgKGFscGhhID09PSAwKSBleSA9IHB5O1xuICAgICAgICBlbHNlIHN5ID0gcHk7XG4gICAgICAgIHB5ID0gZXkgKyBzeSA+PiAxO1xuICAgIH1cbiAgICBsZXQgcmF0aW8gPSBweSAvIGloO1xuICAgIGlmIChyYXRpbyA9PT0gMCkgcmV0dXJuIDE7XG4gICAgZWxzZSByZXR1cm4gcmF0aW87XG59O1xuLy8gQSByZXBsYWNlbWVudCBmb3IgY29udGV4dC5kcmF3SW1hZ2Vcbi8vIChhcmdzIGFyZSBmb3Igc291cmNlIGFuZCBkZXN0aW5hdGlvbikuXG52YXIgJDNlZDI2OWYyZjBmYjIyNGIkdmFyJGRyYXdJbWFnZUlPU0ZpeCA9IGZ1bmN0aW9uKGN0eCwgaW1nLCBzeCwgc3ksIHN3LCBzaCwgZHgsIGR5LCBkdywgZGgpIHtcbiAgICBsZXQgdmVydFNxdWFzaFJhdGlvID0gJDNlZDI2OWYyZjBmYjIyNGIkdmFyJGRldGVjdFZlcnRpY2FsU3F1YXNoKGltZyk7XG4gICAgcmV0dXJuIGN0eC5kcmF3SW1hZ2UoaW1nLCBzeCwgc3ksIHN3LCBzaCwgZHgsIGR5LCBkdywgZGggLyB2ZXJ0U3F1YXNoUmF0aW8pO1xufTtcbi8vIEJhc2VkIG9uIE1pbmlmeUpwZWdcbi8vIFNvdXJjZTogaHR0cDovL3d3dy5wZXJyeS5jei9maWxlcy9FeGlmUmVzdG9yZXIuanNcbi8vIGh0dHA6Ly9lbGljb24uYmxvZzU3LmZjMi5jb20vYmxvZy1lbnRyeS0yMDYuaHRtbFxuY2xhc3MgJDNlZDI2OWYyZjBmYjIyNGIkdmFyJEV4aWZSZXN0b3JlIHtcbiAgICBzdGF0aWMgaW5pdENsYXNzKCkge1xuICAgICAgICB0aGlzLktFWV9TVFIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGU2NChpbnB1dCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgbGV0IGNocjEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaHIyID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2hyMyA9IFwiXCI7XG4gICAgICAgIGxldCBlbmMxID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZW5jMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGVuYzMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBlbmM0ID0gXCJcIjtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dFtpKytdO1xuICAgICAgICAgICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgICAgICAgICBjaHIzID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGVuYzEgPSBjaHIxID4+IDI7XG4gICAgICAgICAgICBlbmMyID0gKGNocjEgJiAzKSA8PCA0IHwgY2hyMiA+PiA0O1xuICAgICAgICAgICAgZW5jMyA9IChjaHIyICYgMTUpIDw8IDIgfCBjaHIzID4+IDY7XG4gICAgICAgICAgICBlbmM0ID0gY2hyMyAmIDYzO1xuICAgICAgICAgICAgaWYgKGlzTmFOKGNocjIpKSBlbmMzID0gZW5jNCA9IDY0O1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4oY2hyMykpIGVuYzQgPSA2NDtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMSkgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzIpICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMzKSArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jNCk7XG4gICAgICAgICAgICBjaHIxID0gY2hyMiA9IGNocjMgPSBcIlwiO1xuICAgICAgICAgICAgZW5jMSA9IGVuYzIgPSBlbmMzID0gZW5jNCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIShpIDwgaW5wdXQubGVuZ3RoKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgc3RhdGljIHJlc3RvcmUob3JpZ0ZpbGVCYXNlNjQsIHJlc2l6ZWRGaWxlQmFzZTY0KSB7XG4gICAgICAgIGlmICghb3JpZ0ZpbGVCYXNlNjQubWF0Y2goXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiKSkgcmV0dXJuIHJlc2l6ZWRGaWxlQmFzZTY0O1xuICAgICAgICBsZXQgcmF3SW1hZ2UgPSB0aGlzLmRlY29kZTY0KG9yaWdGaWxlQmFzZTY0LnJlcGxhY2UoXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiLCBcIlwiKSk7XG4gICAgICAgIGxldCBzZWdtZW50cyA9IHRoaXMuc2xpY2UyU2VnbWVudHMocmF3SW1hZ2UpO1xuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmV4aWZNYW5pcHVsYXRpb24ocmVzaXplZEZpbGVCYXNlNjQsIHNlZ21lbnRzKTtcbiAgICAgICAgcmV0dXJuIGBkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCR7dGhpcy5lbmNvZGU2NChpbWFnZSl9YDtcbiAgICB9XG4gICAgc3RhdGljIGV4aWZNYW5pcHVsYXRpb24ocmVzaXplZEZpbGVCYXNlNjQsIHNlZ21lbnRzKSB7XG4gICAgICAgIGxldCBleGlmQXJyYXkgPSB0aGlzLmdldEV4aWZBcnJheShzZWdtZW50cyk7XG4gICAgICAgIGxldCBuZXdJbWFnZUFycmF5ID0gdGhpcy5pbnNlcnRFeGlmKHJlc2l6ZWRGaWxlQmFzZTY0LCBleGlmQXJyYXkpO1xuICAgICAgICBsZXQgYUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5ld0ltYWdlQXJyYXkpO1xuICAgICAgICByZXR1cm4gYUJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIGdldEV4aWZBcnJheShzZWdtZW50cykge1xuICAgICAgICBsZXQgc2VnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIHdoaWxlKHggPCBzZWdtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgc2VnID0gc2VnbWVudHNbeF07XG4gICAgICAgICAgICBpZiAoc2VnWzBdID09PSAyNTUgJiBzZWdbMV0gPT09IDIyNSkgcmV0dXJuIHNlZztcbiAgICAgICAgICAgIHgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHN0YXRpYyBpbnNlcnRFeGlmKHJlc2l6ZWRGaWxlQmFzZTY0LCBleGlmQXJyYXkpIHtcbiAgICAgICAgbGV0IGltYWdlRGF0YSA9IHJlc2l6ZWRGaWxlQmFzZTY0LnJlcGxhY2UoXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiLCBcIlwiKTtcbiAgICAgICAgbGV0IGJ1ZiA9IHRoaXMuZGVjb2RlNjQoaW1hZ2VEYXRhKTtcbiAgICAgICAgbGV0IHNlcGFyYXRlUG9pbnQgPSBidWYuaW5kZXhPZigyNTUsIDMpO1xuICAgICAgICBsZXQgbWFlID0gYnVmLnNsaWNlKDAsIHNlcGFyYXRlUG9pbnQpO1xuICAgICAgICBsZXQgYXRvID0gYnVmLnNsaWNlKHNlcGFyYXRlUG9pbnQpO1xuICAgICAgICBsZXQgYXJyYXkgPSBtYWU7XG4gICAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KGV4aWZBcnJheSk7XG4gICAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KGF0byk7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgc3RhdGljIHNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlQXJyYXkpIHtcbiAgICAgICAgbGV0IGhlYWQgPSAwO1xuICAgICAgICBsZXQgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHJhd0ltYWdlQXJyYXlbaGVhZF0gPT09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09PSAyMTgpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHJhd0ltYWdlQXJyYXlbaGVhZF0gPT09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09PSAyMTYpIGhlYWQgKz0gMjtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJhd0ltYWdlQXJyYXlbaGVhZCArIDJdICogMjU2ICsgcmF3SW1hZ2VBcnJheVtoZWFkICsgM107XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvaW50ID0gaGVhZCArIGxlbmd0aCArIDI7XG4gICAgICAgICAgICAgICAgbGV0IHNlZyA9IHJhd0ltYWdlQXJyYXkuc2xpY2UoaGVhZCwgZW5kUG9pbnQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnKTtcbiAgICAgICAgICAgICAgICBoZWFkID0gZW5kUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVhZCA+IHJhd0ltYWdlQXJyYXkubGVuZ3RoKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGU2NChpbnB1dCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgbGV0IGNocjEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaHIyID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2hyMyA9IFwiXCI7XG4gICAgICAgIGxldCBlbmMxID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZW5jMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGVuYzMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBlbmM0ID0gXCJcIjtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgYnVmID0gW107XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQS1aLCBhLXosIDAtOSwgKywgLywgb3IgPVxuICAgICAgICBsZXQgYmFzZTY0dGVzdCA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZztcbiAgICAgICAgaWYgKGJhc2U2NHRlc3QuZXhlYyhpbnB1dCkpIGNvbnNvbGUud2FybihcIlRoZXJlIHdlcmUgaW52YWxpZCBiYXNlNjQgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdGV4dC5cXG5WYWxpZCBiYXNlNjQgY2hhcmFjdGVycyBhcmUgQS1aLCBhLXosIDAtOSwgJysnLCAnLycsYW5kICc9J1xcbkV4cGVjdCBlcnJvcnMgaW4gZGVjb2RpbmcuXCIpO1xuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcbiAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICBlbmMxID0gdGhpcy5LRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgZW5jMiA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgIGVuYzMgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgICAgICBlbmM0ID0gdGhpcy5LRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgY2hyMSA9IGVuYzEgPDwgMiB8IGVuYzIgPj4gNDtcbiAgICAgICAgICAgIGNocjIgPSAoZW5jMiAmIDE1KSA8PCA0IHwgZW5jMyA+PiAyO1xuICAgICAgICAgICAgY2hyMyA9IChlbmMzICYgMykgPDwgNiB8IGVuYzQ7XG4gICAgICAgICAgICBidWYucHVzaChjaHIxKTtcbiAgICAgICAgICAgIGlmIChlbmMzICE9PSA2NCkgYnVmLnB1c2goY2hyMik7XG4gICAgICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIGJ1Zi5wdXNoKGNocjMpO1xuICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXCJcIjtcbiAgICAgICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCEoaSA8IGlucHV0Lmxlbmd0aCkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxufVxuJDNlZDI2OWYyZjBmYjIyNGIkdmFyJEV4aWZSZXN0b3JlLmluaXRDbGFzcygpO1xuLypcbiAqIGNvbnRlbnRsb2FkZWQuanNcbiAqXG4gKiBBdXRob3I6IERpZWdvIFBlcmluaSAoZGllZ28ucGVyaW5pIGF0IGdtYWlsLmNvbSlcbiAqIFN1bW1hcnk6IGNyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3IgRE9NQ29udGVudExvYWRlZFxuICogVXBkYXRlZDogMjAxMDEwMjBcbiAqIExpY2Vuc2U6IE1JVFxuICogVmVyc2lvbjogMS4yXG4gKlxuICogVVJMOlxuICogaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0NvbnRlbnRMb2FkZWQvXG4gKiBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vQ29udGVudExvYWRlZC9NSVQtTElDRU5TRVxuICovIC8vIEB3aW4gd2luZG93IHJlZmVyZW5jZVxuLy8gQGZuIGZ1bmN0aW9uIHJlZmVyZW5jZVxubGV0ICQzZWQyNjlmMmYwZmIyMjRiJHZhciRjb250ZW50TG9hZGVkID0gZnVuY3Rpb24od2luLCBmbikge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgbGV0IHRvcCA9IHRydWU7XG4gICAgbGV0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICBsZXQgcm9vdCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgbGV0IGFkZCA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXCJhZGRFdmVudExpc3RlbmVyXCIgOiBcImF0dGFjaEV2ZW50XCI7XG4gICAgbGV0IHJlbSA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXCJyZW1vdmVFdmVudExpc3RlbmVyXCIgOiBcImRldGFjaEV2ZW50XCI7XG4gICAgbGV0IHByZSA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXCJcIiA6IFwib25cIjtcbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJyZWFkeXN0YXRlY2hhbmdlXCIgJiYgZG9jLnJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikgcmV0dXJuO1xuICAgICAgICAoZS50eXBlID09PSBcImxvYWRcIiA/IHdpbiA6IGRvYylbcmVtXShwcmUgKyBlLnR5cGUsIGluaXQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFkb25lICYmIChkb25lID0gdHJ1ZSkpIHJldHVybiBmbi5jYWxsKHdpbiwgZS50eXBlIHx8IGUpO1xuICAgIH07XG4gICAgdmFyIHBvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJvb3QuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBvbGwsIDUwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5pdChcInBvbGxcIik7XG4gICAgfTtcbiAgICBpZiAoZG9jLnJlYWR5U3RhdGUgIT09IFwiY29tcGxldGVcIikge1xuICAgICAgICBpZiAoZG9jLmNyZWF0ZUV2ZW50T2JqZWN0ICYmIHJvb3QuZG9TY3JvbGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdG9wID0gIXdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvcCkgcG9sbCgpO1xuICAgICAgICB9XG4gICAgICAgIGRvY1thZGRdKHByZSArIFwiRE9NQ29udGVudExvYWRlZFwiLCBpbml0LCBmYWxzZSk7XG4gICAgICAgIGRvY1thZGRdKHByZSArIFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBpbml0LCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB3aW5bYWRkXShwcmUgKyBcImxvYWRcIiwgaW5pdCwgZmFsc2UpO1xuICAgIH1cbn07XG5mdW5jdGlvbiAkM2VkMjY5ZjJmMGZiMjI0YiR2YXIkX19ndWFyZF9fKHZhbHVlLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlICE9PSBudWxsID8gdHJhbnNmb3JtKHZhbHVlKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uICQzZWQyNjlmMmYwZmIyMjRiJHZhciRfX2d1YXJkTWV0aG9kX18ob2JqLCBtZXRob2ROYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9ialttZXRob2ROYW1lXSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJhbnNmb3JtKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5cbmV4cG9ydCB7JDNlZDI2OWYyZjBmYjIyNGIkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSBhcyBkZWZhdWx0LCAkM2VkMjY5ZjJmMGZiMjI0YiRleHBvcnQkMmUyYmNkODczOWFlMDM5IGFzIERyb3B6b25lfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyb3B6b25lLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==